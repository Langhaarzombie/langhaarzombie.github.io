


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Functions &mdash; QuTiP 4.7 Documentation</title>
  

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../static/site.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}})</script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Change Log" href="../changelog.html" />
    <link rel="prev" title="Classes" href="classes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.states">Quantum States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qobj">Quantum Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.dimensions">Operators and Superoperator Dimensions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.continuous_variables">Continuous Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measurement">Measurement</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.measurement">Measurement of quantum states</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.krylovsolve">Krylov Subspace Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.rhs_generate">Time-dependent problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.scattering">Scattering in Quantum Optical Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.piqs">Permutational Invariance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lattice">Lattice</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.lattice">Lattice Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.topology">Topology</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.visualization">Graphs and Visualization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.operations.gates">Gates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.qasm">Circuit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.nonmarkov.transfertensor">Non-Markovian Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.control.pulseoptim">Optimal control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grape">GRAPE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crab">CRAB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.graph">Graph Theory Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-utilities">Utility Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.parallel">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.semidefinite">Semidefinite Programming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.states" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.states.basis">
<code class="sig-name descname"><span class="pre">basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Qobj representing the requested number state <code class="docutils literal notranslate"><span class="pre">|n&gt;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [1.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.bell_state">
<code class="sig-name descname"><span class="pre">bell_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'00'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#bell_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.bell_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the selected Bell state:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\lvert B_{00}\rangle &amp;=
    \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\
\lvert B_{01}\rangle &amp;=
    \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\
\lvert B_{10}\rangle &amp;=
    \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\
\lvert B_{11}\rangle &amp;=
    \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\
\end{aligned}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p>Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.bra">
<code class="sig-name descname"><span class="pre">bra</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#bra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.bra" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle bra state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:</p>
<ul class="simple">
<li><p>‘g’/’e’ (ground and excited state)</p></li>
<li><p>‘u’/’d’ (spin up and down)</p></li>
<li><p>‘H’/’V’ (horizontal and vertical polarization)</p></li>
</ul>
<p>Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bra</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  1.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.  0.  0.  0.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  1.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.  0.  1.  0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.coherent">
<code class="sig-name descname"><span class="pre">coherent</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#coherent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue of coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method ‘analytic’.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for coherent state</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting state is normalized. With ‘analytic’ method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.coherent_dm">
<code class="sig-name descname"><span class="pre">coherent_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#coherent_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.coherent</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue for coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent density matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of coherent state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting density matrix is normalized. With ‘analytic’ method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.enr_fock">
<code class="sig-name descname"><span class="pre">enr_fock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#enr_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.enr_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.enr_state_dictionaries">
<code class="sig-name descname"><span class="pre">enr_state_dictionaries</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#enr_state_dictionaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.enr_state_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list</strong></dt><dd><p>A list with the number of states in each sub-system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum numbers of dimension</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>nstates, state2idx, idx2state: integer, dict, list</dt><dd><p>The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a list containing the state tuples
ordered by state indices. state2idx and idx2state are reverses of
each other, i.e., state2idx[idx2state[idx]] = idx and
idx2state[state2idx[state]] = state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.enr_thermal_dm">
<code class="sig-name descname"><span class="pre">enr_thermal_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#enr_thermal_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.enr_thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">integer</span></dt><dd><p>The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">Qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.fock">
<code class="sig-name descname"><span class="pre">fock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.basis</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Requested number state <span class="math notranslate nohighlight">\(\left|n\right&gt;\)</span>.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.fock_dm">
<code class="sig-name descname"><span class="pre">fock_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#fock_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.fock</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of Fock state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.ghz_state">
<code class="sig-name descname"><span class="pre">ghz_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#ghz_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.ghz_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the N-qubit GHZ-state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int (default=3)</span></dt><dd><p>Number of qubits in state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">qobj</span></dt><dd><p>N-qubit GHZ-state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.ket">
<code class="sig-name descname"><span class="pre">ket</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle ket state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.ket2dm">
<code class="sig-name descname"><span class="pre">ket2dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#ket2dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">qobj</span></dt><dd><p>Ket or bra type quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.maximally_mixed_dm">
<code class="sig-name descname"><span class="pre">maximally_mixed_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#maximally_mixed_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.maximally_mixed_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximally mixed density matrix for a Hilbert space of
dimension N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.phase_basis">
<code class="sig-name descname"><span class="pre">phase_basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#phase_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis vectors in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float (default=0)</span></dt><dd><p>Reference phase angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.projection">
<code class="sig-name descname"><span class="pre">projection</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection operator that projects state <span class="math notranslate nohighlight">\(\lvert m\rangle\)</span> on
state <span class="math notranslate nohighlight">\(\lvert n\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n, m</strong><span class="classifier">float</span></dt><dd><p>The number states in the projection.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the projector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Requested projection operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.qutrit_basis">
<code class="sig-name descname"><span class="pre">qutrit_basis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#qutrit_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qstates</strong><span class="classifier">array</span></dt><dd><p>Array of qutrit basis vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.singlet_state">
<code class="sig-name descname"><span class="pre">singlet_state</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#singlet_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.singlet_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the two particle singlet-state:</p>
<div class="math notranslate nohighlight">
\[\lvert S\rangle = \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\]</div>
<p>that is identical to the fourth bell state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p><span class="math notranslate nohighlight">\(\lvert B_{11}\rangle\)</span> Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.spin_coherent">
<code class="sig-name descname"><span class="pre">spin_coherent</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ket'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#spin_coherent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.spin_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the coherent spin state <span class="math notranslate nohighlight">\(\lvert \theta, \phi\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle from z axis.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle from x axis.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin coherent state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.spin_state">
<code class="sig-name descname"><span class="pre">spin_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ket'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#spin_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.spin_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the spin state <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span>, i.e. the
eigenstate of the spin-j Sz operator with eigenvalue m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state ().</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Eigenvalue of the spin-j Sz operator.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.state_index_number">
<code class="sig-name descname"><span class="pre">state_index_number</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#state_index_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>index</strong><span class="classifier">integer</span></dt><dd><p>The index of the state in standard enumeration ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">tuple</span></dt><dd><p>The state number tuple corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.state_number_enumerate">
<code class="sig-name descname"><span class="pre">state_number_enumerate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#state_number_enumerate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerates all the state number tuples (quantum numbers of
the form (n1, n2, n3, …)) for a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span> 
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> 
<span class="go">( 0  0 )</span>
<span class="go">( 0  1 )</span>
<span class="go">( 1  0 )</span>
<span class="go">( 1  1 )</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer (None)</span></dt><dd><p>Restrict state space to states with excitation numbers below or
equal to this value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state_number</strong><span class="classifier">tuple</span></dt><dd><p>Successive state number tuples that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.state_number_index">
<code class="sig-name descname"><span class="pre">state_number_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#state_number_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.state_number_qobj">
<code class="sig-name descname"><span class="pre">state_number_qobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#state_number_qobj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The state as a <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> instance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.thermal_dm">
<code class="sig-name descname"><span class="pre">thermal_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'operator'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#thermal_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">float</span></dt><dd><p>Expectation value for number of particles in thermal state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">string</span></code> that sets the method used to generate the
thermal state probabilities</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘operator’ method (default) generates
the thermal state using the truncated number operator <code class="docutils literal notranslate"><span class="pre">num(N)</span></code>. This
is the method that should be used in computations. The
‘analytic’ method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;analytic&#39;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.triplet_states">
<code class="sig-name descname"><span class="pre">triplet_states</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#triplet_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.triplet_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the two particle triplet-states:</p>
<div class="math notranslate nohighlight">
\[\lvert T_1\rangle = \lvert11\rangle
\lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle)
\lvert T_3\rangle = \lvert00\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trip_states</strong><span class="classifier">list</span></dt><dd><p>2 particle triplet states</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.w_state">
<code class="sig-name descname"><span class="pre">w_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#w_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.w_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the N-qubit W-state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int (default=3)</span></dt><dd><p>Number of qubits in state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">qobj</span></dt><dd><p>N-qubit W-state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.states.zero_ket">
<code class="sig-name descname"><span class="pre">zero_ket</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/states.html#zero_ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.states.zero_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the zero ket vector with shape Nx1 and
dimensions <cite>dims</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Hilbert space dimensionality</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Optional dimensions if ket corresponds to
a composite Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>zero_ket</strong><span class="classifier">qobj</span></dt><dd><p>Zero ket on given Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="py function">
<dt id="qutip.operators.charge">
<code class="sig-name descname"><span class="pre">charge</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Nmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#charge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the diagonal charge operator over charge states
from Nmin to Nmax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nmax</strong><span class="classifier">int</span></dt><dd><p>Maximum charge state to consider.</p>
</dd>
<dt><strong>Nmin</strong><span class="classifier">int (default = -Nmax)</span></dt><dd><p>Lowest charge state to consider.</p>
</dd>
<dt><strong>frac</strong><span class="classifier">float (default = 1)</span></dt><dd><p>Specify fractional charge if needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">Qobj</span></dt><dd><p>Charge operator over [Nmin,Nmax].</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.commutator">
<code class="sig-name descname"><span class="pre">commutator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'normal'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutator of kind <cite>kind</cite> (normal, anti) of the
two operators A and B.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.create">
<code class="sig-name descname"><span class="pre">create</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#create"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for raising operator.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.destroy">
<code class="sig-name descname"><span class="pre">destroy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#destroy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for lowering operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.displace">
<code class="sig-name descname"><span class="pre">displace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#displace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Displacement amplitude.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Displacement operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.enr_destroy">
<code class="sig-name descname"><span class="pre">enr_destroy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#enr_destroy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.enr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div><p>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
…</p>
</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div><p>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</p>
</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, …, a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a_ops</strong><span class="classifier">list of qobj</span></dt><dd><p>A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.enr_identity">
<code class="sig-name descname"><span class="pre">enr_identity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#enr_identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.enr_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.identity">
<code class="sig-name descname"><span class="pre">identity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><code class="xref py py-func docutils literal notranslate"><span class="pre">qeye</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.jmat">
<code class="sig-name descname"><span class="pre">jmat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#jmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>args</strong><span class="classifier">str</span></dt><dd><p>Which operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no args given, then output is [‘x’,’y’,’z’]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>jmat</strong><span class="classifier">qobj / ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> for requested spin operator(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.momentum">
<code class="sig-name descname"><span class="pre">momentum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#momentum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum operator p=-1j/sqrt(2)*(a-a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Momentum operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.num">
<code class="sig-name descname"><span class="pre">num</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#num"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The dimension of the Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>oper: qobj</dt><dd><p>Qobj for number operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.phase">
<code class="sig-name descname"><span class="pre">phase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float</span></dt><dd><p>Reference phase.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Phase operator with respect to reference phase.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.position">
<code class="sig-name descname"><span class="pre">position</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#position"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Position operator x=1/sqrt(2)*(a+a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Position operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.qdiags">
<code class="sig-name descname"><span class="pre">qdiags</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#qdiags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.qdiags" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an operator from an array of diagonals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diagonals</strong><span class="classifier">sequence of array_like</span></dt><dd><p>Array of elements to place along the selected diagonals.</p>
</dd>
<dt><strong>offsets</strong><span class="classifier">sequence of ints</span></dt><dd><dl class="simple">
<dt>Sequence for diagonals to be set:</dt><dd><ul class="simple">
<li><p>k=0 main diagonal</p></li>
<li><p>k&gt;0 kth upper diagonal</p></li>
<li><p>k&lt;0 kth lower diagonal</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>dims</strong><span class="classifier">list, optional</span></dt><dd><p>Dimensions for operator</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list, tuple, optional</span></dt><dd><p>Shape of operator.  If omitted, a square operator large enough
to contain the diagonals is generated.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.diags</span></code></dt><dd><p>for usage information.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function requires SciPy 0.11+.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qdiags</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          1.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.41421356  0.        ]</span>
<span class="go"> [ 0.          0.          0.          1.73205081]</span>
<span class="go"> [ 0.          0.          0.          0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.qeye">
<code class="sig-name descname"><span class="pre">qeye</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#qeye"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[1. 0. 0. 0.]</span>
<span class="go"> [0. 1. 0. 0.]</span>
<span class="go"> [0. 0. 1. 0.]</span>
<span class="go"> [0. 0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.qutrit_ops">
<code class="sig-name descname"><span class="pre">qutrit_ops</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#qutrit_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>opers: array</dt><dd><p><cite>array</cite> of qutrit operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.qzero">
<code class="sig-name descname"><span class="pre">qzero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#qzero"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.qzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qzero</strong><span class="classifier">qobj</span></dt><dd><p>Zero operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.sigmam">
<code class="sig-name descname"><span class="pre">sigmam</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#sigmam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.sigmap">
<code class="sig-name descname"><span class="pre">sigmap</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#sigmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmap</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.sigmax">
<code class="sig-name descname"><span class="pre">sigmax</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#sigmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.sigmay">
<code class="sig-name descname"><span class="pre">sigmay</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#sigmay"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.sigmaz">
<code class="sig-name descname"><span class="pre">sigmaz</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#sigmaz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.spin_Jm">
<code class="sig-name descname"><span class="pre">spin_Jm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#spin_Jm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.spin_Jm" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j annihilation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.spin_Jp">
<code class="sig-name descname"><span class="pre">spin_Jp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#spin_Jp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.spin_Jp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j creation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.spin_Jx">
<code class="sig-name descname"><span class="pre">spin_Jx</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#spin_Jx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.spin_Jx" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j x operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.spin_Jy">
<code class="sig-name descname"><span class="pre">spin_Jy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#spin_Jy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.spin_Jy" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j y operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.spin_Jz">
<code class="sig-name descname"><span class="pre">spin_Jz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#spin_Jz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.spin_Jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j z operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#squeeze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of hilbert space.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.squeezing">
<code class="sig-name descname"><span class="pre">squeezing</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#squeezing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math notranslate nohighlight">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>a1</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Operator 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Operator 2.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.operators.tunneling">
<code class="sig-name descname"><span class="pre">tunneling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/operators.html#tunneling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.operators.tunneling" title="Permalink to this definition">¶</a></dt>
<dd><p>Tunneling operator with elements of the form
<span class="math notranslate nohighlight">\(\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int (default = 1)</span></dt><dd><p>Number of excitations in tunneling event.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">Qobj</span></dt><dd><p>Tunneling operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.qobj">
<span id="quantum-objects"></span><span id="functions-rand"></span><h3>Quantum Objects<a class="headerlink" href="#module-qutip.qobj" title="Permalink to this headline">¶</a></h3>
<p>The Quantum Object (Qobj) class, for representing quantum states and
operators, and related functions.</p>
<dl class="py function">
<dt id="qutip.qobj.dag">
<code class="sig-name descname"><span class="pre">dag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjont operator (dagger) of a quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Input quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Adjoint of input operator</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. It is recommended to use
the <code class="docutils literal notranslate"><span class="pre">dag()</span></code> Qobj method.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.dims">
<code class="sig-name descname"><span class="pre">dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dims attribute of a quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>inpt</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Input quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of the quantum objects dimensions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.dims</cite>
attribute is recommended.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isbra">
<code class="sig-name descname"><span class="pre">isbra</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isbra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isbra" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is a bra-vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isbra</strong><span class="classifier">bool</span></dt><dd><p>True if Qobj is bra-vector, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isbra</cite>
attribute is recommended.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isket</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isequal">
<code class="sig-name descname"><span class="pre">isequal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isequal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if two qobj objects are equal to within given tolerance.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Qobj one</p>
</dd>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Qobj two</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerence for equality to be valid</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isequal</strong><span class="classifier">bool</span></dt><dd><p>True if qobjs are equal, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Instead, it is recommended
to use the equality operator of Qobj instances instead: A == B.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isherm">
<code class="sig-name descname"><span class="pre">isherm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isherm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isherm" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given operator is Hermitian.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isherm</strong><span class="classifier">bool</span></dt><dd><p>True if operator is Hermitian, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isherm</cite>
attribute is recommended.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isherm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isket">
<code class="sig-name descname"><span class="pre">isket</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isket" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is a ket-vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isket</strong><span class="classifier">bool</span></dt><dd><p>True if qobj is ket-vector, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isket</cite>
attribute is recommended.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isket</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isoper">
<code class="sig-name descname"><span class="pre">isoper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isoper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isoper" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is a operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isoper</strong><span class="classifier">bool</span></dt><dd><p>True if Qobj is operator, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isoper</cite>
attribute is recommended.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isoper</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isoperbra">
<code class="sig-name descname"><span class="pre">isoperbra</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isoperbra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isoperbra" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is an operator in row vector form
(operator-bra).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isoperbra</strong><span class="classifier">bool</span></dt><dd><p>True if Qobj is operator-bra, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isoperbra</cite>
attribute is recommended.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.isoperket">
<code class="sig-name descname"><span class="pre">isoperket</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#isoperket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.isoperket" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is an operator in column vector form
(operator-ket).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>isoperket</strong><span class="classifier">bool</span></dt><dd><p>True if Qobj is operator-ket, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.isoperket</cite>
attribute is recommended.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.issuper">
<code class="sig-name descname"><span class="pre">issuper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#issuper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.issuper" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if given quantum object is a super-operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>issuper</strong><span class="classifier">bool</span></dt><dd><p>True if Qobj is superoperator, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.issuper</cite>
attribute is recommended.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.ptrace">
<code class="sig-name descname"><span class="pre">ptrace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#ptrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.ptrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial trace of the Qobj with selected components remaining.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Composite quantum object.</p>
</dd>
<dt><strong>sel</strong><span class="classifier">int/list</span></dt><dd><p>An <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of components to keep after partial trace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object representing partial trace with selected components
remaining.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. It is recommended to use
the <code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> Qobj method.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.qobj_list_evaluate">
<code class="sig-name descname"><span class="pre">qobj_list_evaluate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#qobj_list_evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.qobj_list_evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: See Qobj.evaluate</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qobj.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qobj.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape attribute of a quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>inpt</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Input quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of the quantum objects shape.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. Using the <cite>Qobj.shape</cite>
attribute is recommended.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj’s is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="py function">
<dt id="qutip.random_objects.rand_dm">
<code class="sig-name descname"><span class="pre">rand_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int, ndarray, list</span></dt><dd><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated density matrix.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output density matrix.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>Seed for the random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN density matrix quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math notranslate nohighlight">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_dm_ginibre">
<code class="sig-name descname"><span class="pre">rand_dm_ginibre</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_dm_ginibre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_ginibre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Ginibre random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id2"><span>[BCSZ08]</span></a>. If <code class="docutils literal notranslate"><span class="pre">rank</span></code> is <cite>None</cite>, a full-rank
(Hilbert-Schmidt ensemble) random density operator will be
returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or None</span></dt><dd><p>Rank of the sampled density operator. If None, a full-rank
density operator is generated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>An N × N density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_dm_hs">
<code class="sig-name descname"><span class="pre">rand_dm_hs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_dm_hs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Hilbert-Schmidt random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id3"><span>[BCSZ08]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>A dim × dim density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_herm">
<code class="sig-name descname"><span class="pre">rand_herm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_def</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>If ‘N’ is an integer, uses <span class="math notranslate nohighlight">\(H=0.5*(X+X^{+})\)</span> where <span class="math notranslate nohighlight">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>. Else uses
complex Jacobi rotations when ‘N’ is given by an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int, list/ndarray</span></dt><dd><p>If int, then shape of output operator. If list/ndarray then eigenvalues
of generated operator.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output Hermitian operator.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>pos_def</strong><span class="classifier">bool (default=False)</span></dt><dd><p>Return a positive semi-definite matrix (by diagonal dominance).</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>seed for the random number generator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN Hermitian quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If given a list/ndarray as input ‘N’, this function returns a
random Hermitian object with eigenvalues given in the list/ndarray.
This is accomplished via complex Jacobi rotations.  While this method
is ~50% faster than the corresponding (real only) Matlab code, it should
not be repeatedly used for generating matrices larger than ~1000x1000.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_ket">
<code class="sig-name descname"><span class="pre">rand_ket</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of rows for output quantum vector.
If None, N is deduced from dims.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output ket state.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[1]].</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>Seed for the random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Nx1 ket quantum state vector.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If neither <cite>N</cite> or <cite>dims</cite> are specified.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_ket_haar">
<code class="sig-name descname"><span class="pre">rand_ket_haar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_ket_haar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_ket_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random pure state of dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code> by
applying a Haar random unitary to a fixed pure state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the state vector to be returned.
If None, N is deduced from dims.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of ints, or None</span></dt><dd><p>Dimensions of the resultant quantum object.
If None, [[N],[1]] is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>psi</strong><span class="classifier">Qobj</span></dt><dd><p>A random state vector drawn from the Haar measure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If neither <cite>N</cite> or <cite>dims</cite> are specified.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_stochastic">
<code class="sig-name descname"><span class="pre">rand_stochastic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_stochastic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_stochastic" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a random stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of matrix.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output density matrix.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str (Default = ‘left’)</span></dt><dd><p>Generate ‘left’ or ‘right’ stochastic matrix.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Quantum operator form of stochastic matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_super">
<code class="sig-name descname"><span class="pre">rand_super</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly drawn superoperator acting on operators acting on
N dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_super_bcsz">
<code class="sig-name descname"><span class="pre">rand_super_bcsz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enforce_tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_super_bcsz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_super_bcsz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random superoperator drawn from the Bruzda
et al ensemble for CPTP maps <a class="reference internal" href="../biblio.html#bcsz08" id="id4"><span>[BCSZ08]</span></a>. Note that due to
finite numerical precision, for ranks less than full-rank,
zero eigenvalues may become slightly negative, such that the
returned operator is not actually completely positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>enforce_tp</strong><span class="classifier">bool</span></dt><dd><p>If True, the trace-preserving condition of <a class="reference internal" href="../biblio.html#bcsz08" id="id5"><span>[BCSZ08]</span></a> is enforced;
otherwise only complete positivity is enforced.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or None</span></dt><dd><p>Rank of the sampled superoperator. If None, a full-rank
superoperator is generated.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>A superoperator acting on vectorized dim × dim density operators,
sampled from the BCSZ distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_unitary">
<code class="sig-name descname"><span class="pre">rand_unitary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math notranslate nohighlight">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Shape of output quantum operator.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output Unitary operator.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>NxN Unitary quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.random_objects.rand_unitary_haar">
<code class="sig-name descname"><span class="pre">rand_unitary_haar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_unitary_haar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random unitary matrix of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code>, using the algorithm of <a class="reference internal" href="../biblio.html#mez07" id="id6"><span>[Mez07]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of the unitary to be returned.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of lists of int, or None</span></dt><dd><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Unitary of dims <code class="docutils literal notranslate"><span class="pre">[[dim],</span> <span class="pre">[dim]]</span></code> drawn from the Haar
measure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ladder</span><span class="p">:</span>          <span class="n">Lambda</span><span class="p">:</span>                 <span class="n">Vee</span><span class="p">:</span>
                            <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>
  <span class="o">-------|</span><span class="n">three</span><span class="o">&gt;</span>           <span class="o">-------</span>                      <span class="o">-------</span>
     <span class="o">|</span>                       <span class="o">/</span> \             <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>         <span class="o">/</span>
     <span class="o">|</span>                      <span class="o">/</span>   \           <span class="o">-------</span>       <span class="o">/</span>
     <span class="o">|</span>                     <span class="o">/</span>     \             \         <span class="o">/</span>
  <span class="o">-------|</span><span class="n">two</span><span class="o">&gt;</span>            <span class="o">/</span>       \             \       <span class="o">/</span>
     <span class="o">|</span>                   <span class="o">/</span>         \             \     <span class="o">/</span>
     <span class="o">|</span>                  <span class="o">/</span>           \             \   <span class="o">/</span>
     <span class="o">|</span>                 <span class="o">/</span>        <span class="o">--------</span>           \ <span class="o">/</span>
  <span class="o">-------|</span><span class="n">one</span><span class="o">&gt;</span>      <span class="o">-------</span>      <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>         <span class="o">-------</span>
                     <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r0be8dcf25d86-1" id="id7">[1]</a> .</p>
<dl class="citation">
<dt class="label" id="r0be8dcf25d86-1"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>Shore, B. W., “The Theory of Coherent Atomic Excitation”,
Wiley, 1990.</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Contributed by Markus Baden, Oct. 07, 2011</p>
</div>
<dl class="py function">
<dt id="qutip.three_level_atom.three_level_basis">
<code class="sig-name descname"><span class="pre">three_level_basis</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/three_level_atom.html#three_level_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array</span></dt><dd><p><cite>array</cite> of three level atom basis vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.three_level_atom.three_level_ops">
<code class="sig-name descname"><span class="pre">three_level_ops</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/three_level_atom.html#three_level_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ops</strong><span class="classifier">array</span></dt><dd><p><cite>array</cite> of three level operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.superoperator.lindblad_dissipator">
<code class="sig-name descname"><span class="pre">lindblad_dissipator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#lindblad_dissipator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math notranslate nohighlight">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Left part of collapse operator.</p>
</dd>
<dt><strong>b</strong><span class="classifier">Qobj or QobjEvo (optional)</span></dt><dd><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">qobj, QobjEvo</span></dt><dd><p>Lindblad dissipator superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.liouvillian">
<code class="sig-name descname"><span class="pre">liouvillian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#liouvillian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">array_like of Qobj or QobjEvo</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of collapse operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Liouvillian superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.operator_to_vector">
<code class="sig-name descname"><span class="pre">operator_to_vector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#operator_to_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation given a quantum operator in matrix form.
The passed object should have a <code class="docutils literal notranslate"><span class="pre">Qobj.type</span></code> of ‘oper’ or ‘super’; this
function is not designed for general-purpose matrix reshaping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator in matrix form.  This must have a type of ‘oper’ or
‘super’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj or QobjEvo</dt><dd><p>The same object, but re-cast into a column-stacked-vector form of type
‘operator-ket’.  The output is the same type as the passed object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.spost">
<code class="sig-name descname"><span class="pre">spost</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#spost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input qauntum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.spre">
<code class="sig-name descname"><span class="pre">spre</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#spre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>super :Qobj or QobjEvo</dt><dd><p>Superoperator formed from input quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.sprepost">
<code class="sig-name descname"><span class="pre">sprepost</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#sprepost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.sprepost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A and post-
multiplication of operator B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
<dt><strong>B</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input quantum objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superoperator.vector_to_operator">
<code class="sig-name descname"><span class="pre">vector_to_operator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superoperator.html#vector_to_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in vector form.
The passed object should have a <code class="docutils literal notranslate"><span class="pre">Qobj.type</span></code> of ‘operator-ket’; this
function is not designed for general-purpose matrix reshaping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator in column-stacked-vector form.  This must have a type
of ‘operator-ket’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj or QobjEvo</dt><dd><p>The same object, but re-cast into “standard” operator form.  The output
is the same type as the passed object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="py function">
<dt id="qutip.superop_reps.chi_to_choi">
<code class="sig-name descname"><span class="pre">chi_to_choi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#chi_to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.chi_to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Chi matrix to a Choi matrix.</p>
<p>NOTE: this is only supported for qubits right now. Need to extend to
Heisenberg-Weyl for other subsystem dimensions.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.choi_to_chi">
<code class="sig-name descname"><span class="pre">choi_to_chi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#choi_to_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.choi_to_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Choi matrix to a Chi matrix in the Pauli basis.</p>
<p>NOTE: this is only supported for qubits right now. Need to extend to
Heisenberg-Weyl for other subsystem dimensions.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.choi_to_kraus">
<code class="sig-name descname"><span class="pre">choi_to_kraus</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#choi_to_kraus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.choi_to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a Choi matrix and returns a list of Kraus operators.
TODO: Create a new class structure for quantum channels, perhaps as a
strict sub-class of Qobj.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.choi_to_super">
<code class="sig-name descname"><span class="pre">choi_to_super</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#choi_to_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.choi_to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a Choi matrix to a superoperator
TODO: Sanitize input, Abstract-ify application of channels to states</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.kraus_to_choi">
<code class="sig-name descname"><span class="pre">kraus_to_choi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kraus_ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#kraus_to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.kraus_to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of Kraus operators into Choi representation of the channel.</p>
<p>Essentially, kraus operators are a decomposition of a Choi matrix,
so in this function we build Choi matrix from vector representation of Kraus operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kraus_ops</strong><span class="classifier">list[Qobj]</span></dt><dd><p>The list of Kraus operators to be converted to Choi representation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>choi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">kraus_ops</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.kraus_to_super">
<code class="sig-name descname"><span class="pre">kraus_to_super</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kraus_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#kraus_to_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.kraus_to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a list of Kraus operators and returns a super operator.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.super_to_choi">
<code class="sig-name descname"><span class="pre">super_to_choi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#super_to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.super_to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a superoperator to a Choi matrix
TODO: Sanitize input, incorporate as method on Qobj if type==’super’</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.to_chi">
<code class="sig-name descname"><span class="pre">to_chi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#to_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.to_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a representation as a chi
(process) matrix in the Pauli basis, such that the trace of the returned
operator is equal to the dimension of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Chi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_chi(A)</span> <span class="pre">==</span> <span class="pre">to_chi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">chi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;chi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be converted</dt><dd><p>to Chi representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.to_choi">
<code class="sig-name descname"><span class="pre">to_choi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Choi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_choi(A)</span> <span class="pre">==</span> <span class="pre">to_choi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>choi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be converted</dt><dd><p>to Choi representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.to_kraus">
<code class="sig-name descname"><span class="pre">to_kraus</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#to_kraus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Kraus representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_kraus(A)</span> <span class="pre">==</span> <span class="pre">to_kraus(sprepost(A,</span> <span class="pre">A.dag()))</span> <span class="pre">==</span> <span class="pre">[A]</span></code>.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">Float</span></dt><dd><p>Optional threshold parameter for eigenvalues/Kraus ops to be discarded.
The default is to=1e-9.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kraus_ops</strong><span class="classifier">list of Qobj</span></dt><dd><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be</dt><dd><p>decomposed into Kraus operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.to_stinespring">
<code class="sig-name descname"><span class="pre">to_stinespring</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#to_stinespring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.to_stinespring" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map $Lambda$ to a pair of partial isometries
$A$ and $B$ such that $Lambda(X) = Tr_2(A X B^dagger)$ for all inputs $X$, where
the partial trace is taken over a a new index on the output dimensions of $A$ and $B$.</p>
<p>For completely positive inputs, $A$ will always equal $B$ up to precision errors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to a Stinespring pair.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A, B</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum objects representing each of the Stinespring matrices for the input Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.superop_reps.to_super">
<code class="sig-name descname"><span class="pre">to_super</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/superop_reps.html#to_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to supermatrix representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_super(A)</span> <span class="pre">==</span> <span class="pre">sprepost(A,</span> <span class="pre">A.dag())</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>superop</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the given quantum object is not a map, or cannot be converted
to supermatrix representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.dimensions">
<span id="operators-and-superoperator-dimensions"></span><h3>Operators and Superoperator Dimensions<a class="headerlink" href="#module-qutip.dimensions" title="Permalink to this headline">¶</a></h3>
<p>Internal use module for manipulating dims specifications.</p>
<dl class="py function">
<dt id="qutip.dimensions.collapse_dims_oper">
<code class="sig-name descname"><span class="pre">collapse_dims_oper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#collapse_dims_oper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.collapse_dims_oper" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the dimensions specifications for a ket-, bra- or oper-type
Qobj, returns a dimensions specification describing the same shape
by collapsing all composite systems. For instance, the bra-type
dimensions specification <code class="docutils literal notranslate"><span class="pre">[[2,</span> <span class="pre">3],</span> <span class="pre">[1]]</span></code> collapses to
<code class="docutils literal notranslate"><span class="pre">[[6],</span> <span class="pre">[1]]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Dimensions specifications to be collapsed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapsed_dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Collapsed dimensions specification describing the same shape
such that <code class="docutils literal notranslate"><span class="pre">len(collapsed_dims[0])</span> <span class="pre">==</span> <span class="pre">len(collapsed_dims[1])</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.collapse_dims_super">
<code class="sig-name descname"><span class="pre">collapse_dims_super</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#collapse_dims_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.collapse_dims_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the dimensions specifications for an operator-ket-, operator-bra- or
super-type Qobj, returns a dimensions specification describing the same shape
by collapsing all composite systems. For instance, the super-type
dimensions specification <code class="docutils literal notranslate"><span class="pre">[[[2,</span> <span class="pre">3],</span> <span class="pre">[2,</span> <span class="pre">3]],</span> <span class="pre">[[2,</span> <span class="pre">3],</span> <span class="pre">[2,</span> <span class="pre">3]]]</span></code> collapses to
<code class="docutils literal notranslate"><span class="pre">[[[6],</span> <span class="pre">[6]],</span> <span class="pre">[[6],</span> <span class="pre">[6]]]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Dimensions specifications to be collapsed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapsed_dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Collapsed dimensions specification describing the same shape
such that <code class="docutils literal notranslate"><span class="pre">len(collapsed_dims[i][j])</span> <span class="pre">==</span> <span class="pre">1</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>
in <code class="docutils literal notranslate"><span class="pre">range(2)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.deep_remove">
<code class="sig-name descname"><span class="pre">deep_remove</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">what</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#deep_remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.deep_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes scalars from all levels of a nested list.</p>
<p>Given a list containing a mix of scalars and lists,
returns a list of the same structure, but where one or
more scalars have been removed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deep_remove</span><span class="p">([[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
<span class="go">[[[[1, 2]], [3, 4], [], [6, 7]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.dims_idxs_to_tensor_idxs">
<code class="sig-name descname"><span class="pre">dims_idxs_to_tensor_idxs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#dims_idxs_to_tensor_idxs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.dims_idxs_to_tensor_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the dims of a Qobj instance, and some indices into
dims, returns the corresponding tensor indices. This helps
resolve, for instance, that column-stacking for superoperators,
oper-ket and oper-bra implies that the input and output tensor
indices are reversed from their order in dims.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">int, list or tuple</span></dt><dd><p>Indices to convert to tensor indices. Can be specified
as a single index, or as a collection of indices.
In the latter case, this can be nested arbitrarily
deep. For instance, [0, [0, (2, 3)]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tens_indices</strong><span class="classifier">int, list or tuple</span></dt><dd><p>Container of the same structure as indices containing
the tensor indices for each element of indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.dims_to_tensor_perm">
<code class="sig-name descname"><span class="pre">dims_to_tensor_perm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#dims_to_tensor_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.dims_to_tensor_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the dims of a Qobj instance, returns a list representing
a permutation from the flattening of that dims specification to
the corresponding tensor indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list</span></dt><dd><p>A list such that <code class="docutils literal notranslate"><span class="pre">data[flatten(dims)[idx]]</span></code> gives the
index of the tensor <code class="docutils literal notranslate"><span class="pre">data</span></code> corresponding to the <code class="docutils literal notranslate"><span class="pre">idx``th</span>
<span class="pre">dimension</span> <span class="pre">of</span> <span class="pre">``dims</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.dims_to_tensor_shape">
<code class="sig-name descname"><span class="pre">dims_to_tensor_shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#dims_to_tensor_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.dims_to_tensor_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the dims of a Qobj instance, returns the shape of the
corresponding tensor. This helps, for instance, resolve the
column-stacking convention for superoperators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_shape</strong><span class="classifier">tuple</span></dt><dd><p>NumPy shape of the corresponding tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.enumerate_flat">
<code class="sig-name descname"><span class="pre">enumerate_flat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#enumerate_flat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.enumerate_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels the indices at which scalars occur in a flattened list.</p>
<p>Given a list containing a mix of scalars and lists,
returns a list of the same structure, where each scalar
has been replaced by an index into the flattened list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">enumerate_flat</span><span class="p">([[[</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]],</span> <span class="mi">40</span><span class="p">]))</span> 
<span class="go">[[[0], [1, 2]], 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.flatten">
<code class="sig-name descname"><span class="pre">flatten</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#flatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens a list of lists to the first level.</p>
<p>Given a list containing a mix of scalars and lists,
flattens down to a list of the scalars within the original
list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.is_scalar">
<code class="sig-name descname"><span class="pre">is_scalar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#is_scalar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.is_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if a dims specification is effectively
a scalar (has dimension 1).</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.dimensions.unflatten">
<code class="sig-name descname"><span class="pre">unflatten</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idxs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/dimensions.html#unflatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.dimensions.unflatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Unflattens a list by a given structure.</p>
<p>Given a list of scalars and a deep list of indices
as produced by <cite>flatten</cite>, returns an “unflattened”
form of the list. This perfectly inverts <cite>flatten</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">]]]</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">idxs</span> <span class="o">=</span> <span class="n">enumerate_flat</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">unflatten</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">idxs</span><span class="p">)</span> <span class="o">==</span> <span class="n">l</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.expect.expect">
<code class="sig-name descname"><span class="pre">expect</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/expect.html#expect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expt</strong><span class="classifier">float/complex/array-like</span></dt><dd><p>Expectation value.  <code class="docutils literal notranslate"><span class="pre">real</span></code> if <cite>oper</cite> is Hermitian, <code class="docutils literal notranslate"><span class="pre">complex</span></code>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span> 
<span class="go">    True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.expect.variance">
<code class="sig-name descname"><span class="pre">variance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/expect.html#variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Operator for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/list</span></dt><dd><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>var</strong><span class="classifier">float</span></dt><dd><p>Variance of operator ‘oper’ for given state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="py function">
<dt id="qutip.tensor.composite">
<code class="sig-name descname"><span class="pre">composite</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tensor.html#composite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tensor.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <code class="docutils literal notranslate"><span class="pre">to_super</span></code>,
while kets and bras are promoted by taking their projectors and
using <code class="docutils literal notranslate"><span class="pre">operator_to_vector(ket2dm(arg))</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.tensor.super_tensor">
<code class="sig-name descname"><span class="pre">super_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tensor.html#super_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tensor.super_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input superoperators, by tensoring
together the underlying Hilbert spaces on which each vectorized operator
acts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects with <code class="docutils literal notranslate"><span class="pre">type=&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.tensor.tensor">
<code class="sig-name descname"><span class="pre">tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tensor.html#tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects for tensor product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.tensor.tensor_contract">
<code class="sig-name descname"><span class="pre">tensor_contract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">pairs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tensor.html#tensor_contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tensor.tensor_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">tuple</span></dt><dd><p>One or more tuples <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> indicating that the
<code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> dimensions of the original qobj
should be contracted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cqobj</strong><span class="classifier">Qobj</span></dt><dd><p>The original Qobj with all named index pairs contracted
away.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.partial_transpose.partial_transpose">
<code class="sig-name descname"><span class="pre">partial_transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dense'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>A density matrix.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>A mask that selects which subsystems should be transposed.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho_pr: <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></dt><dd><p>A density matrix with the selected subsystems transposed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.entropy.concurrence">
<code class="sig-name descname"><span class="pre">concurrence</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#concurrence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket, bra, or density matrix for a two-qubit state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>concur</strong><span class="classifier">float</span></dt><dd><p>Concurrence</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ba8a4d22c3a-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Concurrence_(quantum_computing">https://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.entropy.entropy_conditional">
<code class="sig-name descname"><span class="pre">entropy_conditional</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math notranslate nohighlight">\(S(A|B)=S(A,B)-S(B)\)</span>
of a selected density matrix component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix of composite object</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p>Selected components for density matrix B</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_cond</strong><span class="classifier">float</span></dt><dd><p>Value of conditional entropy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.entropy.entropy_linear">
<code class="sig-name descname"><span class="pre">entropy_linear</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>sensity matrix or ket/bra vector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Linear entropy of rho.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.entropy.entropy_mutual">
<code class="sig-name descname"><span class="pre">entropy_mutual</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix for composite quantum systems</p>
</dd>
<dt><strong>selA</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_mut</strong><span class="classifier">float</span></dt><dd><p>Mutual information between selected components.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.entropy.entropy_relative">
<code class="sig-name descname"><span class="pre">entropy_relative</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_relative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the relative entropy S(rho||sigma) between two density
matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>First density matrix (or ket which will be converted to a density
matrix).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Second density matrix (or ket which will be converted to a density
matrix).</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm. Defaults to e.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Flag to use sparse solver when determining the eigenvectors
of the density matrices. Defaults to False.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance to use to detect 0 eigenvalues or dot producted between
eigenvectors. Defaults to 1e-12.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rel_ent</strong><span class="classifier">float</span></dt><dd><p>Value of relative entropy. Guaranteed to be greater than zero
and should equal zero only when rho and sigma are identical.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”,
Section 11.3.1, pg. 511 for a detailed explanation of quantum relative
entropy.</p>
<p class="rubric">Examples</p>
<p>First we define two density matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;00&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">qutip</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;01&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
</pre></div>
</div>
<p>Then we calculate their relative entropy using base 2 (i.e. <code class="docutils literal notranslate"><span class="pre">log2</span></code>)
and base e (i.e. <code class="docutils literal notranslate"><span class="pre">log</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">entropy_relative</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">entropy_relative</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.6931471805599453</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.entropy.entropy_vn">
<code class="sig-name descname"><span class="pre">entropy_vn</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="py function">
<dt id="qutip.metrics.average_gate_fidelity">
<code class="sig-name descname"><span class="pre">average_gate_fidelity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#average_gate_fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.average_gate_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Qobj representing the supermatrix form of a map, returns the
average gate fidelity (pseudo-metric) of that map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing a superoperator.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing the target unitary; the inverse
is applied before evaluating the fidelity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Fidelity pseudo-metric between A and the identity superoperator,
or between A and the target superunitary.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.bures_angle">
<code class="sig-name descname"><span class="pre">bures_angle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#bures_angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.bures_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Bures angle between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.bures_dist">
<code class="sig-name descname"><span class="pre">bures_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#bures_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.bures_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Bures distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.dnorm">
<code class="sig-name descname"><span class="pre">dnorm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CVXOPT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_solve</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#dnorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.dnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the diamond norm of the quantum map q_oper, using
the simplified semidefinite program of <a class="reference internal" href="../biblio.html#wat13" id="id9"><span>[Wat13]</span></a>.</p>
<p>The diamond norm SDP is solved by using <a class="reference external" href="https://www.cvxpy.org/en/latest/..">CVXPY</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum map to take the diamond norm of.</p>
</dd>
<dt><strong>B</strong><span class="classifier">Qobj or None</span></dt><dd><p>If provided, the diamond norm of <span class="math notranslate nohighlight">\(A - B\)</span> is taken instead.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>Solver to use with CVXPY. One of “CVXOPT” (default) or “SCS”. The
latter tends to be significantly faster, but somewhat less accurate.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints additional information about the solution.</p>
</dd>
<dt><strong>force_solve</strong><span class="classifier">bool</span></dt><dd><p>If True, forces dnorm to solve the associated SDP, even if a special
case is known for the argument.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Whether to use sparse matrices in the convex optimisation problem.
Default True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dn</strong><span class="classifier">float</span></dt><dd><p>Diamond norm of q_oper.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ImportError</dt><dd><p>If CVXPY cannot be imported.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.fidelity">
<code class="sig-name descname"><span class="pre">fidelity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Fidelity pseudo-metric between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">0.24104350624628332</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.hellinger_dist">
<code class="sig-name descname"><span class="pre">hellinger_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#hellinger_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.hellinger_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the quantum Hellinger distance between two density matrices.</p>
<p>Formula:
hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B)))</p>
<p>See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, “Geometric
measures of quantum correlations with Bures and Hellinger distances”
arXiv:1611.03449</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False, True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hellinger_dist</strong><span class="classifier">float</span></dt><dd><p>Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">hellinger_dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">1.3725145002591095</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.hilbert_dist">
<code class="sig-name descname"><span class="pre">hilbert_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#hilbert_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.hilbert_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Hilbert-Schmidt distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.process_fidelity">
<code class="sig-name descname"><span class="pre">process_fidelity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#process_fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.process_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the process fidelity given two process operators.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.tracedist">
<code class="sig-name descname"><span class="pre">tracedist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#tracedist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False, True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tracedist</strong><span class="classifier">float</span></dt><dd><p>Trace distance between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">0.9705143161472971</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.metrics.unitarity">
<code class="sig-name descname"><span class="pre">unitarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/metrics.html#unitarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.metrics.unitarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unitarity of a quantum map, defined as the Frobenius norm
of the unital block of that map’s superoperator representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum map under consideration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">float</span></dt><dd><p>Unitarity of <code class="docutils literal notranslate"><span class="pre">oper</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.continuous_variables">
<span id="continuous-variables"></span><h3>Continuous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="py function">
<dt id="qutip.continuous_variables.correlation_matrix">
<code class="sig-name descname"><span class="pre">correlation_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math notranslate nohighlight">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<code class="sig-name descname"><span class="pre">correlation_matrix_field</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the correlation matrix for given field operators <span class="math notranslate nohighlight">\(a_1\)</span> and
<span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<code class="sig-name descname"><span class="pre">correlation_matrix_quadrature</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.continuous_variables.covariance_matrix">
<code class="sig-name descname"><span class="pre">covariance_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the covariance matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>symmetrized</strong><span class="classifier">bool {True, False}</span></dt><dd><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<code class="sig-name descname"><span class="pre">logarithmic_negativity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the logarithmic negativity given a symmetrized covariance
matrix, see <a class="reference internal" href="#qutip.continuous_variables.covariance_matrix" title="qutip.continuous_variables.covariance_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.continuous_variables.covariance_matrix</span></code></a>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>V</strong><span class="classifier"><em>2d array</em></span></dt><dd><p>The covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N</strong><span class="classifier">float</span></dt><dd><p>The logarithmic negativity for the two-mode Gaussian state
that is described by the the Wigner covariance matrix V.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<code class="sig-name descname"><span class="pre">wigner_covariance_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Wigner covariance matrix
<span class="math notranslate nohighlight">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math notranslate nohighlight">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math notranslate nohighlight">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The quadrature correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="measurement">
<h2>Measurement<a class="headerlink" href="#measurement" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.measurement">
<span id="measurement-of-quantum-states"></span><h3>Measurement of quantum states<a class="headerlink" href="#module-qutip.measurement" title="Permalink to this headline">¶</a></h3>
<p>Module for measuring quantum objects.</p>
<dl class="py function">
<dt id="qutip.measurement.measure">
<code class="sig-name descname"><span class="pre">measure</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>A dispatch method that provides measurement results handling both
observable style measurements and projector style measurements (POVMs and
PVMs).</p>
<p>For return signatures, please check:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qutip.measurement.measure_observable" title="qutip.measurement.measure_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_observable</span></code></a> for observable measurements.</p></li>
<li><p><a class="reference internal" href="#qutip.measurement.measure_povm" title="qutip.measurement.measure_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_povm</span></code></a> for POVM measurements.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><ul class="simple">
<li><p>measurement observable (<a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>); or</p></li>
<li><p>list of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets (list of
<a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>) Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</li>
</ul>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of target “qubit” indices on which to apply the
measurement using <a class="reference internal" href="#qutip.qip.operations.gates.expand_operator" title="qutip.qip.operations.gates.expand_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qip.operations.gates.expand_operator</span></code></a>
to expand ops into full dimension.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.measurement.measure_observable">
<code class="sig-name descname"><span class="pre">measure_observable</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure_observable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure_observable" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a measurement specified by an operator on the given state.</p>
<p>This function simulates the classic quantum measurement described in many
introductory texts on quantum mechanics. The measurement collapses the
state to one of the eigenstates of the given operator and the result of the
measurement is the corresponding eigenvalue.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>op</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The measurement operator.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of target “qubit” indices on which to apply the
measurement using <a class="reference internal" href="#qutip.qip.operations.gates.expand_operator" title="qutip.qip.operations.gates.expand_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qip.operations.gates.expand_operator</span></code></a>
to expand op into full dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>measured_value</strong><span class="classifier">float</span></dt><dd><p>The result of the measurement (one of the eigenvalues of op).</p>
</dd>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The new state (a ket if a ket was given, otherwise a density matrix).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Measure the z-component of the spin of the spin-up basis state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sigmaz</span><span class="p">())</span>
<span class="go">(1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[-1.]</span>
<span class="go"> [ 0.]])</span>
</pre></div>
</div>
<p>Since the spin-up basis is an eigenstate of sigmaz, this measurement always
returns 1 as the measurement result (the eigenvalue of the spin-up basis)
and the original state (up to a global phase).</p>
<p>Measure the x-component of the spin of the spin-down basis state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sigmax</span><span class="p">())</span>
<span class="go">(-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[-0.70710678]</span>
<span class="go"> [ 0.70710678]])</span>
</pre></div>
</div>
<p>This measurement returns 1 fifty percent of the time and -1 the other fifty
percent of the time. The new state returned is the corresponding eigenstate
of sigmax.</p>
<p>One may also perform a measurement on a density matrix. Below we perform
the same measurement as above, but on the density matrix representing the
pure spin-down state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">sigmax</span><span class="p">())</span>
<span class="go">(-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5 -0.5]</span>
<span class="go"> [-0.5  0.5]])</span>
</pre></div>
</div>
<p>The measurement result is the same, but the new state is returned as a
density matrix.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.measurement.measure_povm">
<code class="sig-name descname"><span class="pre">measure_povm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure_povm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure_povm" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a measurement specified by list of POVMs.</p>
<p>This function simulates a POVM measurement. The measurement collapses the
state to one of the resultant states of the measurement and returns the
index of the operator corresponding to the collapsed state as well as the
collapsed state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>List of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets.  Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of target “qubit” indices on which to apply
the measurement using
<a class="reference internal" href="#qutip.qip.operations.gates.expand_operator" title="qutip.qip.operations.gates.expand_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qip.operations.gates.expand_operator</span></code></a>
to expand <code class="docutils literal notranslate"><span class="pre">ops</span></code> into full dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>index</strong><span class="classifier">float</span></dt><dd><p>The resultant index of the measurement.</p>
</dd>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The new state (a ket if a ket was given, otherwise a density matrix).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.measurement.measurement_statistics">
<code class="sig-name descname"><span class="pre">measurement_statistics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>A dispatch method that provides measurement statistics handling both
observable style measurements and projector style measurements(POVMs and
PVMs).</p>
<p>For return signatures, please check:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qutip.measurement.measurement_statistics_observable" title="qutip.measurement.measurement_statistics_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_observable</span></code></a> for observable measurements.</p></li>
<li><p><a class="reference internal" href="#qutip.measurement.measurement_statistics_povm" title="qutip.measurement.measurement_statistics_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_povm</span></code></a> for POVM measurements.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><ul class="simple">
<li><p>measurement observable (:class:.Qobj); or</p></li>
<li><p>list of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets (list of
<a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>) Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger * M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</li>
</ul>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of target “qubit” indices on which to apply the
measurement using <a class="reference internal" href="#qutip.qip.operations.gates.expand_operator" title="qutip.qip.operations.gates.expand_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qip.operations.gates.expand_operator</span></code></a>
to expand ops into full dimension.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.measurement.measurement_statistics_observable">
<code class="sig-name descname"><span class="pre">measurement_statistics_observable</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics_observable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics_observable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the measurement eigenvalues, eigenstates (or projectors) and
measurement probabilities for the given state and measurement operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>op</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The measurement operator.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of targets “qubit” indices on which to apply the
measurement using <a class="reference internal" href="#qutip.qip.operations.gates.expand_operator" title="qutip.qip.operations.gates.expand_operator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qip.operations.gates.expand_operator</span></code></a>
to expand op into full dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>eigenvalues: list of float</dt><dd><p>The list of eigenvalues of the measurement operator.</p>
</dd>
<dt>eigenstates_or_projectors: list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></dt><dd><p>If the state was a ket, return the eigenstates of the measurement
operator. Otherwise return the projectors onto the eigenstates.</p>
</dd>
<dt>probabilities: list of float</dt><dd><p>The probability of measuring the state as being in the corresponding
eigenstate (and the measurement result being the corresponding
eigenvalue).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.measurement.measurement_statistics_povm">
<code class="sig-name descname"><span class="pre">measurement_statistics_povm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics_povm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics_povm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns measurement statistics (resultant states and probabilities) for a
measurement specified by a set of positive operator valued measurements on
a specified ket or density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>List of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets.  Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to
projectors (s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</dd>
<dt><strong>targets</strong><span class="classifier">list of ints, optional</span></dt><dd><p>Specifies a list of target “qubit” indices on which to apply
the measurement using qutip.qip.operations.gates.expand_operator
to expand ops into full dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>collapsed_states</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The collapsed states obtained after measuring the qubits and obtaining
the qubit specified by the target in the state specified by the index.</p>
</dd>
<dt><strong>probabilities</strong><span class="classifier">list of floats</span></dt><dd><p>The probability of measuring a state in a the state specified by the
index.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="py function">
<dt id="qutip.sesolve.sesolve">
<code class="sig-name descname"><span class="pre">sesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/sesolve.html#sesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrödinger equation evolution of a state vector or unitary matrix for a
given Hamiltonian.</p>
<p>Evolve the state vector (<code class="docutils literal notranslate"><span class="pre">psi0</span></code>) using a given Hamiltonian (<code class="docutils literal notranslate"><span class="pre">H</span></code>), by
integrating the set of ordinary differential equations that define the
system. Alternatively evolve a unitary matrix in solving the Schrodinger
operator equation.</p>
<p>The output is either the state vector or unitary matrix at arbitrary points
in time (<code class="docutils literal notranslate"><span class="pre">tlist</span></code>), or the expectation values of the supplied operators
(<code class="docutils literal notranslate"><span class="pre">e_ops</span></code>). If <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> is a callback function, it is invoked for each
time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> with time and the state as arguments, and the function
does not use any return values. <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> cannot be used in conjunction
with solving the Schrodinger operator equation</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, list, or callable</span></dt><dd><p>System Hamiltonian as a <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> , list of
<a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> and coefficient, <a class="reference internal" href="classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>,
or a callback function for time-dependent Hamiltonians. List format
and options can be found in QobjEvo’s description.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket) or initial unitary operator <code class="docutils literal notranslate"><span class="pre">psi0</span> <span class="pre">=</span> <span class="pre">U</span></code>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like of float</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">None / list / callback function, optional</span></dt><dd><p>A list of operators as <cite>Qobj</cite> and/or callable functions (can be mixed)
or a single callable function. For callable functions, they are called
as <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code> and return the expectation value. A single
callback’s expectation value can be any type, but a callback part of a
list must return a number as the expectation value. For operators, the
result’s expect will be computed by <a class="reference internal" href="#module-qutip.expect" title="qutip.expect"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.expect</span></code></a> when the state
is a <code class="docutils literal notranslate"><span class="pre">ket</span></code>. For operator evolution, the overlap is computed by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">e_ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">op</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of scope parameters for time-dependent Hamiltonians.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Options</span></code></a>, optional</span></dt><dd><p>Options for the ODE solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseProgressBar</span></code>, optional</span></dt><dd><p>Optional instance of <code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseProgressBar</span></code>, or a subclass thereof,
for showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">Options</span></code></a>, which
contains either an array of expectation values for the times
specified by <code class="docutils literal notranslate"><span class="pre">tlist</span></code>, or an array or state vectors
corresponding to the times in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> (if <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> is an empty
list), or nothing if a callback function was given inplace of
operators for which to calculate the expectation values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="py function">
<dt id="qutip.mesolve.mesolve">
<code class="sig-name descname"><span class="pre">mesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/mesolve.html#mesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian or Liouvillian (<cite>H</cite>) and an optional set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows the solution of master equations that are not in standard
Lindblad form.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a
nested-list format where each element in the list is a list of length 2,
containing an operator (<a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a>) at the first element and where
the second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a NumPy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in <cite>tlist</cite>.</p>
<p>Alternatively, <cite>H</cite> (but not <cite>c_ops</cite>) can be a callback function with the
signature <cite>f(t, args) -&gt; Qobj</cite> (<em>callback format</em>), which can return the
Hamiltonian or Liouvillian superoperator at any point in time.  If the
equation cannot be put in standard Lindblad form, then this time-dependence
format must be used.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
<p>H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as their second argument.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument, which
should be an instance of <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a>. Many ODE
integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in superoperator form it will be
added to the total Liouvillian of the problem without further
transformation. This allows for using mesolve for solving master
equations that are not in standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On using callback functions: mesolve transforms all <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> objects that are used in constructing the
Hamiltonian via <cite>args</cite>. mesolve will check for <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise a NotImplemented
exception.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian, or a callback function for time-dependent
Hamiltonians, or alternatively a system Liouvillian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">None / list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">None / list / callback function, optional</span></dt><dd><p>A list of operators as <cite>Qobj</cite> and/or callable functions (can be mixed)
or a single callable function. For operators, the result’s expect will
be  computed by <a class="reference internal" href="#module-qutip.expect" title="qutip.expect"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.expect</span></code></a>. For callable functions, they are
called as <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code> and return the expectation value.
A single callback’s expectation value can be any type, but a callback
part of a list must return a number as the expectation value.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>with options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">None / BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors or
density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite> is
an empty list], or nothing if a callback function was given in place of
operators for which to calculate the expectation values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.mcsolve.mcsolve">
<code class="sig-name descname"><span class="pre">mcsolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">psi0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">c_ops=[]</span></em>, <em class="sig-param"><span class="pre">e_ops=[]</span></em>, <em class="sig-param"><span class="pre">ntraj=0</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=None</span></em>, <em class="sig-param"><span class="pre">progress_bar=True</span></em>, <em class="sig-param"><span class="pre">map_func=&lt;function</span> <span class="pre">parallel_map&gt;</span></em>, <em class="sig-param"><span class="pre">map_kwargs={}</span></em>, <em class="sig-param"><span class="pre">_safe_mode=True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/mcsolve.html#mcsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <code class="docutils literal notranslate"><span class="pre">H0</span></code> and <code class="docutils literal notranslate"><span class="pre">H1</span></code>, where <code class="docutils literal notranslate"><span class="pre">H1</span></code> is time-dependent with coefficient
<code class="docutils literal notranslate"><span class="pre">sin(w*t)</span></code>, and collapse operators <code class="docutils literal notranslate"><span class="pre">C0</span></code> and <code class="docutils literal notranslate"><span class="pre">C1</span></code>, where <code class="docutils literal notranslate"><span class="pre">C1</span></code> is
time-dependent with coeffcient <code class="docutils literal notranslate"><span class="pre">exp(-a*t)</span></code>.  Here, w and a are constant
arguments with values <code class="docutils literal notranslate"><span class="pre">W</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="s1">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>Times at which results are recorded.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectories to run.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>single collapse operator or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>single operator as Qobj or <code class="docutils literal notranslate"><span class="pre">list</span></code> or equivalent of Qobj operators
for calculating expectation values.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>Instance of ODE solver options.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. Set to None to disable the
progress bar.</p>
</dd>
<dt><strong>map_func: function</strong></dt><dd><p>A map function for managing the calls to the single-trajactory solver.</p>
</dd>
<dt><strong>map_kwargs: dictionary</strong></dt><dd><p>Optional keyword arguments to the map_func function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>Object storing all results from the simulation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to reuse the random number seeds from a previous run
of the mcsolver by passing the output Result object seeds via the
Options class, i.e. Options(seeds=prev_result.seeds).</p>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.essolve.essolve">
<code class="sig-name descname"><span class="pre">essolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/essolve.html#essolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.6.0: </span><a class="reference internal" href="#qutip.essolve.essolve" title="qutip.essolve.essolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">essolve</span></code></a> will be removed in QuTiP 5.  Please use
<a class="reference internal" href="#module-qutip.sesolve" title="qutip.sesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sesolve</span></code></a> or <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mesolve</span></code></a> for general-purpose
integration of the Schroedinger/Lindblad master equation.
This will likely be faster than <a class="reference internal" href="#qutip.essolve.essolve" title="qutip.essolve.essolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">essolve</span></code></a> for you.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">qobj/function_type</span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Initial state density matrix.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> operators for which to evaluate
expectation values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expt_array</strong><span class="classifier">array</span></dt><dd><p>Expectation values of wavefunctions/density matrices for the
times specified in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver does not support time-dependent Hamiltonians.
..</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.essolve.ode2es">
<code class="sig-name descname"><span class="pre">ode2es</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/essolve.html#ode2es"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.6.0: </span><a class="reference internal" href="#qutip.essolve.ode2es" title="qutip.essolve.ode2es"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ode2es</span></code></a> will be removed in QuTiP 5.  Please use
<a class="reference internal" href="classes.html#qutip.Qobj.eigenstates" title="qutip.Qobj.eigenstates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.Qobj.eigenstates</span></code></a> to get the eigenstates and -values,
and use <a class="reference internal" href="classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> for general time-dependence.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>L</strong><span class="classifier">qobj</span></dt><dd><p>Liouvillian of the system.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">qobj</span></dt><dd><p>Initial state vector or density matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eseries</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.eseries</span></code></a></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">eseries</span></code> represention of the system dynamics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.krylovsolve">
<span id="krylov-subspace-solver"></span><h3>Krylov Subspace Solver<a class="headerlink" href="#module-qutip.krylovsolve" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.krylovsolve.krylovsolve">
<code class="sig-name descname"><span class="pre">krylovsolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">qutip.qobj.Qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">qutip.qobj.Qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">krylov_dim</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/krylovsolve.html#krylovsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.krylovsolve.krylovsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Time evolution of state vectors for time independent Hamiltonians.
Evolve the state vector (“psi0”) finding an approximation for the time
evolution operator of Hamiltonian (“H”) by obtaining the projection of
the time evolution operator on a set of small dimensional Krylov
subspaces (m &lt;&lt; dim(H)).</p>
<p>The output is either the state vector or the expectation values of
supplied operators (“e_ops”) at arbitrary points at (“tlist”).</p>
<p><strong>Additional options</strong></p>
<p>Additional options to krylovsolve can be set with the following:</p>
<ul class="simple">
<li><p>“store_states”: stores states even though expectation values are
requested via the “e_ops” argument.</p></li>
<li><p>“store_final_state”: store final state even though expectation values are
requested via the “e_ops” argument.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: <cite>qutip.Qobj</cite></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">None / <em>list</em> / <em>array</em></span></dt><dd><p>List of times on which to evolve the initial state. If None, nothing
happens but the code won’t break.</p>
</dd>
<dt><strong>krylov_dim: int</strong></dt><dd><p>Dimension of Krylov approximation subspaces used for the time
evolution approximation.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">None / list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><dl class="simple">
<dt>Instance of ODE solver options, as well as krylov parameters.</dt><dd><dl class="simple">
<dt>atol: controls (approximately) the error desired for the final</dt><dd><p>solution. (Defaults to 1e-8)</p>
</dd>
<dt>nsteps: maximum number of krylov’s internal number of Lanczos</dt><dd><p>iterations. (Defaults to 10000)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">None / BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool (default False)</span></dt><dd><p>Use np.array to represent system Hamiltonians. If True, scipy sparse
arrays are used instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
<cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors corresponding
to the times <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<code class="sig-name descname"><span class="pre">bloch_redfield_solve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ekets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch_redfield.html#bloch_redfield_solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bloch_redfield_tensor</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>R</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Bloch-Redfield tensor.</p>
</dd>
<dt><strong>ekets</strong><span class="classifier">array of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Array of kets that make up a basis tranformation for the eigenbasis.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Initial density matrix.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> / callback function</span></dt><dd><p>List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<code class="sig-name descname"><span class="pre">bloch_redfield_tensor</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculates the time-independent Bloch-Redfield tensor for a system given
a set of operators and corresponding spectral functions that describes the
system’s couplingto its environment.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<dl class="simple">
<dt>a_ops<span class="classifier">list</span></dt><dd><p>Nested list of system operators that couple to the environment,
and the corresponding bath spectra represented as Python
functions.</p>
</dd>
<dt>spectra_cb<span class="classifier">list</span></dt><dd><p>Depreciated.</p>
</dd>
<dt>c_ops<span class="classifier">list</span></dt><dd><p>List of system collapse operators.</p>
</dd>
<dt>use_secular<span class="classifier">bool {True, False}</span></dt><dd><p>Flag that indicates if the secular approximation should
be used.</p>
</dd>
<dt>sec_cutoff<span class="classifier">float {0.1}</span></dt><dd><p>Threshold for secular approximation.</p>
</dd>
</dl>
</dd>
<dt><strong>atol</strong><span class="classifier">float {qutip.settings.atol}</span></dt><dd><p>Threshold for removing small parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>R, kets: <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></dt><dd><p>R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.bloch_redfield.brmesolve">
<code class="sig-name descname"><span class="pre">brmesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_secular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sec_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectra_cb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch_redfield.html#brmesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the dynamics of a system using the Bloch-Redfield master equation,
given an input Hamiltonian, Hermitian bath-coupling terms and their associated
spectrum functions, as well as possible Lindblad collapse operators.</p>
<p>For time-independent systems, the Hamiltonian must be given as a Qobj,
whereas the bath-coupling terms (a_ops), must be written as a nested list
of operator - spectrum function pairs, where the frequency is specified by
the <cite>w</cite> variable.</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [[a+a.dag(),lambda w: 0.2*(w&gt;=0)]]</p>
</div></blockquote>
<p>For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse
operators (c_ops), can be specified in the QuTiP string-based time-dependent
format.  For the a_op spectra, the frequency variable must be <cite>w</cite>, and the
string cannot contain any other variables other than the possibility of having
a time-dependence through the time variable <cite>t</cite>:</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w&gt;=0)’]]</p>
</div></blockquote>
<p>It is also possible to use Cubic_Spline objects for time-dependence.  In
the case of a_ops, Cubic_Splines must be passed as a tuple:</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [ [a+a.dag(), ( f(w), g(t)] ]</p>
</div></blockquote>
<p>where f(w) and g(t) are strings or Cubic_spline objects for the bath
spectrum and time-dependence, respectively.</p>
<p>Finally, if one has bath-couplimg terms of the form
H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is</p>
<p><em>Example</em></p>
<blockquote>
<div><p>a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]</p>
</div></blockquote>
<p>where f(w) is the spectrum of the operators while g1(t) and g2(t)
are the time-dependence of the operators <cite>a</cite> and <cite>a.dag()</cite>, respectively</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj / list</span></dt><dd><p>System Hamiltonian given as a Qobj or
nested list in string-based format.</p>
</dd>
<dt><strong>psi0: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for evaluating evolution</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list</span></dt><dd><p>Nested list of Hermitian system operators that couple to
the bath degrees of freedom, along with their associated
spectra.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list</span></dt><dd><p>List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of system collapse operators, or nested list in
string-based format.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Placeholder for future implementation, kept for API consistency.</p>
</dd>
<dt><strong>use_secular</strong><span class="classifier">bool {True}</span></dt><dd><p>Use secular approximation when evaluating bath-coupling terms.</p>
</dd>
<dt><strong>sec_cutoff</strong><span class="classifier">float {0.1}</span></dt><dd><p>Cutoff for secular approximation.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float {qutip.setttings.atol}</span></dt><dd><p>Tolerance used for removing small values after
basis transformation.</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list</span></dt><dd><p>DEPRECIATED. Do not use.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">BaseProgressBar</span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.floquet.floquet_basis_transform">
<code class="sig-name descname"><span class="pre">floquet_basis_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_basis_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_basis_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a basis transform that takes rho0 from the floquet basis to the
computational basis.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_markov_mesolve">
<code class="sig-name descname"><span class="pre">floquet_markov_mesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_modes_table_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_markov_mesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_markov_mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to understand in which frame and basis the results
are returned here.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>R</strong><span class="classifier">array</span></dt><dd><p>The Floquet-Markov master equation tensor <cite>R</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Initial density matrix.  If <code class="docutils literal notranslate"><span class="pre">f_modes_0</span></code> is not passed, this density
matrix is assumed to be in the Floquet picture.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> / callback function</span></dt><dd><p>list of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver.</p>
</dd>
<dt><strong>floquet_basis: bool, True</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, states and expectation values will be returned in the
Floquet basis.  If <code class="docutils literal notranslate"><span class="pre">False</span></code>, a transformation will be made to the
computational basis; this will be in the lab frame if
<code class="docutils literal notranslate"><span class="pre">f_modes_table</span></code>, <code class="docutils literal notranslate"><span class="pre">T`</span> <span class="pre">and</span> <span class="pre">``f_energies</span></code> are all supplied, or the
interaction picture (defined purely be f_modes_0) if they are not.</p>
</dd>
<dt><strong>f_modes_0</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets), optional</span></dt><dd><p>A list of initial Floquet modes, used to transform the given starting
density matrix into the Floquet basis.  If this is not passed, it is
assumed that <code class="docutils literal notranslate"><span class="pre">rho</span></code> is already in the Floquet basis.</p>
</dd>
<dt><strong>f_modes_table_t</strong><span class="classifier">nested list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets), optional</span></dt><dd><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a>.  Necessary if
<code class="docutils literal notranslate"><span class="pre">floquet_basis</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and the transformation should be made
back to the lab frame.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array_like of float, optional</span></dt><dd><p>The precalculated Floquet quasienergies.  Necessary if
<code class="docutils literal notranslate"><span class="pre">floquet_basis</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and the transformation should be made
back to the lab frame.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float, optional</span></dt><dd><p>The time period of driving.  Necessary if <code class="docutils literal notranslate"><span class="pre">floquet_basis</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code> and the transformation should be made back to the lab frame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_master_equation_rates">
<code class="sig-name descname"><span class="pre">floquet_master_equation_rates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J_cb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_modes_table_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_master_equation_rates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_master_equation_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the rates and matrix elements for the Floquet-Markov master
equation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of initial Floquet modes.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>The collapse operators describing the dissipation.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>J_cb</strong><span class="classifier">callback functions</span></dt><dd><p>A callback function that computes the noise power spectrum, as
a function of frequency, associated with the collapse operator <cite>c_op</cite>.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature in units of frequency.</p>
</dd>
<dt><strong>kmax</strong><span class="classifier">int</span></dt><dd><p>The truncation of the number of sidebands (default 5).</p>
</dd>
<dt><strong>f_modes_table_t</strong><span class="classifier">nested list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a> (optional).</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma
and A used in the construction of the Floquet-Markov master equation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_master_equation_steadystate">
<code class="sig-name descname"><span class="pre">floquet_master_equation_steadystate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_master_equation_steadystate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_master_equation_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the steadystate density matrix (in the floquet basis!) for the
Floquet-Markov master equation.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_modes">
<code class="sig-name descname"><span class="pre">floquet_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</dd>
<dt><strong>U</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.propagator.propagator</span></code></a>.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver. For the propagator U.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list of kets, list of quasi energies</span></dt><dd><p>Two lists: the Floquet modes as kets and the quasi energies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_modes_t">
<code class="sig-name descname"><span class="pre">floquet_modes_t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">list</span></dt><dd><p>Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver. For the propagator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list of kets</span></dt><dd><p>The Floquet modes as kets at time <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<code class="sig-name descname"><span class="pre">floquet_modes_t_lookup</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_table_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_t_lookup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_table_t</strong><span class="classifier">nested list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table</span></code></a>.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet modes.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">nested list</span></dt><dd><p>A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_modes_table">
<code class="sig-name descname"><span class="pre">floquet_modes_table</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_0</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">list</span></dt><dd><p>Floquet energies.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array</span></dt><dd><p>The list of times at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">nested list</span></dt><dd><p>A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_state_decomposition">
<code class="sig-name descname"><span class="pre">floquet_state_decomposition</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_state_decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math notranslate nohighlight">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_states</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of Floquet modes.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>psi</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>The wavefunction to decompose in the Floquet state basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array</span></dt><dd><p>The coefficients <span class="math notranslate nohighlight">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_states">
<code class="sig-name descname"><span class="pre">floquet_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the Floquet modes at that time.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of Floquet modes for time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list of Floquet states for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_states_t">
<code class="sig-name descname"><span class="pre">floquet_states_t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_states_t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">list</span></dt><dd><p>A list of Floquet states for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_wavefunction">
<code class="sig-name descname"><span class="pre">floquet_wavefunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_wavefunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the Floquet modes at time <cite>t</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>f_coeff</strong><span class="classifier">array</span></dt><dd><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>The wavefunction for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<code class="sig-name descname"><span class="pre">floquet_wavefunction_t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_modes_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_energies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#floquet_wavefunction_t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f_modes_t</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> (kets)</span></dt><dd><p>A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong><span class="classifier">array</span></dt><dd><p>The Floquet energies.</p>
</dd>
<dt><strong>f_coeff</strong><span class="classifier">array</span></dt><dd><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>The wavefunction for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.fmmesolve">
<code class="sig-name descname"><span class="pre">fmmesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">rho0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">c_ops=[]</span></em>, <em class="sig-param"><span class="pre">e_ops=[]</span></em>, <em class="sig-param"><span class="pre">spectra_cb=[]</span></em>, <em class="sig-param"><span class="pre">T=None</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em>, <em class="sig-param"><span class="pre">floquet_basis=True</span></em>, <em class="sig-param"><span class="pre">kmax=5</span></em>, <em class="sig-param"><span class="pre">_safe_mode=True</span></em>, <em class="sig-param"><span class="pre">options_modes=None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#fmmesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver currently does not support multiple collapse operators.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>rho0 / psi0</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> / callback function</span></dt><dd><p>list of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list callback functions</span></dt><dd><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</dd>
<dt><strong>args</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry ‘w_th’, which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c1"># unit K </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>             
</pre></div>
</div>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver. For solving the master equation.</p>
</dd>
<dt><strong>floquet_basis</strong><span class="classifier">bool</span></dt><dd><p>Will return results in Floquet basis or computational basis
(optional).</p>
</dd>
<dt><strong>k_max</strong><span class="classifier">int</span></dt><dd><p>The truncation of the number of sidebands (default 5).</p>
</dd>
<dt><strong>options_modes</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver. For computing Floquet modes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an <em>array</em> of expectation values for the times specified
by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.floquet.fsesolve">
<code class="sig-name descname"><span class="pre">fsesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/floquet.html#fsesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a> / callback function</span></dt><dd><p>list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>Tsteps</strong><span class="classifier">integer</span></dt><dd><p>The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</dd>
<dt><strong>options_modes</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>options for the ODE solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.stochastic.general_stochastic">
<code class="sig-name descname"><span class="pre">general_stochastic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">len_d2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#general_stochastic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.general_stochastic" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic general equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket) or density matrix as a vector.</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>d1</strong><span class="classifier">function, callable class</span></dt><dd><p>Function representing the deterministic evolution of the system.</p>
<dl class="simple">
<dt>def d1(time (double), state (as a np.array vector)):</dt><dd><p>return 1d np.array</p>
</dd>
</dl>
</dd>
<dt><strong>d2</strong><span class="classifier">function, callable class</span></dt><dd><p>Function representing the stochastic evolution of the system.</p>
<dl class="simple">
<dt>def d2(time (double), state (as a np.array vector)):</dt><dd><p>return 2d np.array (N_sc_ops, len(state0))</p>
</dd>
</dl>
</dd>
<dt><strong>len_d2</strong><span class="classifier">int</span></dt><dd><p>Number of output vector produced by d2</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.
Must be a superoperator if the state vector is a density matrix.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.photocurrent_mesolve">
<code class="sig-name descname"><span class="pre">photocurrent_mesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#photocurrent_mesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.photocurrent_mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation using the photocurrent method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.photocurrent_sesolve">
<code class="sig-name descname"><span class="pre">photocurrent_sesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#photocurrent_sesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.photocurrent_sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic schrodinger equation using the photocurrent method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.smepdpsolve">
<code class="sig-name descname"><span class="pre">smepdpsolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#smepdpsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix.</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.smesolve">
<code class="sig-name descname"><span class="pre">smesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#smesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.ssepdpsolve">
<code class="sig-name descname"><span class="pre">ssepdpsolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#ssepdpsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a> instead for quantum
trajectory simulations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.ssesolve">
<code class="sig-name descname"><span class="pre">ssesolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#ssesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic schrodinger equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt><dd><p>System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>State vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.stochastic.stochastic_solvers">
<code class="sig-name descname"><span class="pre">stochastic_solvers</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#stochastic_solvers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.stochastic_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is purely a reference point for documenting the available
stochastic solver methods, and takes no actions.</p>
<p class="rubric">Notes</p>
<dl>
<dt>Available solvers for <a class="reference internal" href="#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ssesolve</span></code></a> and <a class="reference internal" href="#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smesolve</span></code></a></dt><dd><dl class="simple">
<dt>euler-maruyama</dt><dd><p>A simple generalization of the Euler method for ordinary
differential equations to stochastic differential equations.  Only
solver which could take non-commuting <code class="docutils literal notranslate"><span class="pre">sc_ops</span></code>. <em>not tested</em></p>
<ul class="simple">
<li><p>Order 0.5</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'euler-maruyama'</span></code>, <code class="docutils literal notranslate"><span class="pre">'euler'</span></code> or <code class="docutils literal notranslate"><span class="pre">0.5</span></code></p></li>
</ul>
</dd>
<dt>milstein</dt><dd><p>An order 1.0 strong Taylor scheme.  Better approximate numerical
solution to stochastic differential equations.  See eq. (2.9) of
chapter 12.2 of <a class="reference internal" href="#r8549f3bdd68d-1" id="id10">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'milstein'</span></code> or <code class="docutils literal notranslate"><span class="pre">1.0</span></code></p></li>
</ul>
</dd>
<dt>milstein-imp</dt><dd><p>An order 1.0 implicit strong Taylor scheme.  Implicit Milstein
scheme for the numerical simulation of stiff stochastic
differential equations.</p>
<ul class="simple">
<li><p>Order strong 1.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'milstein-imp'</span></code></p></li>
</ul>
</dd>
<dt>predictor-corrector</dt><dd><p>Generalization of the trapezoidal method to stochastic differential
equations. More stable than explicit methods.  See eq. (5.4) of
chapter 15.5 of <a class="reference internal" href="#r8549f3bdd68d-1" id="id11">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 0.5, weak 1.0</p></li>
<li><p>Codes to only correct the stochastic part (<span class="math notranslate nohighlight">\(\alpha=0\)</span>,
<span class="math notranslate nohighlight">\(\eta=1/2\)</span>): <code class="docutils literal notranslate"><span class="pre">'pred-corr'</span></code>, <code class="docutils literal notranslate"><span class="pre">'predictor-corrector'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'pc-euler'</span></code></p></li>
<li><p>Codes to correct both the stochastic and deterministic parts
(<span class="math notranslate nohighlight">\(\alpha=1/2\)</span>, <span class="math notranslate nohighlight">\(\eta=1/2\)</span>): <code class="docutils literal notranslate"><span class="pre">'pc-euler-imp'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'pc-euler-2'</span></code> or <code class="docutils literal notranslate"><span class="pre">'pred-corr-2'</span></code></p></li>
</ul>
</dd>
<dt>platen</dt><dd><p>Explicit scheme, creates the Milstein using finite differences
instead of analytic derivatives. Also contains some higher order
terms, thus converges better than Milstein while staying strong
order 1.0.  Does not require derivatives, therefore usable by
<a class="reference internal" href="#qutip.stochastic.general_stochastic" title="qutip.stochastic.general_stochastic"><code class="xref py py-func docutils literal notranslate"><span class="pre">general_stochastic</span></code></a>.  See eq. (7.47) of chapter 7 of <a class="reference internal" href="#r8549f3bdd68d-2" id="id12">[2]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.0, weak 2.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'platen'</span></code>, <code class="docutils literal notranslate"><span class="pre">'platen1'</span></code> or <code class="docutils literal notranslate"><span class="pre">'explicit1'</span></code></p></li>
</ul>
</dd>
<dt>rouchon</dt><dd><p>Scheme keeping the positivity of the density matrix
(<a class="reference internal" href="#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smesolve</span></code></a> only).  See eq. (4) with <span class="math notranslate nohighlight">\(\eta=1\)</span> of <a class="reference internal" href="#r8549f3bdd68d-3" id="id13">[3]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.0?</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'rouchon'</span></code> or <code class="docutils literal notranslate"><span class="pre">'Rouchon'</span></code></p></li>
</ul>
</dd>
<dt>taylor1.5</dt><dd><p>Order 1.5 strong Taylor scheme.  Solver with more terms of the
Ito-Taylor expansion.  Default solver for <a class="reference internal" href="#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smesolve</span></code></a> and
<a class="reference internal" href="#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ssesolve</span></code></a>.  See eq. (4.6) of chapter 10.4 of <a class="reference internal" href="#r8549f3bdd68d-1" id="id14">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.5</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'taylor1.5'</span></code>, <code class="docutils literal notranslate"><span class="pre">'taylor15'</span></code>, <code class="docutils literal notranslate"><span class="pre">1.5</span></code>, or <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
</dd>
<dt>taylor1.5-imp</dt><dd><p>Order 1.5 implicit strong Taylor scheme.  Implicit Taylor 1.5
(<span class="math notranslate nohighlight">\(\alpha = 1/2\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span> doesn’t matter).  See eq.
(2.18) of chapter 12.2 of <a class="reference internal" href="#r8549f3bdd68d-1" id="id15">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.5</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'taylor1.5-imp'</span></code> or <code class="docutils literal notranslate"><span class="pre">'taylor15-imp'</span></code></p></li>
</ul>
</dd>
<dt>explicit1.5</dt><dd><p>Explicit order 1.5 strong schemes.  Reproduce the order 1.5 strong
Taylor scheme using finite difference instead of derivatives.
Slower than <code class="docutils literal notranslate"><span class="pre">taylor15</span></code> but usable by
<a class="reference internal" href="#qutip.stochastic.general_stochastic" title="qutip.stochastic.general_stochastic"><code class="xref py py-func docutils literal notranslate"><span class="pre">general_stochastic</span></code></a>.  See eq. (2.13) of chapter 11.2 of
<a class="reference internal" href="#r8549f3bdd68d-1" id="id16">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 1.5</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'explicit1.5'</span></code>, <code class="docutils literal notranslate"><span class="pre">'explicit15'</span></code> or <code class="docutils literal notranslate"><span class="pre">'platen15'</span></code></p></li>
</ul>
</dd>
<dt>taylor2.0</dt><dd><p>Order 2 strong Taylor scheme.  Solver with more terms of the
Stratonovich expansion.  See eq. (5.2) of chapter 10.5 of <a class="reference internal" href="#r8549f3bdd68d-1" id="id17">[1]</a>.</p>
<ul class="simple">
<li><p>Order strong 2.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'taylor2.0'</span></code>, <code class="docutils literal notranslate"><span class="pre">'taylor20'</span></code> or <code class="docutils literal notranslate"><span class="pre">2.0</span></code></p></li>
</ul>
</dd>
</dl>
<p>All solvers, except taylor2.0, are usable in both smesolve and ssesolve
and for both heterodyne and homodyne. taylor2.0 only works for 1
stochastic operator independent of time with the homodyne method.
<a class="reference internal" href="#qutip.stochastic.general_stochastic" title="qutip.stochastic.general_stochastic"><code class="xref py py-func docutils literal notranslate"><span class="pre">general_stochastic</span></code></a> only accepts the derivative-free
solvers: <code class="docutils literal notranslate"><span class="pre">'euler'</span></code>, <code class="docutils literal notranslate"><span class="pre">'platen'</span></code> and <code class="docutils literal notranslate"><span class="pre">'explicit1.5'</span></code>.</p>
</dd>
<dt>Available solvers for <a class="reference internal" href="#qutip.stochastic.photocurrent_sesolve" title="qutip.stochastic.photocurrent_sesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">photocurrent_sesolve</span></code></a> and <a class="reference internal" href="#qutip.stochastic.photocurrent_mesolve" title="qutip.stochastic.photocurrent_mesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">photocurrent_mesolve</span></code></a></dt><dd><p>Photocurrent use ordinary differential equations between
stochastic “jump/collapse”.</p>
<dl class="simple">
<dt>euler</dt><dd><p>Euler method for ordinary differential equations between jumps.
Only one jump per time interval.  Default solver.  See eqs. (4.19)
and (4.4) of chapter 4 of <a class="reference internal" href="#r8549f3bdd68d-4" id="id18">[4]</a>.</p>
<ul class="simple">
<li><p>Order 1.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'euler'</span></code></p></li>
</ul>
</dd>
<dt>predictor–corrector</dt><dd><p>predictor–corrector method (PECE) for ordinary differential
equations.  Uses the Poisson distribution to obtain the number of
jumps at each timestep.</p>
<ul class="simple">
<li><p>Order 2.0</p></li>
<li><p>Code: <code class="docutils literal notranslate"><span class="pre">'pred-corr'</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8549f3bdd68d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id11">2</a>,<a href="#id14">3</a>,<a href="#id15">4</a>,<a href="#id16">5</a>,<a href="#id17">6</a>)</span></dt>
<dd><p>Peter E. Kloeden and Exkhard Platen, <em>Numerical Solution of
Stochastic Differential Equations</em>.</p>
</dd>
<dt class="label" id="r8549f3bdd68d-2"><span class="brackets"><a class="fn-backref" href="#id12">2</a></span></dt>
<dd><p>H.-P. Breuer and F. Petruccione, <em>The Theory of Open Quantum
Systems</em>.</p>
</dd>
<dt class="label" id="r8549f3bdd68d-3"><span class="brackets"><a class="fn-backref" href="#id13">3</a></span></dt>
<dd><p>Pierre Rouchon and Jason F. Ralpha, <em>Efficient Quantum Filtering for
Quantum Feedback Control</em>, <a class="reference external" href="https://arxiv.org/abs/1410.5345">arXiv:1410.5345 [quant-ph]</a>, Phys. Rev. A 91, 012118,
(2015).</p>
</dd>
<dt class="label" id="r8549f3bdd68d-4"><span class="brackets"><a class="fn-backref" href="#id18">4</a></span></dt>
<dd><p>Howard M. Wiseman, Gerard J. Milburn, <em>Quantum measurement and
control</em>.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.correlation.coherence_function_g1">
<code class="sig-name descname"><span class="pre">coherence_function_g1</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#coherence_function_g1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[g^{(1)}(\tau) =
\frac{\langle A^\dagger(\tau)A(0)\rangle}
{\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle
        \langle A^\dagger(0)A(0)\rangle}}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g1, G1</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.coherence_function_g2">
<code class="sig-name descname"><span class="pre">coherence_function_g2</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#coherence_function_g2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[ g^{(2)}(\tau) =
\frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}
{\langle A^\dagger(\tau)A(\tau)\rangle
 \langle A^\dagger(0)A(0)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of arguments to be passed to solver.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g2, G2</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation">
<code class="sig-name descname"><span class="pre">correlation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">reverse=False</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_2op_1t">
<code class="sig-name descname"><span class="pre">correlation_2op_1t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">reverse=False</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_2op_1t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘mc’, ‘es’}</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>Solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">ndarray</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_2op_2t">
<code class="sig-name descname"><span class="pre">correlation_2op_2t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">reverse=False</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_2op_2t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_3op_1t">
<code class="sig-name descname"><span class="pre">correlation_3op_1t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">c_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_3op_1t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_3op_2t">
<code class="sig-name descname"><span class="pre">correlation_3op_2t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">c_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_3op_2t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_4op_1t">
<code class="sig-name descname"><span class="pre">correlation_4op_1t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">c_op</span></em>, <em class="sig-param"><span class="pre">d_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_4op_1t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>d_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator D.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deprecated in QuTiP 3.1
Use correlation_3op_1t() instead.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_4op_2t">
<code class="sig-name descname"><span class="pre">correlation_4op_2t</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">tlist</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">c_op</span></em>, <em class="sig-param"><span class="pre">d_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_4op_2t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator C.</p>
</dd>
<dt><strong>d_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator D.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.correlation_ss">
<code class="sig-name descname"><span class="pre">correlation_ss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">taulist</span></em>, <em class="sig-param"><span class="pre">c_ops</span></em>, <em class="sig-param"><span class="pre">a_op</span></em>, <em class="sig-param"><span class="pre">b_op</span></em>, <em class="sig-param"><span class="pre">solver='me'</span></em>, <em class="sig-param"><span class="pre">reverse=False</span></em>, <em class="sig-param"><span class="pre">args={}</span></em>, <em class="sig-param"><span class="pre">options=&lt;qutip.solver.Options</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#correlation_ss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:</p>
<div class="math notranslate nohighlight">
\[\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\]</div>
<p>along one time axis (given steady-state initial conditions) using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">Qobj</span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite>, calculate
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong><span class="classifier">Options</span></dt><dd><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.spectrum">
<code class="sig-name descname"><span class="pre">spectrum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'es'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pinv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse).</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier">bool</span></dt><dd><p>For use with the <cite>pi</cite> solver: if <cite>True</cite> use numpy’s pinv method,
otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<code class="sig-name descname"><span class="pre">spectrum_correlation_fft</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_correlation_fft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list/array of times <span class="math notranslate nohighlight">\(t\)</span> which the correlation function is given.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>list/array of correlations corresponding to time delays <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>inverse: boolean</strong></dt><dd><p>boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w, S</strong><span class="classifier">tuple</span></dt><dd><p>Returns an array of angular frequencies ‘w’ and the corresponding
two-sided power spectrum ‘S(w)’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.spectrum_pi">
<code class="sig-name descname"><span class="pre">spectrum_pi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_pinv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_pi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using a psuedo-inverse method. Note: this spectrum is only defined for
stationary statistics (uses steady state rho0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><em>list</em> of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite> use numpy’s pinv method, otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.correlation.spectrum_ss">
<code class="sig-name descname"><span class="pre">spectrum_ss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_ss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using an eseries based solver Note: this spectrum is only defined for
stationary statistics (uses steady state rho0).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier"><em>list</em> of <a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><a class="reference internal" href="#module-qutip.qobj" title="qutip.qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></a></span></dt><dd><p>operator B.</p>
</dd>
<dt><strong>use_pinv</strong><span class="classifier"><em>bool</em></span></dt><dd><p>If <cite>True</cite> use numpy’s <cite>pinv</cite> method, otherwise use a generic solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="py function">
<dt id="qutip.steadystate.build_preconditioner">
<code class="sig-name descname"><span class="pre">build_preconditioner</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/steadystate.html#build_preconditioner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.steadystate.build_preconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a iLU preconditioner necessary for solving for
the steady state density matrix using the iterative linear solvers
in the ‘steadystate’ function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>return_info</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</dd>
<dt><strong>use_rcm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong><span class="classifier">bool, optional, default = False</span></dt><dd><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, default = ‘iterative’</span></dt><dd><p>Tells the preconditioner what type of Liouvillian to build for
iLU factorization.  For direct iterative methods use ‘iterative’.
For power iterative methods use ‘power’.</p>
</dd>
<dt><strong>permc_spec</strong><span class="classifier">str, optional, default=’COLAMD’</span></dt><dd><p>Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ and
‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</dd>
<dt><strong>fill_factor</strong><span class="classifier">float, optional, default = 100</span></dt><dd><p>Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong><span class="classifier">float, optional, default = 1e-4</span></dt><dd><p>Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong><span class="classifier">float, optional, default = None</span></dt><dd><p>Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong><span class="classifier">str, optional, default = ‘smilu_2’</span></dt><dd><p>Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lu</strong><span class="classifier">object</span></dt><dd><p>Returns a SuperLU object representing iLU preconditioner.</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary containing solver-specific information.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.steadystate.steadystate">
<code class="sig-name descname"><span class="pre">steadystate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/steadystate.html#steadystate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the supplied
Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of
collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">{‘scipy’, ‘mkl’}, optional</span></dt><dd><p>Selects the sparse solver to use.  Default is to auto-select based on
the availability of the MKL library.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, default ‘direct’</span></dt><dd><p>The allowed methods are</p>
<ul class="simple">
<li><p>‘direct’</p></li>
<li><p>‘eigen’</p></li>
<li><p>‘iterative-gmres’</p></li>
<li><p>‘iterative-lgmres’</p></li>
<li><p>‘iterative-bicgstab’</p></li>
<li><p>‘svd’</p></li>
<li><p>‘power’</p></li>
<li><p>‘power-gmres’</p></li>
<li><p>‘power-lgmres’</p></li>
<li><p>‘power-bicgstab’</p></li>
</ul>
<p>Method for solving the underlying linear equation. Direct LU solver
‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES
method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,
iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or
inverse-power method ‘power’. The iterative power methods
‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as
their direct counterparts.</p>
</dd>
<dt><strong>return_info</strong><span class="classifier">bool, default False</span></dt><dd><p>Return a dictionary of solver-specific infomation about the solution
and how it was obtained.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, default True</span></dt><dd><p>Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for ‘smaller’ systems.</p>
</dd>
<dt><strong>use_rcm</strong><span class="classifier">bool, default False</span></dt><dd><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU
factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong><span class="classifier">bool, default False</span></dt><dd><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>max_iter_refine</strong><span class="classifier">int, default 10</span></dt><dd><p>MKL ONLY. Max. number of iterative refinements to perform.</p>
</dd>
<dt><strong>scaling_vectors</strong><span class="classifier">bool</span></dt><dd><p>MKL ONLY.  Scale matrix to unit norm columns and rows.</p>
</dd>
<dt><strong>weighted_matching</strong><span class="classifier">bool</span></dt><dd><p>MKL ONLY.  Use weighted matching to better condition diagonal.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray, optional</span></dt><dd><p>ITERATIVE ONLY. Initial guess for solution vector.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, default 1000</span></dt><dd><p>ITERATIVE ONLY. Maximum number of iterations to perform.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, default 1e-12</span></dt><dd><p>ITERATIVE ONLY. Tolerance used for terminating solver.</p>
</dd>
<dt><strong>mtol</strong><span class="classifier">float, optional</span></dt><dd><p>ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.  If None
given then <code class="docutils literal notranslate"><span class="pre">max(0.1*tol,</span> <span class="pre">1e-15)</span></code> is used.</p>
</dd>
<dt><strong>matol</strong><span class="classifier">float, default 1e-15</span></dt><dd><p>ITERATIVE ONLY. Absolute tolerance for lu solve method.</p>
</dd>
<dt><strong>permc_spec</strong><span class="classifier">str, optional</span></dt><dd><p>ITERATIVE ONLY. Column ordering used internally by superLU for the
‘direct’ LU decomposition method. Options include ‘COLAMD’ (default)
and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically
unless explicitly specified.</p>
</dd>
<dt><strong>use_precond</strong><span class="classifier">bool, default False</span></dt><dd><p>ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the ‘iterative’ GMRES and BICG solvers.  Speeds up
convergence time by orders of magnitude in many cases.</p>
</dd>
<dt><strong>M</strong><span class="classifier">{sparse matrix, dense matrix, LinearOperator}, optional</span></dt><dd><p>ITERATIVE ONLY. Preconditioner for A. The preconditioner should
approximate the inverse of A. Effective preconditioning can
dramatically improve the rate of convergence for iterative methods.
If no preconditioner is given and <code class="docutils literal notranslate"><span class="pre">use_precond</span> <span class="pre">=</span> <span class="pre">True</span></code>, then one
is generated automatically.</p>
</dd>
<dt><strong>fill_factor</strong><span class="classifier">float, default 100</span></dt><dd><p>ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong><span class="classifier">float, default 1e-4</span></dt><dd><p>ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong><span class="classifier">float, optional</span></dt><dd><p>ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong><span class="classifier">str, default ‘smilu_2’</span></dt><dd><p>ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm
used in creating the preconditoner. Should only be used by advanced
users.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Steady state density matrix.</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary containing solver-specific information about the solution.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.propagator.propagator">
<code class="sig-name descname"><span class="pre">propagator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitary_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'batch'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_safe_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/propagator.html#propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math notranslate nohighlight">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math notranslate nohighlight">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">qobj or list</span></dt><dd><p>Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>).</p>
</dd>
<dt><strong>t</strong><span class="classifier">float or array-like</span></dt><dd><p>Time or list of times for which to evaluate the propagator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>List of qobj collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">list/array/dictionary</span></dt><dd><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>with options for the ODE solver.</p>
</dd>
<dt><strong>unitary_mode = str (‘batch’, ‘single’)</strong></dt><dd><p>Solve all basis vectors simulaneously (‘batch’) or individually
(‘single’).</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Run the propagator in parallel mode. This will override the
unitary_mode settings if set to True.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. By default no progress bar
is used, and if set to True a TextProgressBar will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">qobj</span></dt><dd><p>Instance representing the propagator <span class="math notranslate nohighlight">\(U(t)\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.propagator.propagator_steadystate">
<code class="sig-name descname"><span class="pre">propagator_steadystate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/propagator.html#propagator_steadystate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math notranslate nohighlight">\(U\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj</span></dt><dd><p>Operator representing the propagator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">qobj</span></dt><dd><p>Instance representing the steady-state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.rhs_generate">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip.rhs_generate" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.rhs_generate.rhs_clear">
<code class="sig-name descname"><span class="pre">rhs_clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/rhs_generate.html#rhs_clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Nothing, just clears data from internal config module.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.scattering">
<span id="scattering-in-quantum-optical-systems"></span><h3>Scattering in Quantum Optical Systems<a class="headerlink" href="#module-qutip.scattering" title="Permalink to this headline">¶</a></h3>
<p>Photon scattering in quantum optical systems</p>
<p>This module includes a collection of functions for numerically computing photon
scattering in driven arbitrary systems coupled to some configuration of output
waveguides. The implementation of these functions closely follows the
mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent
Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).</p>
<dl class="py function">
<dt id="qutip.scattering.scattering_probability">
<code class="sig-name descname"><span class="pre">scattering_probability</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_emissions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_zero_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">construct_effective_hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/scattering.html#scattering_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.scattering.scattering_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integrated probability of scattering n photons in an arbitrary
system. This function accepts a nonlinearly spaced array of times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from H and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photons emitted by the system (into any combination of
waveguides).</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest; tlist need not be
linearly spaced.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<cite>basis(systemDims, 0)</cite>.</p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scattering_prob</strong><span class="classifier">float</span></dt><dd><p>The probability of scattering n photons from the system over the time
range specified.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.scattering.temporal_basis_vector">
<code class="sig-name descname"><span class="pre">temporal_basis_vector</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">waveguide_emission_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_time_bins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/scattering.html#temporal_basis_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.scattering.temporal_basis_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a temporal basis vector for emissions at specified time bins into
specified waveguides.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>waveguide_emission_indices</strong><span class="classifier">list or tuple</span></dt><dd><p>List of indices where photon emission occurs for each waveguide,
e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].</p>
</dd>
<dt><strong>n_time_bins</strong><span class="classifier">int</span></dt><dd><p>Number of time bins; the range over which each index can vary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>temporal_basis_vector</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>A basis vector representing photon scattering at the specified indices.
If there are W waveguides, T times, and N photon emissions, then the
basis vector has dimensionality (W*T)^N.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.scattering.temporal_scattered_state">
<code class="sig-name descname"><span class="pre">temporal_scattered_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_emissions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_zero_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">construct_effective_hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/scattering.html#temporal_scattered_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.scattering.temporal_scattered_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scattered n-photon state projected onto the temporal basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from <cite>H</cite> and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photon emissions to calculate.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span></p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span></p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi_n</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>The scattered bath state projected onto the temporal basis given by
tlist. If there are W waveguides, T times, and N photon emissions, then
the state is a tensor product state with dimensionality T^(W*N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.piqs">
<span id="permutational-invariance"></span><h3>Permutational Invariance<a class="headerlink" href="#module-qutip.piqs" title="Permalink to this headline">¶</a></h3>
<p>Permutational Invariant Quantum Solver (PIQS)</p>
<p>This module calculates the Liouvillian for the dynamics of ensembles of
identical two-level systems (TLS) in the presence of local and collective
processes by exploiting permutational symmetry and using the Dicke basis.
It also allows to characterize nonlinear functions of the density matrix.</p>
<dl class="py function">
<dt id="qutip.piqs.am">
<code class="sig-name descname"><span class="pre">am</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#am"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.am" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the operator <code class="docutils literal notranslate"><span class="pre">am</span></code> used later.</p>
<p>The action of <code class="docutils literal notranslate"><span class="pre">ap</span></code> is given by:
<span class="math notranslate nohighlight">\(J_{-}\lvert j,m\rangle = A_{-}(jm)\lvert j,m-1\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j: float</strong></dt><dd><p>The value for j.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The value for m.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a_minus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{-}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.ap">
<code class="sig-name descname"><span class="pre">ap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#ap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.ap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the coefficient <code class="docutils literal notranslate"><span class="pre">ap</span></code> by applying <span class="math notranslate nohighlight">\(J_+\lvert j,m\rangle\)</span>.</p>
<p>The action of ap is given by:
<span class="math notranslate nohighlight">\(J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j, m: float</strong></dt><dd><p>The value for j and m in the dicke basis <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a_plus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{+}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.block_matrix">
<code class="sig-name descname"><span class="pre">block_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ones'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#block_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.block_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the block-diagonal matrix for the Dicke basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of two-level systems.</p>
</dd>
<dt><strong>elements</strong><span class="classifier">str {‘ones’ (default),’degeneracy’}</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>block_matr</strong><span class="classifier">ndarray</span></dt><dd><p>A 2D block-diagonal matrix with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems. Filled with ones or the value of degeneracy
at each matrix element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.collapse_uncoupled">
<code class="sig-name descname"><span class="pre">collapse_uncoupled</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#collapse_uncoupled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.collapse_uncoupled" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the collapse operators (c_ops) of the Lindbladian in the
uncoupled basis</p>
<p>These operators are in the uncoupled basis of the two-level
system (TLS) SU(2) Pauli matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>c_ops: list</dt><dd><p>The list of collapse operators as <cite>qutip.Qobj</cite> for the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The collapse operator list can be given to <cite>qutip.mesolve</cite>.
Notice that the operators are placed in a Hilbert space of
dimension <span class="math notranslate nohighlight">\(2^N\)</span>. Thus the method is suitable only for
small N (of the order of 10).</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.css">
<code class="sig-name descname"><span class="pre">css</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7071067811865475</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7071067811865475</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cartesian'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#css"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.css" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the Coherent Spin State (CSS).</p>
<p>It can be defined as,
<span class="math notranslate nohighlight">\(\lvert CSS\rangle = \prod_i^N(a\lvert1\rangle_i+b\lvert0\rangle_i)\)</span>
with <span class="math notranslate nohighlight">\(a = sin(\frac{\theta}{2})\)</span>,
<span class="math notranslate nohighlight">\(b = e^{i \phi}\cos(\frac{\theta}{2})\)</span>.
The default basis is that of Dicke space
<span class="math notranslate nohighlight">\(\lvert j, m\rangle \langle j, m'\rvert\)</span>.
The default state is the symmetric CSS,
<span class="math notranslate nohighlight">\(\lvert CSS\rangle = \lvert+\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>x, y: float</strong></dt><dd><p>The coefficients of the CSS state.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
<dt><strong>coordinates: str</strong></dt><dd><p>Either “cartesian” or “polar”. If polar then the coefficients
are constructed as sin(x/2), cos(x/2)e^(iy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The CSS state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.dicke">
<code class="sig-name descname"><span class="pre">dicke</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.dicke" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Dicke state as a pure density matrix in the Dicke basis.</p>
<p>For instance, the superradiant state given by
<span class="math notranslate nohighlight">\(\lvert  j, m\rangle = \lvert 1, 0\rangle\)</span> for N = 2,
and the state is represented as a density matrix of size (nds, nds) or
(4, 4), with the (1, 1) element set to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>The eigenvalue j of the Dicke state (j, m).</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The eigenvalue m of the Dicke state (j, m).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.dicke_basis">
<code class="sig-name descname"><span class="pre">dicke_basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jmm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#dicke_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.dicke_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the density matrix of a Dicke state for several (j, m, m1).</p>
<p>This function can be used to build arbitrary states in the Dicke basis
<span class="math notranslate nohighlight">\(\lvert j, m\rangle\langle j, m'\rvert\)</span>. We create coefficients for
each (j, m, m1) value in the dictionary jmm1. The mapping for the (i, k)
index of the density matrix to the <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> values is
given by the cythonized function <cite>jmm1_dictionary</cite>. A density matrix is
created from the given dictionary of coefficients for each (j, m, m1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>jmm1: dict</strong></dt><dd><p>A dictionary of {(j, m, m1): p} that gives a density p for the
(j, m, m1) matrix element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix in the Dicke basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.dicke_blocks">
<code class="sig-name descname"><span class="pre">dicke_blocks</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#dicke_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.dicke_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the list of blocks for block-diagonal density matrix in the Dicke basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>square_blocks: list of np.array</dt><dd><p>Give back the blocks list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.dicke_blocks_full">
<code class="sig-name descname"><span class="pre">dicke_blocks_full</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#dicke_blocks_full"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.dicke_blocks_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>full_blocks</strong><span class="classifier">list</span></dt><dd><p>The list of blocks expanded in the 2^N space for N qubits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.dicke_function_trace">
<code class="sig-name descname"><span class="pre">dicke_function_trace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#dicke_function_trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.dicke_function_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the trace of a function on a Dicke density matrix.
:param f: A Taylor-expandable function of <cite>rho</cite>.
:type f: function
:param rho: A density matrix in the Dicke basis.
:type rho: <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>res</strong><span class="classifier">float</span></dt><dd><p>Trace of a nonlinear function on <cite>rho</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.energy_degeneracy">
<code class="sig-name descname"><span class="pre">energy_degeneracy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#energy_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.energy_degeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of Dicke states with same energy.</p>
<p>The use of the <cite>Decimals</cite> class allows to explore N &gt; 1000,
unlike the built-in function <cite>scipy.special.binom</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>Total spin z-axis projection eigenvalue.
This is proportional to the total energy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The energy degeneracy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.entropy_vn_dicke">
<code class="sig-name descname"><span class="pre">entropy_vn_dicke</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#entropy_vn_dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.entropy_vn_dicke" title="Permalink to this definition">¶</a></dt>
<dd><p>Von Neumann Entropy of a Dicke-basis density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>entropy_dm: float</dt><dd><p>Entropy. Use degeneracy to multiply each block.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.excited">
<code class="sig-name descname"><span class="pre">excited</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#excited"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.excited" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix for the excited state.</p>
<p>This state is given by (N/2, N/2) in the default Dicke basis. If the
argument <cite>basis</cite> is “uncoupled” then it generates the state in a
2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The excited state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.ghz">
<code class="sig-name descname"><span class="pre">ghz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#ghz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.ghz" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the GHZ state.</p>
<p>If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The GHZ state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.ground">
<code class="sig-name descname"><span class="pre">ground</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#ground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.ground" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the ground state.</p>
<p>This state is given by (N/2, -N/2) in the Dicke basis. If the argument
<cite>basis</cite> is “uncoupled” then it generates the state in a
<span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The ground state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.identity_uncoupled">
<code class="sig-name descname"><span class="pre">identity_uncoupled</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#identity_uncoupled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.identity_uncoupled" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<p>The identity matrix is formed from the tensor product of N TLSs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>identity: :class: qutip.Qobj</dt><dd><p>The identity matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.isdiagonal">
<code class="sig-name descname"><span class="pre">isdiagonal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#isdiagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.isdiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the input matrix is diagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat: ndarray/Qobj</strong></dt><dd><p>A 2D numpy array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>diag: bool</dt><dd><p>True/False depending on whether the input matrix is diagonal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.jspin">
<code class="sig-name descname"><span class="pre">jspin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#jspin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.jspin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the list of collective operators of the total algebra.</p>
<p>The Dicke basis <span class="math notranslate nohighlight">\(\lvert j,m\rangle\langle j,m'\rvert\)</span> is used by
default. Otherwise with “uncoupled” the operators are in a
<span class="math notranslate nohighlight">\(2^N\)</span> space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of two-level systems.</p>
</dd>
<dt><strong>op: str</strong></dt><dd><p>The operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no operator given, then output is the list of operators
for [‘x’,’y’,’z’].</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis of the operators - “dicke” or “uncoupled”
default: “dicke”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>j_alg: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> representing all the operators in
the “dicke” or “uncoupled” basis or a single operator requested.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.m_degeneracy">
<code class="sig-name descname"><span class="pre">m_degeneracy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#m_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.m_degeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of Dicke states <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> with
same energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>Total spin z-axis projection eigenvalue (proportional to the total
energy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The m-degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.num_dicke_ladders">
<code class="sig-name descname"><span class="pre">num_dicke_ladders</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#num_dicke_ladders"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.num_dicke_ladders" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total number of ladders in the Dicke space.</p>
<p>For a collection of N two-level systems it counts how many different
“j” exist or the number of blocks in the block-diagonal matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Nj: int</dt><dd><p>The number of Dicke ladders.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.num_dicke_states">
<code class="sig-name descname"><span class="pre">num_dicke_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#num_dicke_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.num_dicke_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of Dicke states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>nds: int</dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.num_tls">
<code class="sig-name descname"><span class="pre">num_tls</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#num_tls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.num_tls" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the number of two-level systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nds: int</strong></dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>N: int</dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.purity_dicke">
<code class="sig-name descname"><span class="pre">purity_dicke</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#purity_dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.purity_dicke" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate purity of a density matrix in the Dicke basis.
It accounts for the degenerate blocks in the density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Density matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>purity</strong><span class="classifier">float</span></dt><dd><p>The purity of the quantum state.
It’s 1 for pure states, 0&lt;=purity&lt;1 for mixed states.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.spin_algebra">
<code class="sig-name descname"><span class="pre">spin_algebra</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#spin_algebra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.spin_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the list [sx, sy, sz] with the spin operators.</p>
<p>The operators are constructed for a collection of N two-level systems
(TLSs). Each element of the list, i.e., sx, is a vector of <cite>qutip.Qobj</cite>
objects (spin matrices), as it cointains the list of the SU(2) Pauli
matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),
is placed in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>spin_operators: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> operators - [sx, sy, sz] or the
requested operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>sx[i] is <span class="math notranslate nohighlight">\(\frac{\sigma_x}{2}\)</span> in the composite Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.state_degeneracy">
<code class="sig-name descname"><span class="pre">state_degeneracy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#state_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.state_degeneracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the degeneracy of the Dicke state.</p>
<p>Each state <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> includes D(N,j) irreducible
representations <span class="math notranslate nohighlight">\(\lvert j, m, \alpha\rangle\)</span>.</p>
<p>Uses Decimals to calculate higher numerator and denominators numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>Total spin eigenvalue (cooperativity).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The state degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.superradiant">
<code class="sig-name descname"><span class="pre">superradiant</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#superradiant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.superradiant" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density matrix of the superradiant state.</p>
<p>This state is given by (N/2, 0) or (N/2, 0.5) in the Dicke basis.
If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a 2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The superradiant state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.piqs.tau_column">
<code class="sig-name descname"><span class="pre">tau_column</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#tau_column"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.tau_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the column index for the non-zero elements of the matrix for a
particular row <cite>k</cite> and the value of <cite>j</cite> from the Dicke space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau: str</strong></dt><dd><p>The tau function to check for this <cite>k</cite> and <cite>j</cite>.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>The row of the matrix M for which the non zero elements have
to be calculated.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>The value of <cite>j</cite> for this row.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="lattice">
<h2>Lattice<a class="headerlink" href="#lattice" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.lattice">
<span id="lattice-properties"></span><h3>Lattice Properties<a class="headerlink" href="#module-qutip.lattice" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.lattice.cell_structures">
<code class="sig-name descname"><span class="pre">cell_structures</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#cell_structures"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.cell_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns two matrices H_cell and cell_T to help the user form the inputs for
defining an instance of Lattice1d and Lattice2d classes. The two matrices
are the intra and inter cell Hamiltonians with the tensor structure of the
specified site numbers and/or degrees of freedom defined by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>val_s</strong><span class="classifier">list of str/str</span></dt><dd><p>The first list of str’s specifying the sites/degrees of freedom in the
unitcell</p>
</dd>
<dt><strong>val_t</strong><span class="classifier">list of str/str</span></dt><dd><p>The second list of str’s specifying the sites/degrees of freedom in the
unitcell</p>
</dd>
<dt><strong>val_u</strong><span class="classifier">list of str/str</span></dt><dd><p>The third list of str’s specifying the sites/degrees of freedom in the
unitcell</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H_cell_s</strong><span class="classifier">list of list of str</span></dt><dd><p>tensor structure of the cell Hamiltonian elements</p>
</dd>
<dt><strong>T_inter_cell_s</strong><span class="classifier">list of list of str</span></dt><dd><p>tensor structure of the inter cell Hamiltonian elements</p>
</dd>
<dt><strong>H_cell</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj initiated with all 0s with proper shape for an input as
Hamiltonian_of_cell in Lattice1d.__init__()</p>
</dd>
<dt><strong>T_inter_cell</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj initiated with all 0s with proper shape for an input as
inter_hop in Lattice1d.__init__()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.topology">
<span id="topology"></span><h3>Topology<a class="headerlink" href="#module-qutip.topology" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.topology.berry_curvature">
<code class="sig-name descname"><span class="pre">berry_curvature</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigfs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/topology.html#berry_curvature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.topology.berry_curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the discretized Berry curvature on the two dimensional grid
of parameters. The function works well for cases with no band mixing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eigfs</strong><span class="classifier">numpy ndarray</span></dt><dd><p>4 dimensional numpy ndarray where the first two indices are for the two
discrete values of the two parameters and the third is the index of the
occupied bands. The fourth dimension holds the eigenfunctions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>b_curv</strong><span class="classifier">numpy ndarray</span></dt><dd><p>A two dimensional array of the discretized Berry curvature defined for
the values of the two parameters defined in the eigfs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.topology.plot_berry_curvature">
<code class="sig-name descname"><span class="pre">plot_berry_curvature</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigfs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/topology.html#plot_berry_curvature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.topology.plot_berry_curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the discretized Berry curvature on the two dimensional grid
of parameters. The function works well for cases with no band mixing.</p>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.wigner.qfunc">
<code class="sig-name descname"><span class="pre">qfunc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">qutip.qobj.Qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_memory</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1024</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#qfunc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Husimi-Q function of a given state vector or density matrix at phase-space
points <code class="docutils literal notranslate"><span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(xvec</span> <span class="pre">+</span> <span class="pre">i*yvec)</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A state vector or density matrix.  This cannot have tensor-product
structure.</p>
</dd>
<dt><strong>xvec, yvec</strong><span class="classifier">array_like</span></dt><dd><p>x- and y-coordinates at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float, default sqrt(2)</span></dt><dd><p>Scaling factor for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">iy)</span></code>.  The value of <cite>g</cite> is
related to the value of <span class="math notranslate nohighlight">\(\hbar\)</span> in the commutation relation
<span class="math notranslate nohighlight">\([x,\,y] = i\hbar\)</span> via <span class="math notranslate nohighlight">\(\hbar=2/g^2\)</span>, so the default
corresponds to <span class="math notranslate nohighlight">\(\hbar=1\)</span>.</p>
</dd>
<dt><strong>precompute_memory</strong><span class="classifier">real, default 1024</span></dt><dd><p>Size in MB that may be used during calculations as working space when
dealing with density-matrix inputs.  This is ignored for state-vector
inputs.  The bound is not quite exact due to other, order-of-magnitude
smaller, intermediaries being necessary, but is a good approximation.
If you want to use the same iterative algorithm for density matrices
that is used for single kets, set <code class="docutils literal notranslate"><span class="pre">precompute_memory=None</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Values representing the Husimi-Q function calculated over the specified
range <code class="docutils literal notranslate"><span class="pre">[xvec,</span> <span class="pre">yvec]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="classes.html#qutip.QFunc" title="qutip.QFunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QFunc</span></code></a></dt><dd><p>a class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.wigner.spin_q_function">
<code class="sig-name descname"><span class="pre">spin_q_function</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#spin_q_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.spin_q_function" title="Permalink to this definition">¶</a></dt>
<dd><p>The Husimi Q function for spins is defined as <code class="docutils literal notranslate"><span class="pre">Q(theta,</span> <span class="pre">phi)</span> <span class="pre">=</span>
<span class="pre">SCS.dag()</span> <span class="pre">*</span> <span class="pre">rho</span> <span class="pre">*</span> <span class="pre">SCS</span></code> for the spin coherent state <code class="docutils literal notranslate"><span class="pre">SCS</span> <span class="pre">=</span> <span class="pre">spin_coherent(</span>
<span class="pre">j,</span> <span class="pre">theta,</span> <span class="pre">phi)</span></code> where j is the spin length.
The implementation here is more efficient as it doesn’t
generate all of the SCS at theta and phi (see references).</p>
<p>The spin Q function is normal when integrated over the surface of the
sphere</p>
<div class="math notranslate nohighlight">
\[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta
Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>Polar (colatitude) angle at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>Azimuthal angle at which to calculate the Husimi-Q function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Q, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Husimi Q function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Lee Loh, Y., &amp; Kim, M. (2015). American J. of Phys., 83(1), 30–35.
<a class="reference external" href="https://doi.org/10.1119/1.4898595">https://doi.org/10.1119/1.4898595</a></p>
</dd></dl>

<dl class="py function">
<dt id="qutip.wigner.spin_wigner">
<code class="sig-name descname"><span class="pre">spin_wigner</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#spin_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.spin_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a spin-j system.</p>
<p>The spin W function is normal when integrated over the surface of the
sphere</p>
<div class="math notranslate nohighlight">
\[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta
W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>Polar (colatitude) angle at which to calculate the W function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>Azimuthal angle at which to calculate the W function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Wigner function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.
<a class="reference external" href="https://doi.org/10.1103/PhysRevA.24.2889">https://doi.org/10.1103/PhysRevA.24.2889</a></p>
<p>[2] Dowling, J. P., Agarwal, G. S., &amp; Schleich, W. P. (1994).
Phys. Rev. A, 49(5), 4101–4109. <a class="reference external" href="https://doi.org/10.1103/PhysRevA.49.4101">https://doi.org/10.1103/PhysRevA.49.4101</a></p>
<p>[3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients
taken from Wikipedia (<a class="reference external" href="https://en.wikipedia.org/wiki/3-j_symbol">https://en.wikipedia.org/wiki/3-j_symbol</a>)</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.wigner.wigner">
<code class="sig-name descname"><span class="pre">wigner</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clenshaw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parfor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g^2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’
and ‘iterative’ use an iterative method to evaluate the Wigner functions for density
matrices <span class="math notranslate nohighlight">\(|m&gt;&lt;n|\)</span>, while ‘laguerre’ uses the Laguerre polynomials
in scipy for the same task. The ‘fft’ method evaluates the Fourier
transform of the density matrix. The ‘iterative’ method is default, and
in general recommended, but the ‘laguerre’ method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The ‘clenshaw’ method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50). ‘clenshaw’ is a fast and numerically stable method.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Tells the default solver whether or not to keep the input density
matrix in sparse format.  As the dimensions of the density matrix
grow, setthing this flag can result in increased performance.</p>
</dd>
<dt><strong>parfor</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Flag for calculating the Laguerre polynomial based Wigner function
method=’laguerre’ in parallel using the parfor function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array</span></dt><dd><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</dd>
<dt><strong>yvex</strong><span class="classifier">array</span></dt><dd><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘fft’ method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.visualization">
<span id="graphs-and-visualization"></span><h3>Graphs and Visualization<a class="headerlink" href="#module-qutip.visualization" title="Permalink to this headline">¶</a></h3>
<p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="py function">
<dt id="qutip.visualization.hinton">
<code class="sig-name descname"><span class="pre">hinton</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_top</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#hinton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix or superoperator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Input density matrix or superoperator.</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings or False</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings or False</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>label_top</strong><span class="classifier">bool</span></dt><dd><p>If True, x-axis labels will be placed on top, otherwise
they will appear below the plot.</p>
</dd>
<dt><strong>color_style</strong><span class="classifier">string</span></dt><dd><p>Determines how colors are assigned to each square:</p>
<ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;scaled&quot;</span></code> (default), each color is chosen by
passing the absolute value of the corresponding matrix
element into <cite>cmap</cite> with the sign of the real part.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;threshold&quot;</span></code>, each square is plotted as
the maximum of <cite>cmap</cite> for the positive real part and as
the minimum for the negative part of the matrix element;
note that this generalizes <cite>“threshold”</cite> to complex numbers.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code>, each color is chosen according to
the angle of the corresponding matrix element.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not a quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qutip</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">rand_dm</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">colorblind_safe</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">color_style</span><span class="o">=</span><span class="s2">&quot;threshold&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">colorblind_safe</span> <span class="o">=</span> <span class="kc">False</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">color_style</span><span class="o">=</span><span class="s2">&quot;phase&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.matrix_histogram">
<code class="sig-name descname"><span class="pre">matrix_histogram</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>M</strong><span class="classifier">Matrix of Qobj</span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool (default: True)</span></dt><dd><p>show colorbar</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing extra options for the plot.
The names (keys) and values of the options are
described below:</p>
<dl class="simple">
<dt>‘zticks’<span class="classifier">list of numbers</span></dt><dd><p>A list of z-axis tick locations.</p>
</dd>
<dt>‘cmap’<span class="classifier">string (default: ‘jet’)</span></dt><dd><p>The name of the color map to use.</p>
</dd>
<dt>‘cmap_min’<span class="classifier">float (default: 0.0)</span></dt><dd><p>The lower bound to truncate the color map at.
A value in range 0 - 1. The default, 0, leaves the lower
bound of the map unchanged.</p>
</dd>
<dt>‘cmap_max’<span class="classifier">float (default: 1.0)</span></dt><dd><p>The upper bound to truncate the color map at.
A value in range 0 - 1. The default, 1, leaves the upper
bound of the map unchanged.</p>
</dd>
<dt>‘bars_spacing’<span class="classifier">float (default: 0.1)</span></dt><dd><p>spacing between bars.</p>
</dd>
<dt>‘bars_alpha’<span class="classifier">float (default: 1.)</span></dt><dd><p>transparency of bars, should be in range 0 - 1</p>
</dd>
<dt>‘bars_lw’<span class="classifier">float (default: 0.5)</span></dt><dd><p>linewidth of bars’ edges.</p>
</dd>
<dt>‘bars_edgecolor’<span class="classifier">color (default: ‘k’)</span></dt><dd><p>The colors of the bars’ edges.
Examples: ‘k’, (0.1, 0.2, 0.5) or ‘#0f0f0f80’.</p>
</dd>
<dt>‘shade’<span class="classifier">bool (default: True)</span></dt><dd><p>Whether to shade the dark sides of the bars (True) or not (False).
The shading is relative to plot’s source of light.</p>
</dd>
<dt>‘azim’<span class="classifier">float</span></dt><dd><p>The azimuthal viewing angle.</p>
</dd>
<dt>‘elev’<span class="classifier">float</span></dt><dd><p>The elevation viewing angle.</p>
</dd>
<dt>‘proj_type’<span class="classifier">string (default: ‘ortho’ if ax is not passed)</span></dt><dd><p>The type of projection (‘ortho’ or ‘persp’)</p>
</dd>
<dt>‘stick’<span class="classifier">bool (default: False)</span></dt><dd><p>Changes xlim and ylim in such a way that bars next to
XZ and YZ planes will stick to those planes.
This option has no effect if <code class="docutils literal notranslate"><span class="pre">ax</span></code> is passed as a parameter.</p>
</dd>
<dt>‘cbar_pad’<span class="classifier">float (default: 0.04)</span></dt><dd><p>The fraction of the original axes between the colorbar
and the new image axes.
(i.e. the padding between the 3D figure and the colorbar).</p>
</dd>
<dt>‘cbar_to_z’<span class="classifier">bool (default: False)</span></dt><dd><p>Whether to set the color of maximum and minimum z-values to the
maximum and minimum colors in the colorbar (True) or not (False).</p>
</dd>
<dt>‘figsize’<span class="classifier">tuple of two numbers</span></dt><dd><p>The size of the figure.</p>
</dd>
</dl>
</dd>
<dt><strong>Returns :</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.matrix_histogram_complex">
<code class="sig-name descname"><span class="pre">matrix_histogram_complex</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#matrix_histogram_complex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>M</strong><span class="classifier">Matrix of Qobj</span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of x labels</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>list of y labels</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>phase_limits</strong><span class="classifier">list/array with two float numbers</span></dt><dd><p>The phase-axis (colorbar) limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_energy_levels">
<code class="sig-name descname"><span class="pre">plot_energy_levels</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">12)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_list</strong><span class="classifier">List of Qobj</span></dt><dd><blockquote>
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="simple">
<dt>labels<span class="classifier">List of string</span></dt><dd><p>A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels<span class="classifier">Bool (default False)</span></dt><dd><p>Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N<span class="classifier">int</span></dt><dd><p>The number of energy levels to plot</p>
</dd>
<dt>figsize<span class="classifier">tuple (int,int)</span></dt><dd><p>The size of the figure (width, height).</p>
</dd>
<dt>fig<span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax<span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_expectation_values">
<code class="sig-name descname"><span class="pre">plot_expectation_values</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">4)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>results</strong><span class="classifier">(list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>List of results objects returned by any of the QuTiP evolution solvers.</p>
</dd>
<dt><strong>ylabels</strong><span class="classifier">list of strings</span></dt><dd><p>The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>The title of the figure.</p>
</dd>
<dt><strong>show_legend</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to show the legend.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_fock_distribution">
<code class="sig-name descname"><span class="pre">plot_fock_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_y_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>An optional title for the figure.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_qubism">
<code class="sig-name descname"><span class="pre">plot_qubism</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(6,</span> <span class="pre">6)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.  Works best for spin chains,
especially with even number of particles of the same dimension.  Allows to
see entanglement between first 2k particles and the rest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ (default) or ‘dark’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>how</strong><span class="classifier">‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’</span></dt><dd><p>Type of Qubism plotting.  Options:</p>
<ul class="simple">
<li><p>‘pairs’ - typical coordinates,</p></li>
<li><p>‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,</p></li>
<li><p>‘before_after’ - related to Schmidt plot (see also: plot_schmidt).</p></li>
</ul>
</dd>
<dt><strong>grid_iteration</strong><span class="classifier">int (default 1)</span></dt><dd><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</dd>
<dt><strong>legend_iteration</strong><span class="classifier">int (default 0) or ‘grid_iteration’ or ‘all’</span></dt><dd><p>Show labels for first <code class="docutils literal notranslate"><span class="pre">2*legend_iteration</span></code> particles.  Option
‘grid_iteration’ sets the same number of particles as for
grid_iteration.  Option ‘all’ makes label for all particles.  Typically
it should be 0, 1, 2 or perhaps 3.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See also <a class="reference internal" href="#r226a66bbc30b-1" id="id23">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r226a66bbc30b-1"><span class="brackets"><a class="fn-backref" href="#id23">1</a></span></dt>
<dd><p>J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein
and G. Sierra, <em>Qubism: self-similar visualization of many-body
wavefunctions</em>, <a class="reference external" href="https://dx.doi.org/10.1088/1367-2630/14/5/053028">New J. Phys. 14 053028</a>, arXiv:1112.3560
(2012), open access.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_schmidt">
<code class="sig-name descname"><span class="pre">plot_schmidt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(3,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(6,</span> <span class="pre">6)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=’before_after’ for a similar plot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>splitting</strong><span class="classifier">int</span></dt><dd><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ (default) or ‘dark’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>labels_iteration</strong><span class="classifier">int or pair of ints (default (3,2))</span></dt><dd><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_spin_distribution_2d">
<code class="sig-name descname"><span class="pre">plot_spin_distribution_2d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">THETA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PHI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">8)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_spin_distribution_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a spin distribution function (given as meshgrid data) with a 2D
projection where the surface of the unit sphere is mapped on the unit disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">matrix</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_spin_distribution_3d">
<code class="sig-name descname"><span class="pre">plot_spin_distribution_3d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">THETA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PHI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_spin_distribution_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">matrix</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_wigner">
<code class="sig-name descname"><span class="pre">plot_wigner</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(6,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clenshaw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>alpha_max</strong><span class="classifier">float</span></dt><dd><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<code class="sig-name descname"><span class="pre">plot_wigner_fock_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">4)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'iterative'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner_fock_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">a list of two matplotlib axes instances</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">(width, height)</span></dt><dd><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no ‘fig’ and ‘ax’ arguments are passed).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>alpha_max</strong><span class="classifier">float</span></dt><dd><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.plot_wigner_sphere">
<code class="sig-name descname"><span class="pre">plot_wigner_sphere</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wigner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflections</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a coloured Bloch sphere.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fig</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.figure.Figure</span></code></span></dt><dd><p>An instance of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Figure</span></code>.</p>
</dd>
<dt><strong>ax</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></span></dt><dd><p>An axes instance in the given figure.</p>
</dd>
<dt><strong>wigner</strong><span class="classifier">list of float</span></dt><dd><p>The wigner transformation at <cite>steps</cite> different theta and phi.</p>
</dd>
<dt><strong>reflections</strong><span class="classifier">bool</span></dt><dd><p>If the reflections of the sphere should be plotted as well.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Special thanks to Russell P Rundle for writing this function.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.visualization.sphereplot">
<code class="sig-name descname"><span class="pre">sphereplot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#sphereplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle with respect to z-axis</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle in x-y plane</p>
</dd>
<dt><strong>values</strong><span class="classifier">array</span></dt><dd><p>Data set to be plotted</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>save</strong><span class="classifier">bool {False , True}</span></dt><dd><p>Whether to save the figure or not</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-qutip.orbital"></span><dl class="py function">
<dt id="qutip.orbital.orbital">
<code class="sig-name descname"><span class="pre">orbital</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/orbital.html#orbital"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.orbital.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<code class="docutils literal notranslate"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></code> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math notranslate nohighlight">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math notranslate nohighlight">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l. The first entry of the ket defines the coefficient
c_{l,-l}, while the last entry of the ket defines the
coefficient c_{l, l}.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">int/float/list/array</span></dt><dd><p>Polar angles in [0, pi]</p>
</dd>
<dt><strong>phi</strong><span class="classifier">int/float/list/array</span></dt><dd><p>Azimuthal angles in [0, 2*pi]</p>
</dd>
<dt><strong>args</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> of ket vectors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code> for angular wave function evaluated at all</dt><dd><p>possible combinations of theta and phi</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-qutip.matplotlib_utilities"></span><p>This module contains utility functions that enhance Matplotlib
in one way or another.</p>
<dl class="py function">
<dt id="qutip.matplotlib_utilities.complex_phase_cmap">
<code class="sig-name descname"><span class="pre">complex_phase_cmap</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/matplotlib_utilities.html#complex_phase_cmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.matplotlib_utilities.complex_phase_cmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cyclic colormap for representing the phase of complex variables</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>cmap :</dt><dd><p>A matplotlib linear segmented colormap.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.matplotlib_utilities.wigner_cmap">
<code class="sig-name descname"><span class="pre">wigner_cmap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#09224F'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mid_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#FFFFFF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#530017'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#FF97D4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/matplotlib_utilities.html#wigner_cmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.matplotlib_utilities.wigner_cmap" title="Permalink to this definition">¶</a></dt>
<dd><p>A custom colormap that emphasizes negative values by creating a
nonlinear colormap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array</span></dt><dd><p>Wigner function array, or any array.</p>
</dd>
<dt><strong>levels</strong><span class="classifier">int</span></dt><dd><p>Number of color levels to create.</p>
</dd>
<dt><strong>shift</strong><span class="classifier">float</span></dt><dd><p>Shifts the value at which Wigner elements are emphasized.
This parameter should typically be negative and small (i.e -1e-5).</p>
</dd>
<dt><strong>max_color</strong><span class="classifier">str</span></dt><dd><p>String for color corresponding to maximum value of data.  Accepts
any string format compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>mid_color</strong><span class="classifier">str</span></dt><dd><p>Color corresponding to zero values.  Accepts any string format
compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>min_color</strong><span class="classifier">str</span></dt><dd><p>Color corresponding to minimum data values.  Accepts any string format
compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>neg_color</strong><span class="classifier">str</span></dt><dd><p>Color that starts highlighting negative values.  Accepts any string
format compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>invert</strong><span class="classifier">bool</span></dt><dd><p>Invert the color scheme for negative values so that smaller negative
values have darker color.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Returns a Matplotlib colormap instance for use in plotting.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘shift’ parameter allows you to vary where the colormap begins
to highlight negative colors. This is beneficial in cases where there
are small negative Wigner elements due to numerical round-off and/or
truncation.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.tomography.qpt">
<code class="sig-name descname"><span class="pre">qpt</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_basis_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</dd>
<dt><strong>op_basis_list</strong><span class="classifier">list</span></dt><dd><p>A list of Qobj’s representing the basis states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>QPT chi matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.tomography.qpt_plot">
<code class="sig-name descname"><span class="pre">qpt_plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbls_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">list of figure axis instance</span></dt><dd><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.tomography.qpt_plot_combined">
<code class="sig-name descname"><span class="pre">qpt_plot_combined</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbls_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">figure axis instance</span></dt><dd><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.operations.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.operations.gates" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.qip.operations.gates.berkeley">
<code class="sig-name descname"><span class="pre">berkeley</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#berkeley"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>berkeley_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Berkeley gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.cnot">
<code class="sig-name descname"><span class="pre">cnot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#cnot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cnot_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of CNOT gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.controlled_gate">
<code class="sig-name descname"><span class="pre">controlled_gate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#controlled_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Arbitrary single-qubit gate.</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the first control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
<dt><strong>control_value</strong><span class="classifier">integer (1)</span></dt><dd><p>The state of the control qubit that activates the gate U.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representing the controlled-U gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.cphase">
<code class="sig-name descname"><span class="pre">cphase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#cphase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the controlled phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of controlled phase gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.csign">
<code class="sig-name descname"><span class="pre">csign</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#csign"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>csign_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of CSIGN gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.expand_operator">
<code class="sig-name descname"><span class="pre">expand_operator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#expand_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.expand_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a qubits operator to one that acts on a N-qubit system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>An operator acts on qubits, the type of the <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>
has to be an operator
and the dimension matches the tensored qubit Hilbert space
e.g. dims = <code class="docutils literal notranslate"><span class="pre">[[2,</span> <span class="pre">2,</span> <span class="pre">2],</span> <span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">2]]</span></code></p>
</dd>
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">int or list of int</span></dt><dd><p>The indices of qubits that are acted on.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list, optional</span></dt><dd><p>A list of integer for the dimension of each composite system.
E.g <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2]</span></code> for 5 qubits system. If None, qubits system
will be the default option.</p>
</dd>
<dt><strong>cyclic_permutation</strong><span class="classifier">boolean, optional</span></dt><dd><p>Expand for all cyclic permutation of the targets.
E.g. if <code class="docutils literal notranslate"><span class="pre">N=3</span></code> and <cite>oper</cite> is a 2-qubit operator,
the result will be a list of three operators,
each acting on qubits 0 and 1, 1 and 2, 2 and 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>expanded_oper</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The expanded qubits operator acting on a system with N qubits.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is equivalent to gate_expand_1toN, gate_expand_2toN,
gate_expand_3toN in <code class="docutils literal notranslate"><span class="pre">qutip.qip.gate.py</span></code>, but works for any dimension.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.fredkin">
<code class="sig-name descname"><span class="pre">fredkin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1,</span> <span class="pre">2]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#fredkin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fredkin_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Fredkin gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.gate_expand_1toN">
<code class="sig-name descname"><span class="pre">gate_expand_1toN</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#gate_expand_1toN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The one-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.gate_expand_2toN">
<code class="sig-name descname"><span class="pre">gate_expand_2toN</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#gate_expand_2toN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The two-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong><span class="classifier">integer</span></dt><dd><p>The index of the control qubit.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list</span></dt><dd><p>List of target qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.gate_expand_3toN">
<code class="sig-name descname"><span class="pre">gate_expand_3toN</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#gate_expand_3toN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>The three-qubit gate</p>
</dd>
<dt><strong>N</strong><span class="classifier">integer</span></dt><dd><p>The number of qubits in the target space.</p>
</dd>
<dt><strong>controls</strong><span class="classifier">list</span></dt><dd><p>The list of the control qubits.</p>
</dd>
<dt><strong>target</strong><span class="classifier">integer</span></dt><dd><p>The index of the target qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.gate_sequence_product">
<code class="sig-name descname"><span class="pre">gate_sequence_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_to_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#gate_sequence_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U_list: list</strong></dt><dd><p>List of gates implementing the quantum circuit.</p>
</dd>
<dt><strong>left_to_right: Boolean, optional</strong></dt><dd><p>Check if multiplication is to be done from left to right.</p>
</dd>
<dt><strong>inds_list: list of list of int, optional</strong></dt><dd><p>If expand=True, list of qubit indices corresponding to U_list
to which each unitary is applied.</p>
</dd>
<dt><strong>expand: Boolean, optional</strong></dt><dd><p>Check if the list of unitaries need to be expanded to full dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U_overall</strong><span class="classifier">qobj</span></dt><dd><p>Unitary matrix corresponding to U_list.</p>
</dd>
<dt><strong>overall_inds</strong><span class="classifier">list of int, optional</span></dt><dd><p>List of qubit indices on which U_overall applies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.globalphase">
<code class="sig-name descname"><span class="pre">globalphase</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#globalphase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phase_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of global phase shift gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.hadamard_transform">
<code class="sig-name descname"><span class="pre">hadamard_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#hadamard_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of the N-qubit Hadamard gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.iswap">
<code class="sig-name descname"><span class="pre">iswap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#iswap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of iSWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.phasegate">
<code class="sig-name descname"><span class="pre">phasegate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#phasegate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Phase rotation angle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phase_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of phase shift gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.rotation">
<code class="sig-name descname"><span class="pre">rotation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.rx">
<code class="sig-name descname"><span class="pre">rx</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#rx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.ry">
<code class="sig-name descname"><span class="pre">ry</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#ry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.rz">
<code class="sig-name descname"><span class="pre">rz</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#rz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.snot">
<code class="sig-name descname"><span class="pre">snot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#snot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>snot_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SNOT gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.sqrtiswap">
<code class="sig-name descname"><span class="pre">sqrtiswap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#sqrtiswap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sqrtiswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of square root iSWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.sqrtnot">
<code class="sig-name descname"><span class="pre">sqrtnot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#sqrtnot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object for operator describing the square root NOT gate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.sqrtswap">
<code class="sig-name descname"><span class="pre">sqrtswap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#sqrtswap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sqrtswap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of square root SWAP gate</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.swap">
<code class="sig-name descname"><span class="pre">swap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#swap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>swap_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SWAP gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.swapalpha">
<code class="sig-name descname"><span class="pre">swapalpha</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#swapalpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>swapalpha_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of SWAPalpha gate</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.operations.gates.toffoli">
<code class="sig-name descname"><span class="pre">toffoli</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/operations/gates.html#toffoli"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.operations.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>toff_gate</strong><span class="classifier">qobj</span></dt><dd><p>Quantum object representation of Toffoli gate.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]],                     shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.qip.qubits.qubit_states">
<code class="sig-name descname"><span class="pre">qubit_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/qubits.html#qubit_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">Integer</span></dt><dd><p>Number of qubits in the register.</p>
</dd>
<dt><strong>states</strong><span class="classifier">List</span></dt><dd><p>Initial state of each qubit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qstates</strong><span class="classifier">Qobj</span></dt><dd><p>List of qubits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<p>This module provides the circuit implementation for Quantum Fourier Transform.</p>
<dl class="py function">
<dt id="qutip.qip.algorithms.qft.qft">
<code class="sig-name descname"><span class="pre">qft</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>QFT: qobj</dt><dd><p>Quantum Fourier transform operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<code class="sig-name descname"><span class="pre">qft_gate_sequence</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">swapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft_gate_sequence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt><dd><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: instance of QubitCircuit</dt><dd><p>Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<code class="sig-name descname"><span class="pre">qft_steps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">swapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft_steps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt><dd><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_step_list: list of qobj</dt><dd><p>List of Hadamard and controlled rotation gates implementing QFT.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qasm">
<span id="circuit"></span><h3>Circuit<a class="headerlink" href="#module-qutip.qip.qasm" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.qip.qasm.circuit_to_qasm_str">
<code class="sig-name descname"><span class="pre">circuit_to_qasm_str</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/qasm.html#circuit_to_qasm_str"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.qasm.circuit_to_qasm_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return QASM output of circuit object as string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>circuit object to produce QASM output for.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: str</dt><dd><p>string corresponding to QASM output.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.qasm.print_qasm">
<code class="sig-name descname"><span class="pre">print_qasm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/qasm.html#print_qasm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.qasm.print_qasm" title="Permalink to this definition">¶</a></dt>
<dd><p>Print QASM output of circuit object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>circuit object to produce QASM output for.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.qasm.read_qasm">
<code class="sig-name descname"><span class="pre">read_qasm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qasm_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qiskit'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2.0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/qasm.html#read_qasm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.qasm.read_qasm" title="Permalink to this definition">¶</a></dt>
<dd><p>Read OpenQASM intermediate representation
(<a class="reference external" href="https://github.com/Qiskit/openqasm">https://github.com/Qiskit/openqasm</a>) and return
a <a class="reference internal" href="classes.html#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> and state inputs as specified in the
QASM file.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qasm_input</strong><span class="classifier">str</span></dt><dd><p>File location or String Input for QASM file to be imported. In case of
string input, the parameter strmode must be True.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>QASM mode to be read in. When mode is “qiskit”,
the “qelib1.inc” include is automatically included,
without checking externally. Otherwise, each include is
processed.</p>
</dd>
<dt><strong>version</strong><span class="classifier">str</span></dt><dd><p>QASM version of the QASM file. Only version 2.0 is currently supported.</p>
</dd>
<dt><strong>strmode</strong><span class="classifier">bool</span></dt><dd><p>if specified as True, indicates that qasm_input is in string format
rather than from file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>qc</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></span></dt><dd><p>Returns a <a class="reference internal" href="classes.html#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> object specified in the QASM file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.qip.qasm.save_qasm">
<code class="sig-name descname"><span class="pre">save_qasm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_loc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/qasm.html#save_qasm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.qasm.save_qasm" title="Permalink to this definition">¶</a></dt>
<dd><p>Save QASM output of circuit object to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>circuit object to produce QASM output for.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.nonmarkov.transfertensor">
<span id="non-markovian-solvers"></span><span id="functions-non-markov"></span><h2>Non-Markovian Solvers<a class="headerlink" href="#module-qutip.nonmarkov.transfertensor" title="Permalink to this headline">¶</a></h2>
<p>This module contains an implementation of the non-Markovian transfer tensor
method (TTM), introduced in [1].</p>
<p>[1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)</p>
<dl class="py function">
<dt id="qutip.nonmarkov.transfertensor.ttmsolve">
<code class="sig-name descname"><span class="pre">ttmsolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynmaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learningtimes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/transfertensor.html#ttmsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.ttmsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve time-evolution using the Transfer Tensor Method, based on a set of
precomputed dynamical maps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dynmaps</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier">array_like</span></dt><dd><p>list of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to compute <span class="math notranslate nohighlight">\(\rho(t_n)\)</span>.
Must be uniformily spaced.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function</span></dt><dd><p>single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>learningtimes</strong><span class="classifier">array_like</span></dt><dd><p>list of times <span class="math notranslate nohighlight">\(t_k\)</span> for which we have knowledge of the dynamical
maps <span class="math notranslate nohighlight">\(E(t_k)\)</span>.</p>
</dd>
<dt><strong>tensors</strong><span class="classifier">array_like</span></dt><dd><p>optional list of precomputed tensors <span class="math notranslate nohighlight">\(T_k\)</span></p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dictionary</span></dt><dd><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.nonmarkov.transfertensor.TTMSolverOptions" title="qutip.nonmarkov.transfertensor.TTMSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.nonmarkov.transfertensor.TTMSolverOptions</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>output: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.control.pulseoptim">
<span id="optimal-control"></span><span id="functions-control"></span><h2>Optimal control<a class="headerlink" href="#module-qutip.control.pulseoptim" title="Permalink to this headline">¶</a></h2>
<p>Wrapper functions that will manage the creation of the objects,
build the configuration, and execute the algorithm required to optimise
a set of ctrl pulses for a given (quantum) system.
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.
The functions minimise this fidelity error wrt the piecewise control
amplitudes in the timeslots</p>
<p>There are currently two quantum control pulse optmisations algorithms
implemented in this library. There are accessible through the methods
in this module. Both the algorithms use the scipy.optimize methods
to minimise the fidelity error with respect to to variables that define
the pulse.</p>
<div class="section" id="grape">
<h3>GRAPE<a class="headerlink" href="#grape" title="Permalink to this headline">¶</a></h3>
<p>The default algorithm (as it was implemented here first) is GRAPE
GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such
as BFGS to minimise the fidelity error. This makes convergence very quick
when an exact gradient can be calculated, but this limits the factors that can
taken into account in the fidelity.</p>
</div>
<div class="section" id="crab">
<h3>CRAB<a class="headerlink" href="#crab" title="Permalink to this headline">¶</a></h3>
<p>The CRAB [3][4] algorithm was developed at the University of Ulm.
In full it is the Chopped RAndom Basis algorithm.
The main difference is that it reduces the number of optimisation variables
by defining the control pulses by expansions of basis functions,
where the variables are the coefficients. Typically a Fourier series is chosen,
i.e. the variables are the Fourier coefficients.
Therefore it does not need to compute an explicit gradient.
By default it uses the Nelder-Mead method for fidelity error minimisation.</p>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>N Khaneja et. al.
Optimal control of coupled spin dynamics: Design of NMR pulse sequences
by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).</p></li>
<li><p>Shai Machnes et.al
DYNAMO - Dynamic Framework for Quantum Optimal Control
arXiv.1011.4874</p></li>
<li><p>Doria, P., Calarco, T. &amp; Montangero, S.
Optimal Control Technique for Many-Body Quantum Dynamics.
Phys. Rev. Lett. 106, 1–4 (2011).</p></li>
<li><p>Caneva, T., Calarco, T. &amp; Montangero, S.
Chopped random-basis quantum optimization.
Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011).</p></li>
</ol>
<dl class="py function">
<dt id="qutip.control.pulseoptim.create_pulse_optimizer">
<code class="sig-name descname"><span class="pre">create_pulse_optimizer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">drift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evo_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_lbound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_targ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wall_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GRAPE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_metric_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accuracy_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GEN_MAT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_update_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#create_pulse_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulseoptim.create_pulse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the objects of the appropriate subclasses required for the pulse
optmisation based on the parameters given Note this method may be
preferable to calling optimize_pulse if more detailed configuration is
required before running the optmisation algorthim, or the algorithm will be
run many times, for instances when trying to finding global the optimum or
minimum time optimisation</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>The underlying dynamics generator of the system can provide list (of
length num_tslots) for time dependent drift.</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>A list of control dynamics generators. These are scaled by the
amplitudes to alter the overall dynamics.  Array-like input can be
provided for time dependent control generators.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>Starting point for the evolution.  Typically the identity matrix.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Target transformation, e.g. gate or state, for the time evolution.</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>Number of timeslots.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be given in
the tau array.</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>Total time for the evolution.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be
given in the tau array.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>Durations for the timeslots.  If this is given then <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> and
<code class="docutils literal notranslate"><span class="pre">evo_time</span></code> are dervived from it.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslot
durations will be equal and calculated as <code class="docutils literal notranslate"><span class="pre">evo_time/num_tslots</span></code>.</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Lower boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Upper boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will terminate when the
fidelity error falls below this value.</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the gradients wrt to
the control amplitudes falls below this value, the optimisation
terminates, assuming local minima.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm.</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the optimisation algorithm.</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.
Options are:</p>
<ul class="simple">
<li><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering</p></li>
<li><p>‘CRAB’ - Chopped RAndom Basis</p></li>
</ul>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value used to set
attribute values.  Note: attributes are created if they do not exist
already, and are overwritten if they do.  Note: method_params are
applied afterwards and so may override these.</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<ul class="simple">
<li><p>GRAPE - Default optim_method is FMIN_L_BFGS_B</p></li>
<li><p>CRAB - Default optim_method is Nelder-Mead</p></li>
</ul>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.
Note that where there is an attribute of the
<a class="reference internal" href="classes.html#qutip.control.optimizer.Optimizer" title="qutip.control.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a> object or the
termination_conditions matching the key that attribute. Otherwise,
and in some case also, they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use method_params instead</p>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Pass in fid_params instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use scale_factor key in fid_params instead.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the TimeslotComputer object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>type / shape of pulse(s) used to initialise the
the control amplitudes.
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p>(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.
It’s intended use for a ramping modulation, which is often required in
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">Optimizer</span></dt><dd><p>Instance of an Optimizer, through which the
Config, Dynamics, PulseGen, and TerminationConditions objects
can be accessed as attributes.
The PropagatorComputer, FidelityComputer and TimeslotComputer objects
can be accessed as attributes of the Dynamics object,
e.g. optimizer.dynamics.fid_computer The optimisation can be run
through the optimizer.run_optimization</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab">
<code class="sig-name descname"><span class="pre">opt_pulse_crab</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">drift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evo_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_lbound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_targ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wall_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_coeff_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fmin'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GEN_MAT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MODULATE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_file_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#opt_pulse_crab"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.
The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>Starting point for the evolution.  Typically the identity matrix.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Target transformation, e.g. gate or state, for the time evolution.</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>Number of timeslots.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be given in
the tau array.</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>Total time for the evolution.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be
given in the tau array.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>Durations for the timeslots.  If this is given then <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> and
<code class="docutils literal notranslate"><span class="pre">evo_time</span></code> are dervived from it.
<code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslot durations will be equal and calculated
as <code class="docutils literal notranslate"><span class="pre">evo_time/num_tslots</span></code>.</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Lower boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Upper boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will terminate when the
fidelity error falls below this value.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm.</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm.</p>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>Options that are specific to the algorithm see above.</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value used to set
attribute values.  Note: attributes are created if they do not exist
already, and are overwritten if they do.  Note: method_params are
applied afterwards and so may override these.</p>
</dd>
<dt><strong>coeff_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for the random basis coefficients.  By default
these range from -1.0 to 1.0.  Note this is overridden by alg_params
(if given there).</p>
</dd>
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function.  Note this is
calculated automatically based on the dimension of the dynamics if not
given. It is crucial to the performane of the algorithm that it is set
as low as possible, while still giving high enough frequencies.  Note
this is overridden by alg_params (if given there).</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>Multi-variable optimisation method.  The only tested options are ‘fmin’
and ‘Nelder-mead’.  In theory any non-gradient method implemented in
scipy.optimize.mininize could be used.</p>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the optim_method.  Note that where there is an attribute
of the <a class="reference internal" href="classes.html#qutip.control.optimizer.Optimizer" title="qutip.control.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a> object or the
termination_conditions matching the key that attribute. Otherwise,
and in some case also, they are assumed to be method_options for the
<code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method.  The commonly used parameter are:</p>
<ul class="simple">
<li><p>xtol - limit on variable change for convergence</p></li>
<li><p>ftol - limit on fidelity error change for convergence</p></li>
</ul>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe the dynamics.
Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details).</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.dynamics.Dynamics" title="qutip.control.dynamics.Dynamics"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.control.dynamics.Dynamics</span></code></a> object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the propagtors and
propagtor gradient for each timeslot options are DEF, APPROX, DIAG,
FRECHET, AUG_MAT DEF will use the default for the specific dyn_type
(see <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a> classes for
details).</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method.
Options are DEF, UNIT, TRACEDIFF, TD_APPROX.  DEF will use the default
for the specific dyn_type.
(See <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a> classes for
details).</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and evolution
in the timeslots.  Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the
only one that currently works.
(See <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a> classes
for details).</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>guess_pulse_type</strong><span class="classifier">string, default None</span></dt><dd><p>Type / shape of pulse(s) used modulate the control amplitudes.
Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN.</p>
</dd>
<dt><strong>guess_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the guess pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>guess_pulse_action</strong><span class="classifier">string, default ‘MODULATE’</span></dt><dd><p>Determines how the guess pulse is applied to the pulse generated by the
basis expansion.  Options are: MODULATE, ADD.</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated guess pulses.  By default initial
pulses are generated with amplitudes in the range (-1.0, 1.0). These
will be scaled by this parameter.</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added to any
guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.  It’s intended use
for a ramping modulation, which is often required in experimental
setups.  This is only currently implemented in CRAB.  GAUSSIAN_EDGE was
added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.  Options are attributes of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.logging_utils</span></code>, in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution, assuming
everything runs as expected.  The default NOTSET implies that the level
will be taken from the QuTiP settings file, which by default is WARN.</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>Files containing the initial and final control pulse.  Amplitudes are
saved to the current directory.  The default name will be postfixed
with this extension.  Setting this to <code class="docutils literal notranslate"><span class="pre">None</span></code> will suppress the output
of files.</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then statistics for the optimisation run will be
generated - accessible through attributes of the stats object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab_unitary">
<code class="sig-name descname"><span class="pre">opt_pulse_crab_unitary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_targ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evo_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_lbound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_targ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wall_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_coeff_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fmin'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PSU'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_pulse_action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MODULATE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_file_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#opt_pulse_crab_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that the
dynamics of the system are generated by unitary operators.  This function
is simply a wrapper for optimize_pulse, where the appropriate options for
unitary dynamics are chosen and the parameter names are in the format
familiar to unitary dynamics.  The dynamics of the system  in any given
timeslot are governed by the combined Hamiltonian, i.e. the sum of the
<code class="docutils literal notranslate"><span class="pre">H_d</span> <span class="pre">+</span> <span class="pre">ctrl_amp[j]*H_c[j]</span></code> The control pulse is an <code class="docutils literal notranslate"><span class="pre">[n_ts,</span> <span class="pre">n_ctrls]</span></code>
array of piecewise amplitudes.</p>
<p>The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.  A multivariable
optimisation algorithm attempts to determines the optimal values for the
control pulse to minimise the fidelity error.  The fidelity error is some
measure of distance of the system evolution from the given target evolution
in the time allowed for the evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_d</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>Drift (aka system) the underlying Hamiltonian of the system can provide
list (of length num_tslots) for time dependent drift.</p>
</dd>
<dt><strong>H_c</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>A list of control Hamiltonians. These are scaled by the amplitudes to
alter the overall dynamics.  Array like imput can be provided for time
dependent control generators.</p>
</dd>
<dt><strong>U_0</strong><span class="classifier">Qobj</span></dt><dd><p>Starting point for the evolution.  Typically the identity matrix.</p>
</dd>
<dt><strong>U_targ</strong><span class="classifier">Qobj</span></dt><dd><p>Target transformation, e.g. gate or state, for the time evolution.</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>Number of timeslots.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be given in
the tau array.</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>Total time for the evolution.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be
given in the tau array.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>Durations for the timeslots.  If this is given then <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> and
<code class="docutils literal notranslate"><span class="pre">evo_time</span></code> are derived from it.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslot
durations will be equal and calculated as <code class="docutils literal notranslate"><span class="pre">evo_time/num_tslots</span></code>.</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Lower boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Upper boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will terminate when the
fidelity error falls below this value.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm.</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the optimisation algorithm.</p>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>Options that are specific to the algorithm see above.</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value used to set
attribute values.  Note: attributes are created if they do not exist
already, and are overwritten if they do.  Note: <code class="docutils literal notranslate"><span class="pre">method_params</span></code> are
applied afterwards and so may override these.</p>
</dd>
<dt><strong>coeff_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for the random basis coefficients.  By default
these range from -1.0 to 1.0.  Note this is overridden by
<code class="docutils literal notranslate"><span class="pre">alg_params</span></code> (if given there).</p>
</dd>
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function.  Note this is
calculated automatically based on the dimension of the dynamics if not
given. It is crucial to the performance of the algorithm that it is set
as low as possible, while still giving high enough frequencies.  Note
this is overridden by <code class="docutils literal notranslate"><span class="pre">alg_params</span></code> (if given there).</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>Multi-variable optimisation method.  The only tested options are ‘fmin’
and ‘Nelder-mead’.  In theory any non-gradient method implemented in
<code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> could be used.</p>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <code class="docutils literal notranslate"><span class="pre">optim_method</span></code>.  Note that where there is an
attribute of the <a class="reference internal" href="classes.html#qutip.control.optimizer.Optimizer" title="qutip.control.optimizer.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a> object or
the termination_conditions matching the key that attribute. Otherwise,
and in some case also, they are assumed to be method_options for the
<code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method.  The commonly used parameter are:</p>
<ul class="simple">
<li><p>xtol - limit on variable change for convergence</p></li>
<li><p>ftol - limit on fidelity error change for convergence</p></li>
</ul>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Determines how global phase is treated in fidelity calculations
(<code class="docutils literal notranslate"><span class="pre">fid_type='UNIT'</span></code> only). Options:</p>
<ul class="simple">
<li><p>PSU - global phase ignored</p></li>
<li><p>SU - global phase included</p></li>
</ul>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.dynamics.Dynamics" title="qutip.control.dynamics.Dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dynamics</span></code></a> object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and evolution
in the timeslots.  Options: DEF, UPDATE_ALL, DYNAMIC.  UPDATE_ALL is
the only one that currently works.
(See <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a> classes for
details).</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>guess_pulse_type</strong><span class="classifier">string, optional</span></dt><dd><p>Type / shape of pulse(s) used modulate the control amplitudes.
Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN.</p>
</dd>
<dt><strong>guess_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the guess pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>guess_pulse_action</strong><span class="classifier">string, ‘MODULATE’</span></dt><dd><p>Determines how the guess pulse is applied to the pulse generated by the
basis expansion.  Options are: MODULATE, ADD.</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated guess pulses.  By default initial
pulses are generated with amplitudes in the range (-1.0, 1.0). These
will be scaled by this parameter.</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added to any
guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.  It’s intended use
for a ramping modulation, which is often required in experimental
setups.  This is only currently implemented in CRAB.  GAUSSIAN_EDGE was
added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>Level of messaging output from the logger.  Options are attributes of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.logging_utils</span></code>, in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.
Anything WARN or above is effectively ‘quiet’ execution, assuming
everything runs as expected.  The default NOTSET implies that the level
will be taken from the QuTiP settings file, which by default is WARN.</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>Files containing the initial and final control pulse amplitudes are
saved to the current directory.  The default name will be postfixed
with this extension.  Setting this to None will suppress the output of
files.</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then statistics for the optimisation run will be
generated - accessible through attributes of the stats object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of <a class="reference internal" href="classes.html#qutip.control.optimresult.OptimResult" title="qutip.control.optimresult.OptimResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimResult</span></code></a>,
which has attributes giving the reason for termination, final fidelity
error, final evolution final amplitudes, statistics etc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.control.pulseoptim.optimize_pulse">
<code class="sig-name descname"><span class="pre">optimize_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">drift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evo_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_lbound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_targ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wall_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GRAPE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_metric_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accuracy_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GEN_MAT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_scale_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_update_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_file_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#optimize_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.  The dynamics of
the system in any given timeslot are governed by the combined dynamics
generator, i.e. the sum of the <code class="docutils literal notranslate"><span class="pre">drift</span> <span class="pre">+</span> <span class="pre">ctrl_amp[j]*ctrls[j]</span></code>.</p>
<p>The control pulse is an <code class="docutils literal notranslate"><span class="pre">[n_ts,</span> <span class="pre">n_ctrls]</span></code> array of piecewise amplitudes
Starting from an initial (typically random) pulse, a multivariable
optimisation algorithm attempts to determines the optimal values for the
control pulse to minimise the fidelity error.  The fidelity error is some
measure of distance of the system evolution from the given target evolution
in the time allowed for the evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drift</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>The underlying dynamics generator of the system can provide list (of
length <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code>) for time dependent drift.</p>
</dd>
<dt><strong>ctrls</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>A list of control dynamics generators. These are scaled by the
amplitudes to alter the overall dynamics.  Array-like input can be
provided for time dependent control generators.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>Starting point for the evolution.  Typically the identity matrix.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Target transformation, e.g. gate or state, for the time evolution.</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>Number of timeslots.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be given in
the tau array.</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>Total time for the evolution.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be
given in the tau array.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>Durations for the timeslots.  If this is given then <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> and
<code class="docutils literal notranslate"><span class="pre">evo_time</span></code> are derived from it.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslot
durations will be equal and calculated as <code class="docutils literal notranslate"><span class="pre">evo_time/num_tslots</span></code>.</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Lower boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Upper boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will terminate when the
fidelity error falls below this value.</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the gradients wrt to
the control amplitudes falls below this value, the optimisation
terminates, assuming local minima.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm.</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the  optimisation algorithm.</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.  Options are:</p>
<ul class="simple">
<li><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering</p></li>
<li><p>‘CRAB’ - Chopped RAndom Basis</p></li>
</ul>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>Options that are specific to the algorithm see above.</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value used to set
attribute values.  Note: attributes are created if they do not exist
already, and are overwritten if they do.  Note: <code class="docutils literal notranslate"><span class="pre">method_params</span></code> are
applied afterwards and so may override these.</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method that will be used to optimise the
pulse for minimum fidelity error.  Note that <code class="docutils literal notranslate"><span class="pre">FMIN</span></code>, <code class="docutils literal notranslate"><span class="pre">FMIN_BFGS</span></code> &amp;
<code class="docutils literal notranslate"><span class="pre">FMIN_L_BFGS_B</span></code> will all result in calling these specific
<code class="docutils literal notranslate"><span class="pre">scipy.optimize</span> <span class="pre">methods</span></code>.  Note the <code class="docutils literal notranslate"><span class="pre">LBFGSB</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">FMIN_L_BFGS_B</span></code> for backwards compatibility reasons.  Supplying DEF
will given alg dependent result:</p>
<ul class="simple">
<li><p>GRAPE - Default <code class="docutils literal notranslate"><span class="pre">optim_method</span></code> is <code class="docutils literal notranslate"><span class="pre">FMIN_L_BFGS_B</span></code></p></li>
<li><p>CRAB - Default <code class="docutils literal notranslate"><span class="pre">optim_method</span></code> is <code class="docutils literal notranslate"><span class="pre">FMIN</span></code></p></li>
</ul>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <code class="docutils literal notranslate"><span class="pre">optim_method</span></code>.  Note that where there is an
attribute of the <a class="reference internal" href="classes.html#qutip.control.optimizer.Optimizer" title="qutip.control.optimizer.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a> object or
the termination_conditions matching the key that attribute.
Otherwise, and in some case also, they are assumed to be method_options
for the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">optim_method</span></code>.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">method_params</span></code> instead.</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">method_params</span></code> instead.</p>
</dd>
<dt><strong>dyn_type</strong><span class="classifier">string</span></dt><dd><p>Dynamics type, i.e. the type of matrix used to describe the dynamics.
Options are <code class="docutils literal notranslate"><span class="pre">UNIT</span></code>, <code class="docutils literal notranslate"><span class="pre">GEN_MAT</span></code>, <code class="docutils literal notranslate"><span class="pre">SYMPL</span></code>
(see <a class="reference internal" href="classes.html#qutip.control.dynamics.Dynamics" title="qutip.control.dynamics.Dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dynamics</span></code></a> classes for details).</p>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.dynamics.Dynamics" title="qutip.control.dynamics.Dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dynamics</span></code></a> object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>prop_type</strong><span class="classifier">string</span></dt><dd><p>Propagator type i.e. the method used to calculate the propagators and
propagator gradient for each timeslot options are DEF, APPROX, DIAG,
FRECHET, AUG_MAT.  DEF will use the default for the specific
<code class="docutils literal notranslate"><span class="pre">dyn_type</span></code> (see <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a>
classes for details).</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>fid_type</strong><span class="classifier">string</span></dt><dd><p>Fidelity error (and fidelity error gradient) computation method.
Options are DEF, UNIT, TRACEDIFF, TD_APPROX.  DEF will use the default
for the specific <code class="docutils literal notranslate"><span class="pre">dyn_type</span></code>
(See <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a> classes for
details).</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Pass in <code class="docutils literal notranslate"><span class="pre">fid_params</span></code> instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> key in <code class="docutils literal notranslate"><span class="pre">fid_params</span></code> instead.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and evolution
in the timeslots.  Options: DEF, UPDATE_ALL, DYNAMIC.  UPDATE_ALL is
the only one that currently works.
(See <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a> classes for
details.)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs. They applied after the object is created.</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">tslot_type</span></code> instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type / shape of pulse(s) used to initialise the control amplitudes.
Options (GRAPE) include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW.
Default is RND. (see <a class="reference internal" href="classes.html#qutip.control.pulsegen.PulseGen" title="qutip.control.pulsegen.PulseGen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PulseGen</span></code></a> classes
for details). For the CRAB the this the <code class="docutils literal notranslate"><span class="pre">guess_pulse_type</span></code>.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses.  By default
initial pulses are generated with amplitudes in the range (-1.0, 1.0).
These will be scaled by this parameter.</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added to any
initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.  It’s intended use
for a ramping modulation, which is often required in experimental
setups.  This is only currently implemented in CRAB.  GAUSSIAN_EDGE was
added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>Level of messaging output from the logger.  Options are attributes of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.logging_utils</span></code>, in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.
Anything WARN or above is effectively ‘quiet’ execution, assuming
everything runs as expected.  The default NOTSET implies that the level
will be taken from the QuTiP settings file, which by default is WARN.</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>Files containing the initial and final control pulse amplitudes are
saved to the current directory.  The default name will be postfixed
with this extension.  Setting this to None will suppress the output of
files.</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>If set to True then statistics for the optimisation run will be
generated - accessible through attributes of the stats object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of <a class="reference internal" href="classes.html#qutip.control.optimresult.OptimResult" title="qutip.control.optimresult.OptimResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimResult</span></code></a>,
which has attributes giving the reason for termination, final fidelity
error, final evolution final amplitudes, statistics etc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.control.pulseoptim.optimize_pulse_unitary">
<code class="sig-name descname"><span class="pre">optimize_pulse_unitary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H_c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_targ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evo_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_lbound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_err_targ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_wall_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GRAPE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optim_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_metric_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accuracy_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PSU'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tslot_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp_update_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DEF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ramping_pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_file_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#optimize_pulse_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that the
dynamics of the system are generated by unitary operators.  This function
is simply a wrapper for optimize_pulse, where the appropriate options for
unitary dynamics are chosen and the parameter names are in the format
familiar to unitary dynamics The dynamics of the system  in any given
timeslot are governed by the combined Hamiltonian, i.e. the sum of the
<code class="docutils literal notranslate"><span class="pre">H_d</span> <span class="pre">+</span> <span class="pre">ctrl_amp[j]*H_c[j]</span></code> The control pulse is an <code class="docutils literal notranslate"><span class="pre">[n_ts,</span> <span class="pre">n_ctrls]</span></code>
array of piecewise amplitudes Starting from an initial (typically random)
pulse, a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error The
maximum fidelity for a unitary system is 1, i.e. when the time evolution
resulting from the pulse is equivalent to the target.  And therefore the
fidelity error is <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">fidelity</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_d</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>Drift (aka system) the underlying Hamiltonian of the system can provide
list (of length <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code>) for time dependent drift.</p>
</dd>
<dt><strong>H_c</strong><span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt><dd><p>A list of control Hamiltonians. These are scaled by the amplitudes to
alter the overall dynamics.  Array-like input can be provided for time
dependent control generators.</p>
</dd>
<dt><strong>U_0</strong><span class="classifier">Qobj</span></dt><dd><p>Starting point for the evolution.  Typically the identity matrix.</p>
</dd>
<dt><strong>U_targ</strong><span class="classifier">Qobj</span></dt><dd><p>Target transformation, e.g. gate or state, for the time evolution.</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer or None</span></dt><dd><p>Number of timeslots.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be given in
the tau array.</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float or None</span></dt><dd><p>Total time for the evolution.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslots will be
given in the tau array.</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of floats or None</span></dt><dd><p>Durations for the timeslots.  If this is given then <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> and
<code class="docutils literal notranslate"><span class="pre">evo_time</span></code> are derived from it.  <code class="docutils literal notranslate"><span class="pre">None</span></code> implies that timeslot
durations will be equal and calculated as <code class="docutils literal notranslate"><span class="pre">evo_time/num_tslots</span></code>.</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Lower boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>Upper boundaries for the control amplitudes.  Can be a scalar value
applied to all controls or a list of bounds for each control.</p>
</dd>
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Fidelity error target. Pulse optimisation will terminate when the
fidelity error falls below this value.</p>
</dd>
<dt><strong>mim_grad</strong><span class="classifier">float</span></dt><dd><p>Minimum gradient. When the sum of the squares of the gradients wrt to
the control amplitudes falls below this value, the optimisation
terminates, assuming local minima.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of iterations of the optimisation algorithm.</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p>Maximum allowed elapsed time for the optimisation algorithm.</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.  Options are:</p>
<ul class="simple">
<li><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering</p></li>
<li><p>‘CRAB’ - Chopped RAndom Basis</p></li>
</ul>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong><span class="classifier">Dictionary</span></dt><dd><p>The key value pairs are the attribute name and value used to set
attribute values.  Note: attributes are created if they do not exist
already, and are overwritten if they do.  Note: <code class="docutils literal notranslate"><span class="pre">method_params</span></code> are
applied afterwards and so may override these.</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method that will be used to optimise the
pulse for minimum fidelity error Note that <code class="docutils literal notranslate"><span class="pre">FMIN</span></code>, <code class="docutils literal notranslate"><span class="pre">FMIN_BFGS</span></code> &amp;
<code class="docutils literal notranslate"><span class="pre">FMIN_L_BFGS_B</span></code> will all result in calling these specific
scipy.optimize methods Note the <code class="docutils literal notranslate"><span class="pre">LBFGSB</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">FMIN_L_BFGS_B</span></code> for backwards compatibility reasons.  Supplying
<code class="docutils literal notranslate"><span class="pre">DEF</span></code> will given algorithm-dependent result:</p>
<ul class="simple">
<li><p>GRAPE - Default <code class="docutils literal notranslate"><span class="pre">optim_method</span></code> is FMIN_L_BFGS_B</p></li>
<li><p>CRAB - Default <code class="docutils literal notranslate"><span class="pre">optim_method</span></code> is FMIN</p></li>
</ul>
</dd>
<dt><strong>method_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <code class="docutils literal notranslate"><span class="pre">optim_method</span></code>.  Note that where there is an
attribute of the <a class="reference internal" href="classes.html#qutip.control.optimizer.Optimizer" title="qutip.control.optimizer.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a> object or
the <code class="docutils literal notranslate"><span class="pre">termination_conditions</span></code> matching the key that attribute.
Otherwise, and in some case also, they are assumed to be
method_options for the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> method.</p>
</dd>
<dt><strong>optim_alg</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">optim_method</span></code>.</p>
</dd>
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">method_params</span></code> instead.</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">method_params</span></code> instead.</p>
</dd>
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><p>Determines how global phase is treated in fidelity calculations
(<code class="docutils literal notranslate"><span class="pre">fid_type='UNIT'</span></code> only). Options:</p>
<ul class="simple">
<li><p>PSU - global phase ignored</p></li>
<li><p>SU - global phase included</p></li>
</ul>
</dd>
<dt><strong>dyn_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.dynamics.Dynamics" title="qutip.control.dynamics.Dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dynamics</span></code></a> object.
The key value pairs are assumed to be attribute name value pairs.
They applied after the object is created.</p>
</dd>
<dt><strong>prop_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>fid_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.fidcomp.FidelityComputer" title="qutip.control.fidcomp.FidelityComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FidelityComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>tslot_type</strong><span class="classifier">string</span></dt><dd><p>Method for computing the dynamics generators, propagators and evolution
in the timeslots.  Options: <code class="docutils literal notranslate"><span class="pre">DEF</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE_ALL</span></code>, <code class="docutils literal notranslate"><span class="pre">DYNAMIC</span></code>.
<code class="docutils literal notranslate"><span class="pre">UPDATE_ALL</span></code> is the only one that currently works.  (See
<a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a> classes for details.)</p>
</dd>
<dt><strong>tslot_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the <a class="reference internal" href="classes.html#qutip.control.tslotcomp.TimeslotComputer" title="qutip.control.tslotcomp.TimeslotComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TimeslotComputer</span></code></a>
object. The key value pairs are assumed to be attribute name value
pairs.  They applied after the object is created.</p>
</dd>
<dt><strong>amp_update_mode</strong><span class="classifier">string</span></dt><dd><p>Deprecated. Use <code class="docutils literal notranslate"><span class="pre">tslot_type</span></code> instead.</p>
</dd>
<dt><strong>init_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type / shape of pulse(s) used to initialise the control amplitudes.
Options (GRAPE) include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW.
DEF is RND.  (see <a class="reference internal" href="classes.html#qutip.control.pulsegen.PulseGen" title="qutip.control.pulsegen.PulseGen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PulseGen</span></code></a> classes for
details.) For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the initial / guess pulse generator object.  The key
value pairs are assumed to be attribute name value pairs.  They applied
after the object is created.</p>
</dd>
<dt><strong>pulse_scaling</strong><span class="classifier">float</span></dt><dd><p>Linear scale factor for generated initial / guess pulses.  By default
initial pulses are generated with amplitudes in the range (-1.0, 1.0).
These will be scaled by this parameter.</p>
</dd>
<dt><strong>pulse_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset for the pulse. That is this value will be added to any
initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong><span class="classifier">string</span></dt><dd><p>Type of pulse used to modulate the control pulse.  It’s intended use
for a ramping modulation, which is often required in experimental
setups.  This is only currently implemented in CRAB.  GAUSSIAN_EDGE was
added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong><span class="classifier">dict</span></dt><dd><p>Parameters for the ramping pulse generator object.  The key value pairs
are assumed to be attribute name value pairs.  They applied after the
object is created.</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>Level of messaging output from the logger.  Options are attributes of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.logging_utils</span></code> in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution, assuming
everything runs as expected.  The default NOTSET implies that the level
will be taken from the QuTiP settings file, which by default is WARN.</p>
</dd>
<dt><strong>out_file_ext</strong><span class="classifier">string or None</span></dt><dd><p>Files containing the initial and final control pulse amplitudes are
saved to the current directory.  The default name will be postfixed
with this extension.  Setting this to <code class="docutils literal notranslate"><span class="pre">None</span></code> will suppress the output
of files.</p>
</dd>
<dt><strong>gen_stats</strong><span class="classifier">boolean</span></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code> then statistics for the optimisation run will be
generated - accessible through attributes of the stats object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opt</strong><span class="classifier">OptimResult</span></dt><dd><p>Returns instance of <a class="reference internal" href="classes.html#qutip.control.optimresult.OptimResult" title="qutip.control.optimresult.OptimResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimResult</span></code></a>,
which has attributes giving the reason for termination, final fidelity
error, final evolution final amplitudes, statistics etc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
<dl class="py function">
<dt id="qutip.control.pulsegen.create_pulse_gen">
<code class="sig-name descname"><span class="pre">create_pulse_gen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RND'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#create_pulse_gen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.create_pulse_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a pulse generator object matching the given type.
The pulse generators each produce a different type of pulse,
see the gen_pulse function description for details.
These are the random pulse options:</p>
<blockquote>
<div><p>RND - Independent random value in each timeslot
RNDFOURIER - Fourier series with random coefficients
RNDWAVES - Summation of random waves
RNDWALK1 - Random change in amplitude each timeslot
RNDWALK2 - Random change in amp gradient each timeslot</p>
</div></blockquote>
<p>These are the other non-periodic options:</p>
<blockquote>
<div><p>LIN - Linear, i.e. contant gradient over the time
ZERO - special case of the LIN pulse, where the gradient is 0</p>
</div></blockquote>
<p>These are the periodic options</p>
<blockquote>
<div><p>SINE - Sine wave
SQUARE - Square wave
SAW - Saw tooth wave
TRIANGLE - Triangular wave</p>
</div></blockquote>
<p>If a Dynamics object is passed in then this is used in instantiate
the PulseGen, meaning that some timeslot and amplitude properties
are copied over.</p>
</dd></dl>

</div>
<div class="section" id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.graph">
<span id="graph-theory-routines"></span><span id="functions-graph"></span><h3>Graph Theory Routines<a class="headerlink" href="#module-qutip.graph" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="py function">
<dt id="qutip.graph.breadth_first_search">
<code class="sig-name descname"><span class="pre">breadth_first_search</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/graph.html#breadth_first_search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.  Use A+trans(A)
if original matrix is not symmetric or not sure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix, csr_matrix</span></dt><dd><p>Input graph in CSC or CSR matrix format</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Staring node for BFS traversal.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">array</span></dt><dd><p>Order in which nodes are traversed from starting node.</p>
</dd>
<dt><strong>levels</strong><span class="classifier">array</span></dt><dd><p>Level of the nodes in the order that they are traversed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.graph.graph_degree">
<code class="sig-name descname"><span class="pre">graph_degree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/graph.html#graph_degree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR
or CSC format, or a qobj.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj, csr_matrix, csc_matrix</span></dt><dd><p>Input quantum object or csr_matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>degree</strong><span class="classifier">array</span></dt><dd><p>Array of integers giving the degree for each node (row).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.graph.maximum_bipartite_matching">
<code class="sig-name descname"><span class="pre">maximum_bipartite_matching</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'row'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/graph.html#maximum_bipartite_matching"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.graph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row or column permutations that removes nonzero
elements from the diagonal of a nonsingular square CSC sparse matrix. Such
a permutation is always possible provided that the matrix is nonsingular.
This function looks at the structure of the matrix only.</p>
<p>The input matrix will be converted to CSC matrix format if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">sparse matrix</span></dt><dd><p>Input matrix</p>
</dd>
<dt><strong>perm_type</strong><span class="classifier">str {‘row’, ‘column’}</span></dt><dd><p>Type of permutation to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of row or column permutations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function relies on a maximum cardinality bipartite matching algorithm
based on a breadth-first search (BFS) of the underlying graph[1]_.</p>
<p class="rubric">References</p>
<p>I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and
Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.
38, no. 2, (2011).</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.graph.reverse_cuthill_mckee">
<code class="sig-name descname"><span class="pre">reverse_cuthill_mckee</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/graph.html#reverse_cuthill_mckee"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.graph.reverse_cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation array that orders a sparse CSR or CSC matrix in
Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,
this routine works on the matrix A+Trans(A) if the sym flag is set to False
(Default).</p>
<p>It is assumed by default (<em>sym=False</em>) that the input matrix is not
symmetric. This is because it is faster to do A+Trans(A) than it is to
check for symmetry for a generic matrix. If you are guaranteed that the
matrix is symmetric in structure (values of matrix element do not matter)
then set <em>sym=True</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix, csr_matrix</span></dt><dd><p>Input sparse CSC or CSR sparse matrix format.</p>
</dd>
<dt><strong>sym</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Flag to set whether input matrix is symmetric.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of permuted row and column indices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This routine is used primarily for internal reordering of Lindblad
superoperators for use in iterative solver routines.</p>
<p class="rubric">References</p>
<p>E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric
Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,
(1969).</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.graph.weighted_bipartite_matching">
<code class="sig-name descname"><span class="pre">weighted_bipartite_matching</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'row'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/graph.html#weighted_bipartite_matching"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.graph.weighted_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row permutations that attempts to maximize the product
of the ABS values of the diagonal elements in a nonsingular square CSC
sparse matrix. Such a permutation is always possible provided that the
matrix is nonsingular.</p>
<p>This function looks at both the structure and ABS values of the underlying
matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">csc_matrix</span></dt><dd><p>Input matrix</p>
</dd>
<dt><strong>perm_type</strong><span class="classifier">str {‘row’, ‘column’}</span></dt><dd><p>Type of permutation to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array</span></dt><dd><p>Array of row or column permutations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses a weighted maximum cardinality bipartite matching
algorithm based on breadth-first search (BFS).  The columns are weighted
according to the element of max ABS value in the associated rows and are
traversed in descending order by weight.  When performing the BFS
traversal, the row associated to a given column is the one with maximum
weight. Unlike other techniques[1]_, this algorithm does not guarantee the
product of the diagonal is maximized.  However, this limitation is offset
by the substantially faster runtime of this method.</p>
<p class="rubric">References</p>
<p>I. S. Duff and J. Koster, “The design and use of algorithms for permuting
large entries to the diagonal of sparse matrices”, SIAM J.  Matrix Anal.
and Applics. 20, no. 4, 889 (1997).</p>
</dd></dl>

</div>
<div class="section" id="functions-utilities">
<span id="id25"></span><h3>Utility Functions<a class="headerlink" href="#functions-utilities" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.utilities"></span><p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="py function">
<dt id="qutip.utilities.clebsch">
<code class="sig-name descname"><span class="pre">clebsch</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#clebsch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j1</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 1.</p>
</dd>
<dt><strong>j2</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 2.</p>
</dd>
<dt><strong>j3</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 3.</p>
</dd>
<dt><strong>m1</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 1.</p>
</dd>
<dt><strong>m2</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 2.</p>
</dd>
<dt><strong>m3</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cg_coeff</strong><span class="classifier">float</span></dt><dd><p>Requested Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.utilities.convert_unit">
<code class="sig-name descname"><span class="pre">convert_unit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'meV'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GHz'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#convert_unit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the old unit.</p>
</dd>
<dt><strong>orig</strong><span class="classifier">string</span></dt><dd><p>The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
<dt><strong>to</strong><span class="classifier">string</span></dt><dd><p>The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>value_new_unit</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the new unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.utilities.n_thermal">
<code class="sig-name descname"><span class="pre">n_thermal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#n_thermal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency ‘w’, at the temperature described by
‘w_th’ where <span class="math notranslate nohighlight">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Frequency of the oscillator.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier"><em>float</em></span></dt><dd><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>n_avg</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.fileio.file_data_read">
<code class="sig-name descname"><span class="pre">file_data_read</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#file_data_read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of file containing reqested data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Seperator used to store data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Data from selected file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.fileio.file_data_store">
<code class="sig-name descname"><span class="pre">file_data_store</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'complex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'decimal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#file_data_store"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of data file to be stored, including extension.</p>
</dd>
<dt><strong>data: array_like</strong></dt><dd><p>Data to be written to file.</p>
</dd>
<dt><strong>numtype</strong><span class="classifier">str {‘complex, ‘real’}</span></dt><dd><p>Type of numerical data.</p>
</dd>
<dt><strong>numformat</strong><span class="classifier">str {‘decimal’,’exp’}</span></dt><dd><p>Format for written data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.fileio.qload">
<code class="sig-name descname"><span class="pre">qload</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#qload"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of data file to be loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qobject</strong><span class="classifier">instance / array_like</span></dt><dd><p>Object retrieved from requested file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.fileio.qsave">
<code class="sig-name descname"><span class="pre">qsave</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qutip_data'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#qsave"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">instance/array_like</span></dt><dd><p>Input Python object to be stored.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of output data file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.parallel" title="Permalink to this headline">¶</a></h3>
<p>This function provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing.</p>
<dl class="py function">
<dt id="qutip.parallel.parallel_map">
<code class="sig-name descname"><span class="pre">parallel_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/parallel.html#parallel_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.parallel.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">ProgressBar</span></dt><dd><p>Progress bar class instance for showing progress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for
each value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.parallel.parfor">
<code class="sig-name descname"><span class="pre">parfor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/parallel.html#parfor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.parallel.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>From QuTiP 3.1, we recommend to use <a class="reference internal" href="#qutip.parallel.parallel_map" title="qutip.parallel.parallel_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel.parallel_map</span></code></a>
instead of this function.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function_type</span></dt><dd><p>A function to run in parallel on the local machine. The function ‘func’
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</dd>
<dt><strong>The following keyword argument is reserved:</strong></dt><dd></dd>
<dt><strong>num_cpus</strong><span class="classifier">int</span></dt><dd><p>Number of CPU’s to use.  Default uses maximum number of CPU’s.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.parallel.serial_map">
<code class="sig-name descname"><span class="pre">serial_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/parallel.html#serial_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.parallel.serial_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>This function work as a drop-in replacement of
<a class="reference internal" href="#qutip.parallel.parallel_map" title="qutip.parallel.parallel_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel.parallel_map</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">ProgressBar</span></dt><dd><p>Progress bar class instance for showing progress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip.semidefinite">
<span id="semidefinite-programming"></span><span id="functions-ipython"></span><h3>Semidefinite Programming<a class="headerlink" href="#module-qutip.semidefinite" title="Permalink to this headline">¶</a></h3>
<p>This module implements internal-use functions for semidefinite programming.</p>
</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-semidefinite"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="py function">
<dt id="qutip.ipynbtools.parallel_map">
<code class="sig-name descname"><span class="pre">parallel_map</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scheduling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">task</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">values</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task: a Python function</strong></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values: array / list</strong></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args: list / dictionary</strong></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs: list / dictionary</strong></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt><dd><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt><dd><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt><dd><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt><dd><p>Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.ipynbtools.parfor">
<code class="sig-name descname"><span class="pre">parfor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scheduling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progressbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/ipynbtools.html#parfor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">tast</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> or <code class="docutils literal notranslate"><span class="pre">task(value)</span></code> if <code class="docutils literal notranslate"><span class="pre">args=None</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task: a Python function</strong></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>task_vec: array / list</strong></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>args: list / dictionary</strong></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function. For example
a dictionary with parameter values.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt><dd><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt><dd><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt><dd><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt><dd><p>Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of <code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>, that is, it should be equivalent to
<code class="docutils literal notranslate"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="qutip.ipynbtools.version_table">
<code class="sig-name descname"><span class="pre">version_table</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>version_table: string</dt><dd><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="qutip.about">
<code class="sig-name descname"><span class="pre">about</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/about.html#about"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,
and MatPlotLib.</p>
</dd></dl>

<dl class="py function">
<dt id="qutip.simdiag">
<code class="sig-name descname"><span class="pre">simdiag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1e-14</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_mode</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/simdiag.html#simdiag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simultaneous diagonalization of commuting Hermitian matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ops</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of qobjs representing commuting Hermitian
operators.</p>
</dd>
<dt><strong>evals</strong><span class="classifier">bool [True]</span></dt><dd><p>Whether to return the eigenvalues for each ops and eigenvectors or just
the eigenvectors.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float [1e-14]</span></dt><dd><p>Tolerance for detecting degenerate eigenstates.</p>
</dd>
<dt><strong>safe_mode</strong><span class="classifier">bool [True]</span></dt><dd><p>Whether to check that all ops are Hermitian and commuting. If set to
<code class="docutils literal notranslate"><span class="pre">False</span></code> and operators are not commuting, the eigenvectors returned
will often be eigenvectors of only the first operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigs</strong><span class="classifier">tuple</span></dt><dd><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../changelog.html" class="btn btn-neutral float-right" title="Change Log" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="classes.html" class="btn btn-neutral float-left" title="Classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">
        Last updated on Jan 29, 2024.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>