
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qutip.solver.steadystate &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qutip.solver.steadystate</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qutip.solver.steadystate</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">liouvillian</span><span class="p">,</span> <span class="n">lindblad_dissipator</span><span class="p">,</span> <span class="n">Qobj</span><span class="p">,</span> <span class="n">qzero_like</span><span class="p">,</span> <span class="n">qeye_like</span>
<span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">vector_to_operator</span><span class="p">,</span> <span class="n">operator_to_vector</span>
<span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">import</span> <span class="nn">qutip.core.data</span> <span class="k">as</span> <span class="nn">_data</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.csgraph</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;steadystate&quot;</span><span class="p">,</span> <span class="s2">&quot;steadystate_floquet&quot;</span><span class="p">,</span> <span class="s2">&quot;pseudo_inverse&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_permute_wbm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">())</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_permute_rcm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">reverse_cuthill_mckee</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">())</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">perm</span>


<span class="k">def</span> <span class="nf">_reverse_rcm</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
    <span class="n">rev_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rev_perm</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho</span>


<div class="viewcode-block" id="steadystate"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.solver.steadystate.steadystate">[docs]</a><span class="k">def</span> <span class="nf">steadystate</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="p">[],</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the steady state for quantum evolution subject to the supplied</span>
<span class="sd">    Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of</span>
<span class="sd">    collapse operators.</span>

<span class="sd">    If the user passes a Hamiltonian then it, along with the list of collapse</span>
<span class="sd">    operators, will be converted into a Liouvillian operator in Lindblad form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : :obj:`~Qobj`</span>
<span class="sd">        A Hamiltonian or Liouvillian operator.</span>

<span class="sd">    c_op_list : list</span>
<span class="sd">        A list of collapse operators.</span>

<span class="sd">    method : str, default=&#39;direct&#39;</span>
<span class="sd">        The allowed methods are composed of 2 parts, the steadystate method:</span>
<span class="sd">        - &quot;direct&quot;: Solving ``L(rho_ss) = 0``</span>
<span class="sd">        - &quot;eigen&quot; : Eigenvalue problem</span>
<span class="sd">        - &quot;svd&quot; : Singular value decomposition</span>
<span class="sd">        - &quot;power&quot; : Inverse-power method</span>

<span class="sd">    solver : str, default=None</span>
<span class="sd">        &#39;direct&#39; and &#39;power&#39; methods only.</span>
<span class="sd">        Solver to use when solving the ``L(rho_ss) = 0`` equation.</span>
<span class="sd">        Default supported solver are:</span>

<span class="sd">        - &quot;solve&quot;, &quot;lstsq&quot;</span>
<span class="sd">          dense solver from numpy.linalg</span>
<span class="sd">        - &quot;spsolve&quot;, &quot;gmres&quot;, &quot;lgmres&quot;, &quot;bicgstab&quot;</span>
<span class="sd">          sparse solver from scipy.sparse.linalg</span>
<span class="sd">        - &quot;mkl_spsolve&quot;</span>
<span class="sd">          sparse solver by mkl.</span>

<span class="sd">        Extension to qutip, such as qutip-tensorflow, can use come with their</span>
<span class="sd">        own solver. When ``A`` and ``c_ops`` use these data backends, see the</span>
<span class="sd">        corresponding libraries ``linalg`` for available solver.</span>

<span class="sd">        Extra options for these solver can be passed in ``**kw``.</span>

<span class="sd">    use_rcm : bool, default False</span>
<span class="sd">        Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU</span>
<span class="sd">        factorization of the Liouvillian.</span>
<span class="sd">        Used with &#39;direct&#39; or &#39;power&#39; method.</span>

<span class="sd">    use_wbm : bool, default False</span>
<span class="sd">        Use Weighted Bipartite Matching reordering to make the Liouvillian</span>
<span class="sd">        diagonally dominant.  This is useful for iterative preconditioners</span>
<span class="sd">        only. Used with &#39;direct&#39; or &#39;power&#39; method.</span>

<span class="sd">    weight : float, optional</span>
<span class="sd">        Sets the size of the elements used for adding the unity trace condition</span>
<span class="sd">        to the linear solvers.  This is set to the average abs value of the</span>
<span class="sd">        Liouvillian elements if not specified by the user.</span>
<span class="sd">        Used with &#39;direct&#39; method.</span>

<span class="sd">    power_tol : float, default 1e-12</span>
<span class="sd">        Tolerance for the solution when using the &#39;power&#39; method.</span>

<span class="sd">    power_maxiter : int, default 10</span>
<span class="sd">        Maximum number of iteration to use when looking for a solution when</span>
<span class="sd">        using the &#39;power&#39; method.</span>

<span class="sd">    power_eps: double, default 1e-15</span>
<span class="sd">        Small weight used in the &quot;power&quot; method.</span>

<span class="sd">    sparse: bool</span>
<span class="sd">        Whether to use the sparse eigen solver with the &quot;eigen&quot; method</span>
<span class="sd">        (default sparse).  With &quot;direct&quot; and &quot;power&quot; method, when the solver is</span>
<span class="sd">        not specified, it is used to set whether &quot;solve&quot; or &quot;spsolve&quot; is</span>
<span class="sd">        used as default solver.</span>

<span class="sd">    **kwargs :</span>
<span class="sd">        Extra options to pass to the linear system solver. See the</span>
<span class="sd">        documentation of the used solver in ``numpy.linalg`` or</span>
<span class="sd">        ``scipy.sparse.linalg`` to see what extra arguments are supported.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dm : qobj</span>
<span class="sd">        Steady state density matrix.</span>
<span class="sd">    info : dict, optional</span>
<span class="sd">        Dictionary containing solver-specific information about the solution.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The SVD method works only for dense operators (i.e. small systems).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">issuper</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c_ops</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot calculate the steady state for a &#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;non-dissipative system.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">issuper</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">+=</span> <span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
        <span class="c1"># to support v4&#39;s &quot;power-gmres&quot; method</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;mkl&quot;</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;mkl_spsolve&quot;</span>

    <span class="c1"># Keys supported in v4, but removed in v5</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;return_info&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Steadystate no longer supports return_info&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;mtol&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;power_tol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;power_tol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mtol&quot;</span><span class="p">]</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mtol&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;eigen&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_steadystate_eigen</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;svd&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_steadystate_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># We want to be able to use this without having to know what data type the</span>
    <span class="c1"># liouvillian uses. For extra data types (tensorflow) we can expect</span>
    <span class="c1"># the users to know they are using them and choose an appropriate solver</span>
    <span class="n">sparse_solvers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spsolve&quot;</span><span class="p">,</span> <span class="s2">&quot;mkl_spsolve&quot;</span><span class="p">,</span> <span class="s2">&quot;gmres&quot;</span><span class="p">,</span> <span class="s2">&quot;lgmres&quot;</span><span class="p">,</span> <span class="s2">&quot;bicgstab&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">)):</span>
        <span class="c1"># Tensorflow, jax, etc. data type</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">)</span> <span class="ow">and</span> <span class="n">solver</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;solve&quot;</span><span class="p">,</span> <span class="s2">&quot;lstsq&quot;</span><span class="p">]:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">)</span> <span class="ow">and</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">sparse_solvers</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;mkl_spsolve&quot;</span> <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">has_mkl</span> <span class="k">else</span> <span class="s2">&quot;spsolve&quot;</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1"># sparse is explicitly set to false, v4 tag to use `numpy.linalg.solve`</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;solve&quot;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;direct&quot;</span><span class="p">,</span> <span class="s2">&quot;iterative&quot;</span><span class="p">]:</span>
        <span class="c1"># Remove unused kwargs, so only used and pass-through ones are included</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_tol&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_maxiter&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_eps&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_steadystate_direct</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                   <span class="n">method</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;power&quot;</span><span class="p">:</span>
        <span class="c1"># Remove unused kwargs, so only used and pass-through ones are included</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_steadystate_power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> not supported.&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_steadystate_direct</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># Find the weight, no good dispatched function available...</span>
    <span class="k">if</span> <span class="n">weight</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">):</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">full</span><span class="p">())</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A_np</span><span class="p">[</span><span class="n">A_np</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Add weight to the Liouvillian</span>
    <span class="c1"># A[:, 0] = vectorized(eye * weight)</span>
    <span class="c1"># We don&#39;t have a function to overwrite part of an array, so</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">weight_vec</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">weight</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="n">weight_mat</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span>
        <span class="n">weight_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">one_element</span><span class="p">[</span><span class="n">dtype</span><span class="p">]((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">weight_mat</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">one_element</span><span class="p">[</span><span class="n">dtype</span><span class="p">]((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">weight</span><span class="p">)</span>

    <span class="c1"># Permutation are part of scipy.sparse, thus only supported for CSR.</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_wbm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">):</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_permute_wbm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only CSR matrice can be permuted.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="n">use_rcm</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_rcm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">):</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">_permute_rcm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">use_rcm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only CSR matrice can be permuted.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_precond&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span><span class="p">)):</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_compute_precond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only sparse solver use preconditioners.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>


    <span class="n">method</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">steadystate</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_rcm</span><span class="p">:</span>
        <span class="n">steadystate</span> <span class="o">=</span> <span class="n">_reverse_rcm</span><span class="p">(</span><span class="n">steadystate</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

    <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">column_unstack</span><span class="p">(</span><span class="n">steadystate</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rho_ss</span><span class="p">,</span> <span class="n">rho_ss</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.5</span>

    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">rho_ss</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_steadystate_eigen</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">@</span> <span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">eigenstates</span><span class="p">(</span>
        <span class="n">eigvals</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">sort</span><span class="o">=</span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
        <span class="c1"># v4&#39;s implementation only uses sparse eigen solver</span>
        <span class="n">sparse</span><span class="o">=</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">vector_to_operator</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rho</span> <span class="o">/</span> <span class="n">rho</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_steadystate_svd</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">split_columns</span><span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">vector_to_operator</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho</span> <span class="o">/</span> <span class="n">rho</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_steadystate_power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">+=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_eps&quot;</span><span class="p">,</span> <span class="mf">1e-15</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Permutation are part of scipy.sparse, thus only supported for CSR.</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_wbm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">):</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_permute_wbm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only CSR matrice can be permuted.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="n">use_rcm</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_rcm&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">):</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">_permute_rcm</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">use_rcm</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only CSR matrice can be permuted.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_precond&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span><span class="p">)):</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_compute_precond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only sparse solver use preconditioners.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxiter</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_maxiter&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;power_tol&quot;</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="n">_data</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">L</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">_data</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">maxiter</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Failed to find steady state after &#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">maxiter</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; iterations&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_rcm</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_reverse_rcm</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

    <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">column_unstack</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">rho_ss</span> <span class="o">+</span> <span class="n">rho_ss</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">rho_ss</span> <span class="o">/</span> <span class="n">rho_ss</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
    <span class="n">rho_ss</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">rho_ss</span>


<div class="viewcode-block" id="steadystate_floquet"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.solver.steadystate.steadystate_floquet">[docs]</a><span class="k">def</span> <span class="nf">steadystate_floquet</span><span class="p">(</span><span class="n">H_0</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">Op_t</span><span class="p">,</span> <span class="n">w_d</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_it</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the effective steady state for a driven</span>
<span class="sd">     system with a time-dependent cosinusoidal term:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\mathcal{\\hat{H}}(t) = \\hat{H}_0 +</span>
<span class="sd">         \\mathcal{\\hat{O}} \\cos(\\omega_d t)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_0 : :obj:`~Qobj`</span>
<span class="sd">        A Hamiltonian or Liouvillian operator.</span>

<span class="sd">    c_ops : list</span>
<span class="sd">        A list of collapse operators.</span>

<span class="sd">    Op_t : :obj:`~Qobj`</span>
<span class="sd">        The the interaction operator which is multiplied by the cosine</span>

<span class="sd">    w_d : float, default 1.0</span>
<span class="sd">        The frequency of the drive</span>

<span class="sd">    n_it : int, default 3</span>
<span class="sd">        The number of iterations for the solver</span>

<span class="sd">    sparse : bool, default False</span>
<span class="sd">        Solve for the steady state using sparse algorithms.</span>

<span class="sd">    solver : str, default=None</span>
<span class="sd">        Solver to use when solving the linear system.</span>
<span class="sd">        Default supported solver are:</span>

<span class="sd">        - &quot;solve&quot;, &quot;lstsq&quot;</span>
<span class="sd">          dense solver from numpy.linalg</span>
<span class="sd">        - &quot;spsolve&quot;, &quot;gmres&quot;, &quot;lgmres&quot;, &quot;bicgstab&quot;</span>
<span class="sd">          sparse solver from scipy.sparse.linalg</span>
<span class="sd">        - &quot;mkl_spsolve&quot;</span>
<span class="sd">          sparse solver by mkl.</span>

<span class="sd">        Extensions to qutip, such as qutip-tensorflow, may provide their own solvers.</span>
<span class="sd">        When ``H_0`` and ``c_ops`` use these data backends, see their documentation</span>
<span class="sd">        for the names and details of additional solvers they may provide.</span>

<span class="sd">    **kwargs:</span>
<span class="sd">        Extra options to pass to the linear system solver. See the</span>
<span class="sd">        documentation of the used solver in ``numpy.linalg`` or</span>
<span class="sd">        ``scipy.sparse.linalg`` to see what extra arguments are supported.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dm : qobj</span>
<span class="sd">        Steady state density matrix.</span>

<span class="sd">    .. note::</span>

<span class="sd">        See: Sze Meng Tan,</span>
<span class="sd">        https://copilot.caltech.edu/documents/16743/qousersguide.pdf,</span>
<span class="sd">        Section (10.16)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">L_0</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">H_0</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">)</span>
    <span class="n">L_m</span> <span class="o">=</span> <span class="n">L_p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">Op_t</span><span class="p">)</span>
    <span class="c1"># L_p and L_m correspond to the positive and negative</span>
    <span class="c1"># frequency terms respectively.</span>
    <span class="c1"># They are independent in the model, so we keep both names.</span>
    <span class="n">Id</span> <span class="o">=</span> <span class="n">qeye_like</span><span class="p">(</span><span class="n">L_0</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">T</span> <span class="o">=</span> <span class="n">qzero_like</span><span class="p">(</span><span class="n">L_0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">H_0</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">L_0</span> <span class="o">=</span> <span class="n">L_0</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Dense&quot;</span><span class="p">)</span>
        <span class="n">L_m</span> <span class="o">=</span> <span class="n">L_m</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Dense&quot;</span><span class="p">)</span>
        <span class="n">L_p</span> <span class="o">=</span> <span class="n">L_p</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Dense&quot;</span><span class="p">)</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Dense&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n_i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_it</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L_0</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_i</span> <span class="o">*</span> <span class="n">w_d</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">L_m</span> <span class="o">@</span> <span class="n">S</span>
        <span class="n">S</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">-</span> <span class="n">_data</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">L_p</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L_0</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n_i</span> <span class="o">*</span> <span class="n">w_d</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">L_p</span> <span class="o">@</span> <span class="n">T</span>
        <span class="n">T</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">-</span> <span class="n">_data</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">L_m</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="n">M_subs</span> <span class="o">=</span> <span class="n">L_0</span> <span class="o">+</span> <span class="n">L_m</span> <span class="o">@</span> <span class="n">S</span> <span class="o">+</span> <span class="n">L_p</span> <span class="o">@</span> <span class="n">T</span>
    <span class="k">return</span> <span class="n">steadystate</span><span class="p">(</span><span class="n">M_subs</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="pseudo_inverse"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.solver.steadystate.pseudo_inverse">[docs]</a><span class="k">def</span> <span class="nf">pseudo_inverse</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rhoss</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;splu&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">use_rcm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pseudo inverse for a Liouvillian superoperator, optionally</span>
<span class="sd">    given its steady state density matrix (which will be computed if not</span>
<span class="sd">    given).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : Qobj</span>
<span class="sd">        A Liouvillian superoperator for which to compute the pseudo inverse.</span>

<span class="sd">    rhoss : Qobj</span>
<span class="sd">        A steadystate density matrix as Qobj instance, for the Liouvillian</span>
<span class="sd">        superoperator L.</span>

<span class="sd">    w : double</span>
<span class="sd">        frequency at which to evaluate pseudo-inverse.  Can be zero for dense</span>
<span class="sd">        systems and large sparse systems. Small sparse systems can fail for</span>
<span class="sd">        zero frequencies.</span>

<span class="sd">    sparse : bool</span>
<span class="sd">        Flag that indicate whether to use sparse or dense matrix methods when</span>
<span class="sd">        computing the pseudo inverse.</span>

<span class="sd">    method : string</span>
<span class="sd">        Method used to compte matrix inverse.</span>
<span class="sd">        Choice are &#39;pinv&#39; to use scipy&#39;s function of the same name, or a linear</span>
<span class="sd">        system solver.</span>
<span class="sd">        Default supported solver are:</span>

<span class="sd">        - &quot;solve&quot;, &quot;lstsq&quot;</span>
<span class="sd">          dense solver from numpy.linalg</span>
<span class="sd">        - &quot;spsolve&quot;, &quot;gmres&quot;, &quot;lgmres&quot;, &quot;bicgstab&quot;, &quot;splu&quot;</span>
<span class="sd">          sparse solver from scipy.sparse.linalg</span>
<span class="sd">        - &quot;mkl_spsolve&quot;,</span>
<span class="sd">          sparse solver by mkl.</span>

<span class="sd">        Extension to qutip, such as qutip-tensorflow, can use come with their</span>
<span class="sd">        own solver. When ``L`` use these data backends, see the corresponding</span>
<span class="sd">        libraries ``linalg`` for available solver.</span>

<span class="sd">    kwargs : dictionary</span>
<span class="sd">        Additional keyword arguments for setting parameters for solver methods.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : Qobj</span>
<span class="sd">        Returns a Qobj instance representing the pseudo inverse of L.</span>

<span class="sd">    .. note::</span>

<span class="sd">        In general the inverse of a sparse matrix will be dense.  If you</span>
<span class="sd">        are applying the inverse to a density matrix then it is better to</span>
<span class="sd">        cast the problem as an Ax=b type problem where the explicit calculation</span>
<span class="sd">        of the inverse is not required. See page 67 of &quot;Electrons in</span>
<span class="sd">        nanostructures&quot; C. Flindt, PhD Thesis available online:</span>
<span class="sd">        https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/</span>
<span class="sd">        file_4732600/content</span>

<span class="sd">        Note also that the definition of the pseudo-inverse herein is different</span>
<span class="sd">        from numpys pinv() alone, as it includes pre and post projection onto</span>
<span class="sd">        the subspace defined by the projector Q.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rhoss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rhoss</span> <span class="o">=</span> <span class="n">steadystate</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

    <span class="n">sparse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;direct&quot;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;splu&quot;</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="s2">&quot;pinv&quot;</span>
    <span class="n">sparse_solvers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;splu&quot;</span><span class="p">,</span> <span class="s2">&quot;mkl_spsolve&quot;</span><span class="p">,</span> <span class="s2">&quot;spilu&quot;</span><span class="p">]</span>
    <span class="n">dense_solvers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;solve&quot;</span><span class="p">,</span> <span class="s2">&quot;lstsq&quot;</span><span class="p">,</span> <span class="s2">&quot;pinv&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span><span class="p">))</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">dense_solvers</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;dense&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">sparse_solvers</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">rhoss_vec</span> <span class="o">=</span> <span class="n">operator_to_vector</span><span class="p">(</span><span class="n">rhoss</span><span class="p">)</span>

    <span class="n">tr_op</span> <span class="o">=</span> <span class="n">qeye_like</span><span class="p">(</span><span class="n">rhoss</span><span class="p">)</span>
    <span class="n">tr_op_vec</span> <span class="o">=</span> <span class="n">operator_to_vector</span><span class="p">(</span><span class="n">tr_op</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">rhoss_vec</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">tr_op_vec</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">identity_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]:</span>
        <span class="n">L</span> <span class="o">+=</span> <span class="mf">1e-15j</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span>

    <span class="n">use_rcm</span> <span class="o">=</span> <span class="n">use_rcm</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_rcm</span><span class="p">:</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">reverse_cuthill_mckee</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">())</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">data</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pinv&quot;</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">,</span> <span class="s2">&quot;scipy&quot;</span><span class="p">,</span> <span class="s2">&quot;scipy2&quot;</span><span class="p">]:</span>
        <span class="c1"># from scipy 1.7.0, they all use the same algorithm.</span>
        <span class="n">LI</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">to_array</span><span class="p">()),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">LIQ</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">LI</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;spilu&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span><span class="p">)):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;spilu&#39; method can only be used with sparse data.&quot;</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
        <span class="n">ILU</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">()</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">LIQ</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">ILU</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">to_array</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LIQ</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">LIQ</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_rcm</span><span class="p">:</span>
        <span class="n">rev_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">permute</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">rev_perm</span><span class="p">,</span> <span class="n">rev_perm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_compute_precond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">spilu_keys</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;permc_spec&#39;</span><span class="p">,</span>
        <span class="s1">&#39;drop_tol&#39;</span><span class="p">,</span>
        <span class="s1">&#39;diag_pivot_thresh&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fill_factor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;options&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">ss_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">spilu_keys</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">args</span>
    <span class="p">}</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">as_scipy</span><span class="p">()</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="o">**</span><span class="n">ss_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="n">P</span><span class="o">.</span><span class="n">solve</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Sep 07, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>