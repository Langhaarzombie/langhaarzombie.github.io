
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qutip.solver.result &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qutip.solver.result</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qutip.solver.result</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Class for solve function results&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">Qobj</span><span class="p">,</span> <span class="n">QobjEvo</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">isket</span><span class="p">,</span> <span class="n">ket2dm</span><span class="p">,</span> <span class="n">qzero</span><span class="p">,</span> <span class="n">qzero_like</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Result&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiTrajResult&quot;</span><span class="p">,</span> <span class="s2">&quot;McResult&quot;</span><span class="p">,</span> <span class="s2">&quot;NmmcResult&quot;</span><span class="p">,</span>
           <span class="s2">&quot;McTrajectoryResult&quot;</span><span class="p">,</span> <span class="s2">&quot;McResultImprovedSampling&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_QobjExpectEop</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pickable e_ops callable that calculates the expectation value for a given</span>
<span class="sd">    operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : :obj:`~Qobj`</span>
<span class="sd">        The expectation value operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExpectOp</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A result e_op (expectation operation).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : object</span>
<span class="sd">        The original object used to define the e_op operation, e.g. a</span>
<span class="sd">        :~obj:`Qobj` or a function ``f(t, state)``.</span>

<span class="sd">    f : function</span>
<span class="sd">        A callable ``f(t, state)`` that will return the value of the e_op</span>
<span class="sd">        for the specified state and time.</span>

<span class="sd">    append : function</span>
<span class="sd">        A callable ``append(value)``, e.g. ``expect[k].append``, that will</span>
<span class="sd">        store the result of the e_ops function ``f(t, state)``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    op : object</span>
<span class="sd">        The original object used to define the e_op operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">append</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append</span> <span class="o">=</span> <span class="n">append</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the expectation value for the given time, ``t`` and</span>
<span class="sd">        state, ``state``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the result of the e_op function. Should only be called by</span>
<span class="sd">        :class:`~Result`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_BaseResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Common method for all ``Result``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors_require_copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

    <span class="k">def</span> <span class="nf">_e_ops_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert the supplied e_ops to a dictionary of Eop instances. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e_ops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e_ops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">e_ops</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">e_op</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">e_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">)}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_ops</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">e_ops</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">e_ops</span>

    <span class="k">def</span> <span class="nf">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">requires_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a processor ``f`` to the list of state processors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : function, ``f(t, state)``</span>
<span class="sd">            A function to be called each time a state is added to this</span>
<span class="sd">            result object. The state is the state passed to ``.add``, after</span>
<span class="sd">            applying the pre-processors, if any.</span>

<span class="sd">        requires_copy : bool, default False</span>
<span class="sd">            Whether this processor requires a copy of the state rather than</span>
<span class="sd">            a reference. A processor must never modify the supplied state, but</span>
<span class="sd">            if a processor stores the state it should set ``require_copy`` to</span>
<span class="sd">            true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors_require_copy</span> <span class="o">|=</span> <span class="n">requires_copy</span>


<div class="viewcode-block" id="Result"><a class="viewcode-back" href="../../../apidoc/classes.html#qutip.solver.sesolve.Result">[docs]</a><span class="k">class</span> <span class="nc">Result</span><span class="p">(</span><span class="n">_BaseResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for storing solver results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e_ops : :obj:`~Qobj`, :obj:`~QobjEvo`, function or list or dict of these</span>
<span class="sd">        The ``e_ops`` parameter defines the set of values to record at</span>
<span class="sd">        each time step ``t``. If an element is a :obj:`~Qobj` or</span>
<span class="sd">        :obj:`~QobjEvo` the value recorded is the expectation value of that</span>
<span class="sd">        operator given the state at ``t``. If the element is a function, ``f``,</span>
<span class="sd">        the value recorded is ``f(t, state)``.</span>

<span class="sd">        The values are recorded in the ``e_data`` and ``expect`` attributes of</span>
<span class="sd">        this result object. ``e_data`` is a dictionary and ``expect`` is a</span>
<span class="sd">        list, where each item contains the values of the corresponding</span>
<span class="sd">        ``e_op``.</span>

<span class="sd">    options : dict</span>
<span class="sd">        The options for this result class.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict or None</span>
<span class="sd">        The stats generated by the solver while producing these results. Note</span>
<span class="sd">        that the solver may update the stats directly while producing results.</span>

<span class="sd">    kw : dict</span>
<span class="sd">        Additional parameters specific to a result sub-class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    times : list</span>
<span class="sd">        A list of the times at which the expectation values and states were</span>
<span class="sd">        recorded.</span>

<span class="sd">    states : list of :obj:`~Qobj`</span>
<span class="sd">        The state at each time ``t`` (if the recording of the state was</span>
<span class="sd">        requested).</span>

<span class="sd">    final_state : :obj:`~Qobj`:</span>
<span class="sd">        The final state (if the recording of the final state was requested).</span>

<span class="sd">    expect : list of arrays of expectation values</span>
<span class="sd">        A list containing the values of each ``e_op``. The list is in</span>
<span class="sd">        the same order in which the ``e_ops`` were supplied and empty if</span>
<span class="sd">        no ``e_ops`` were given.</span>

<span class="sd">        Each element is itself a list and contains the values of the</span>
<span class="sd">        corresponding ``e_op``, with one value for each time in ``.times``.</span>

<span class="sd">        The same lists of values may be accessed via the ``.e_data`` dictionary</span>
<span class="sd">        and the original ``e_ops`` are available via the ``.e_ops`` attribute.</span>

<span class="sd">    e_data : dict</span>
<span class="sd">        A dictionary containing the values of each ``e_op``. If the ``e_ops``</span>
<span class="sd">        were supplied as a dictionary, the keys are the same as in</span>
<span class="sd">        that dictionary. Otherwise the keys are the index of the ``e_op``</span>
<span class="sd">        in the ``.expect`` list.</span>

<span class="sd">        The lists of expectation values returned are the *same* lists as</span>
<span class="sd">        those returned by ``.expect``.</span>

<span class="sd">    e_ops : dict</span>
<span class="sd">        A dictionary containing the supplied e_ops as ``ExpectOp`` instances.</span>
<span class="sd">        The keys of the dictionary are the same as for ``.e_data``.</span>
<span class="sd">        Each value is object where ``.e_ops[k](t, state)`` calculates the</span>
<span class="sd">        value of ``e_op`` ``k`` at time ``t`` and the given ``state``, and</span>
<span class="sd">        ``.e_ops[k].op`` is the original object supplied to create the</span>
<span class="sd">        ``e_op``.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict or None</span>
<span class="sd">        The stats generated by the solver while producing these results.</span>

<span class="sd">    options : dict</span>
<span class="sd">        The options for this result class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="n">stats</span><span class="p">)</span>
        <span class="n">raw_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_e_ops_to_dict</span><span class="p">(</span><span class="n">e_ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">raw_ops</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">raw_ops</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_e_op_func</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExpectOp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_post_init</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_e_op_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_op</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an e_op entry into a function, ``f(t, state)`` that returns</span>
<span class="sd">        the appropriate value (usually an expectation value).</span>

<span class="sd">        Sub-classes may override this function to calculate expectation values</span>
<span class="sd">        in different ways.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_op</span><span class="p">,</span> <span class="n">Qobj</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_QobjExpectEop</span><span class="p">(</span><span class="n">e_op</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_op</span><span class="p">,</span> <span class="n">QobjEvo</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">e_op</span><span class="o">.</span><span class="n">expect</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">e_op</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">e_op</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e_op</span><span class="si">!r}</span><span class="s2"> has unsupported type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e_op</span><span class="p">)</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform post __init__ initialisation. In particular, add state</span>
<span class="sd">        processors or pre-processors.</span>

<span class="sd">        Sub-class may override this. If the sub-class wishes to register the</span>
<span class="sd">        default processors for storing states, it should call this parent</span>
<span class="sd">        ``.post_init()`` method.</span>

<span class="sd">        Sub-class ``.post_init()`` implementation may take additional keyword</span>
<span class="sd">        arguments if required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">store_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;store_states&#39;</span><span class="p">]</span>
        <span class="n">store_final_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;store_final_state&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">store_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">store_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store_state</span><span class="p">,</span> <span class="n">requires_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">store_states</span> <span class="ow">or</span> <span class="n">store_final_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store_final_state</span><span class="p">,</span> <span class="n">requires_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Processor that stores a state in ``.states``. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_store_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Processor that writes the state to ``.final_state``. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_pre_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a copy of the state. Sub-classes may override this to</span>
<span class="sd">            copy a state in different manner or to skip making a copy</span>
<span class="sd">            altogether if a copy is not necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Result.add"><a class="viewcode-back" href="../../../apidoc/classes.html#qutip.solver.sesolve.Result.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a state to the results for the time ``t`` of the evolution.</span>

<span class="sd">        Adding a state calculates the expectation value of the state for</span>
<span class="sd">        each of the supplied ``e_ops`` and stores the result in ``.expect``.</span>

<span class="sd">        The state is recorded in ``.states`` and ``.final_state`` if specified</span>
<span class="sd">        by the supplied result options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            The time of the added state.</span>

<span class="sd">        state : typically a :obj:`~Qobj`</span>
<span class="sd">            The state a time ``t``. Usually this is a :obj:`~Qobj` with</span>
<span class="sd">            suitable dimensions, but it sub-classes of result might support</span>
<span class="sd">            other forms of the state.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The expectation values, i.e. ``e_ops``, and states are recorded by</span>
<span class="sd">           the state processors (see ``.add_processor``).</span>

<span class="sd">           Additional processors may be added by sub-classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors_require_copy</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_copy</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors</span><span class="p">:</span>
            <span class="n">op</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;  Solver: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Solver stats:&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;  Time interval: [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span><span class="si">}</span><span class="s2"> steps)&quot;</span>
            <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of e_ops: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  States saved.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Final state saved.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  State not saved.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">e_op</span><span class="p">)</span> <span class="k">for</span> <span class="n">e_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>


<span class="k">class</span> <span class="nc">MultiTrajResult</span><span class="p">(</span><span class="n">_BaseResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for storing results for solver using multiple trajectories.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e_ops : :obj:`~Qobj`, :obj:`~QobjEvo`, function or list or dict of these</span>
<span class="sd">        The ``e_ops`` parameter defines the set of values to record at</span>
<span class="sd">        each time step ``t``. If an element is a :obj:`~Qobj` or</span>
<span class="sd">        :obj:`~QobjEvo` the value recorded is the expectation value of that</span>
<span class="sd">        operator given the state at ``t``. If the element is a function, ``f``,</span>
<span class="sd">        the value recorded is ``f(t, state)``.</span>

<span class="sd">        The values are recorded in the ``.expect`` attribute of this result</span>
<span class="sd">        object. ``.expect`` is a list, where each item contains the values</span>
<span class="sd">        of the corresponding ``e_op``.</span>

<span class="sd">        Function ``e_ops`` must return a number so the average can be computed.</span>

<span class="sd">    options : dict</span>
<span class="sd">        The options for this result class.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict or None</span>
<span class="sd">        The stats generated by the solver while producing these results. Note</span>
<span class="sd">        that the solver may update the stats directly while producing results.</span>

<span class="sd">    kw : dict</span>
<span class="sd">        Additional parameters specific to a result sub-class.</span>

<span class="sd">    Properties</span>
<span class="sd">    ----------</span>
<span class="sd">    times : list</span>
<span class="sd">        A list of the times at which the expectation values and states were</span>
<span class="sd">        recorded.</span>

<span class="sd">    average_states : list of :obj:`~Qobj`</span>
<span class="sd">        The state at each time ``t`` (if the recording of the state was</span>
<span class="sd">        requested) averaged over all trajectories as a density matrix.</span>

<span class="sd">    runs_states : list of list of :obj:`~Qobj`</span>
<span class="sd">        The state for each trajectory and each time ``t`` (if the recording of</span>
<span class="sd">        the states and trajectories was requested)</span>

<span class="sd">    final_state : :obj:`~Qobj:</span>
<span class="sd">        The final state (if the recording of the final state was requested)</span>
<span class="sd">        averaged over all trajectories as a density matrix.</span>

<span class="sd">    runs_final_state : list of :obj:`~Qobj`</span>
<span class="sd">        The final state for each trajectory (if the recording of the final</span>
<span class="sd">        state and trajectories was requested).</span>

<span class="sd">    average_expect : list of array of expectation values</span>
<span class="sd">        A list containing the values of each ``e_op`` averaged over each</span>
<span class="sd">        trajectories. The list is in the same order in which the ``e_ops`` were</span>
<span class="sd">        supplied and empty if no ``e_ops`` were given.</span>

<span class="sd">        Each element is itself an array and contains the values of the</span>
<span class="sd">        corresponding ``e_op``, with one value for each time in ``.times``.</span>

<span class="sd">    std_expect : list of array of expectation values</span>
<span class="sd">        A list containing the standard derivation of each ``e_op`` over each</span>
<span class="sd">        trajectories. The list is in the same order in which the ``e_ops`` were</span>
<span class="sd">        supplied and empty if no ``e_ops`` were given.</span>

<span class="sd">        Each element is itself an array and contains the values of the</span>
<span class="sd">        corresponding ``e_op``, with one value for each time in ``.times``.</span>

<span class="sd">    runs_expect : list of array of expectation values</span>
<span class="sd">        A list containing the values of each ``e_op`` for each trajectories.</span>
<span class="sd">        The list is in the same order in which the ``e_ops`` were</span>
<span class="sd">        supplied and empty if no ``e_ops`` were given. Only available if the</span>
<span class="sd">        storing of trajectories was requested.</span>

<span class="sd">        The order of the elements is ``runs_expect[e_ops][trajectory][time]``.</span>

<span class="sd">        Each element is itself an array and contains the values of the</span>
<span class="sd">        corresponding ``e_op``, with one value for each time in ``.times``.</span>

<span class="sd">    average_e_data : dict</span>
<span class="sd">        A dictionary containing the values of each ``e_op`` averaged over each</span>
<span class="sd">        trajectories. If the ``e_ops`` were supplied as a dictionary, the keys</span>
<span class="sd">        are the same as in that dictionary. Otherwise the keys are the index of</span>
<span class="sd">        the ``e_op`` in the ``.expect`` list.</span>

<span class="sd">        The lists of expectation values returned are the *same* lists as</span>
<span class="sd">        those returned by ``.expect``.</span>

<span class="sd">    average_e_data : dict</span>
<span class="sd">        A dictionary containing the standard derivation of each ``e_op`` over</span>
<span class="sd">        each trajectories. If the ``e_ops`` were supplied as a dictionary, the</span>
<span class="sd">        keys are the same as in that dictionary. Otherwise the keys are the</span>
<span class="sd">        index of the ``e_op`` in the ``.expect`` list.</span>

<span class="sd">        The lists of expectation values returned are the *same* lists as</span>
<span class="sd">        those returned by ``.expect``.</span>

<span class="sd">    runs_e_data : dict</span>
<span class="sd">        A dictionary containing the values of each ``e_op`` for each</span>
<span class="sd">        trajectories. If the ``e_ops`` were supplied as a dictionary, the keys</span>
<span class="sd">        are the same as in that dictionary. Otherwise the keys are the index of</span>
<span class="sd">        the ``e_op`` in the ``.expect`` list. Only available if the storing</span>
<span class="sd">        of trajectories was requested.</span>

<span class="sd">        The order of the elements is ``runs_expect[e_ops][trajectory][time]``.</span>

<span class="sd">        The lists of expectation values returned are the *same* lists as</span>
<span class="sd">        those returned by ``.expect``.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict or None</span>
<span class="sd">        The stats generated by the solver while producing these results.</span>

<span class="sd">    options : :obj:`~SolverResultsOptions`</span>
<span class="sd">        The options for this result class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="n">stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_e_ops_to_dict</span><span class="p">(</span><span class="n">e_ops</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_tols</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_e_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_post_init</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;ket&#39;</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">proj</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_add_first_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the first trajectory, intitializing needed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">times</span>

        <span class="k">if</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">=</span> <span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">e_ops</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">avg_expect</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">avg_expect</span>
            <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;keep_runs_results&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span>

    <span class="k">def</span> <span class="nf">_store_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">accu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">accu</span><span class="p">,</span> <span class="n">state</span>
            <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span><span class="p">,</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_reduce_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the average of the expectation values and store it in it&#39;s</span>
<span class="sd">        multiple formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">):</span>
            <span class="n">expect_traj</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span><span class="o">**</span><span class="mi">2</span>

            <span class="n">avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
            <span class="n">avg2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>

            <span class="c1"># mean(expect**2) - mean(expect)**2 can something be very small</span>
            <span class="c1"># negative (-1e-15) which raise an error for float sqrt.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_increment_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_first_traj</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_no_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remaining number of trajectories needed to finish cannot be determined</span>
<span class="sd">        by this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">def</span> <span class="nf">_fixed_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finish at a known number of trajectories.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ntraj_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_ntraj</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
        <span class="k">if</span> <span class="n">ntraj_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;end_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ntraj reached&#39;</span>
        <span class="k">return</span> <span class="n">ntraj_left</span>

    <span class="k">def</span> <span class="nf">_average_computer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
        <span class="n">avg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">avg2</span>

    <span class="k">def</span> <span class="nf">_target_tolerance_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the error on the expectation values using jackknife resampling.</span>
<span class="sd">        Return the approximate number of trajectories needed to have this</span>
<span class="sd">        error within the tolerance fot all e_ops and times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">avg</span><span class="p">,</span> <span class="n">avg2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_computer</span><span class="p">()</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">mean</span>
            <span class="k">for</span> <span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)</span>
            <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_tols</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">target_ntraj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">avg2</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">target</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_estimated_ntraj</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">target_ntraj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_ntraj</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_estimated_ntraj</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;end_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;target tolerance reached&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimated_ntraj</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>

    <span class="k">def</span> <span class="nf">_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_ntraj</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">store_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;store_states&#39;</span><span class="p">]</span>
        <span class="n">store_final_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;store_final_state&#39;</span><span class="p">]</span>
        <span class="n">store_traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;keep_runs_results&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_increment_traj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store_traj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store_trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">store_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reduce_states</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store_states</span> <span class="ow">or</span> <span class="n">store_final_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reduce_final_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reduce_expect</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_early_finish_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;end_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory_info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a trajectory to the evolution.</span>

<span class="sd">        Trajectories can be saved or average canbe extracted depending on the</span>
<span class="sd">        options ``keep_runs_results``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trajectory_info : tuple of seed and trajectory</span>
<span class="sd">            - seed: int, SeedSequence</span>
<span class="sd">              Seed used to generate the trajectory.</span>
<span class="sd">            - trajectory : :class:`Result`</span>
<span class="sd">              Run result for one evolution over the times.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        remaing_traj : number</span>
<span class="sd">            Return the number of trajectories still needed to reach the target</span>
<span class="sd">            tolerance. If no tolerance is provided, return infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seed</span><span class="p">,</span> <span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_processors</span><span class="p">:</span>
            <span class="n">op</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_early_finish_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_end_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">,</span> <span class="n">target_tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the condition to stop the computing trajectories when the certain</span>
<span class="sd">        condition are fullfilled.</span>
<span class="sd">        Supported end condition for multi trajectories computation are:</span>
<span class="sd">        - Reaching a number of trajectories.</span>
<span class="sd">        - Error bar on the expectation values reach smaller than a given</span>
<span class="sd">          tolerance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ntraj : int</span>
<span class="sd">            Number of trajectories expected.</span>

<span class="sd">        target_tol : float, array_like, [optional]</span>
<span class="sd">            Target tolerance of the evolution. The evolution will compute</span>
<span class="sd">            trajectories until the error on the expectation values is lower</span>
<span class="sd">            than this tolerance. The error is computed using jackknife</span>
<span class="sd">            resampling. ``target_tol`` can be an absolute tolerance, a pair of</span>
<span class="sd">            absolute and relative tolerance, in that order. Lastly, it can be a</span>
<span class="sd">            list of pairs of (atol, rtol) for each e_ops.</span>

<span class="sd">            Error estimation is done with jackknife resampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_ntraj</span> <span class="o">=</span> <span class="n">ntraj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;end_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;timeout&#39;</span>

        <span class="k">if</span> <span class="n">target_tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_early_finish_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_end</span>
            <span class="k">return</span>

        <span class="n">num_e_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">num_e_ops</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot target a tolerance without e_ops&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_estimated_ntraj</span> <span class="o">=</span> <span class="n">ntraj</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">targets</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_tols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">target_tol</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)]</span> <span class="o">*</span> <span class="n">num_e_ops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">targets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_tols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_e_ops</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">targets</span>
        <span class="k">elif</span> <span class="n">targets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_e_ops</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_tols</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;target_tol must be a number, a pair of (atol, &quot;</span>
                             <span class="s2">&quot;rtol) or a list of (atol, rtol) for each e_ops&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_early_finish_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_tolerance_end</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        States of every runs as ``states[run][t]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">states</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        States averages as density matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">final</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="k">for</span> <span class="n">final</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs final states if available, average otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_states</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_states</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_final_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Last states of each trajectories.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_state</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">final_state</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Last states of each trajectories averaged into a density matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs final states if available, average otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_final_states</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_final_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">std_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_e_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average the states of the last ``N`` times of every runs as a density</span>
<span class="sd">        matrix. Should converge to the steady state in the right circumstances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N : int [optional]</span>
<span class="sd">            Number of states from the end of ``tlist`` to average. Per default</span>
<span class="sd">            all states will be averaged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="k">else</span> <span class="n">N</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_states</span>
        <span class="k">if</span> <span class="n">states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:])</span> <span class="o">/</span> <span class="n">N</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;  Solver: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Solver stats:&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;  Time interval: [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span><span class="si">}</span><span class="s2"> steps)&quot;</span>
            <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of e_ops: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  States saved.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Final state saved.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  State not saved.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Number of trajectories: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Trajectories saved.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  Trajectories not saved.&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiTrajResult</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shared `e_ops` is required to merge results&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shared `times` are is required to merge results&quot;</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
                             <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">trajectories</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">trajectories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectories</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">trajectories</span>
        <span class="n">new</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">num_trajectories</span>
        <span class="n">new</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">new</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">seeds</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_sum_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum_states</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum_final_states</span>
            <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_target_tols</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">new</span><span class="o">.</span><span class="n">_sum_expect</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_sum2_expect</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">average_e_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new</span><span class="o">.</span><span class="n">std_e_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_sum_expect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">avg</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">_sum_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">new</span><span class="o">.</span><span class="n">num_trajectories</span>
            <span class="n">avg2</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">_sum2_expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">new</span><span class="o">.</span><span class="n">num_trajectories</span>

            <span class="n">new</span><span class="o">.</span><span class="n">average_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">average_e_data</span>

            <span class="n">new</span><span class="o">.</span><span class="n">std_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">new</span><span class="o">.</span><span class="n">trajectories</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">new</span><span class="o">.</span><span class="n">e_data</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">runs_e_data</span>

        <span class="n">new</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;run time&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;run time&quot;</span><span class="p">]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;end_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Merged results&quot;</span>

        <span class="k">return</span> <span class="n">new</span>


<span class="k">class</span> <span class="nc">McTrajectoryResult</span><span class="p">(</span><span class="n">Result</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Result class used by the :class:`qutip.MCSolver` for single trajectories.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="n">options</span><span class="p">,</span> <span class="s2">&quot;normalize_output&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">McResult</span><span class="p">(</span><span class="n">MultiTrajResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing Monte-Carlo solver results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e_ops : :obj:`~Qobj`, :obj:`~QobjEvo`, function or list or dict of these</span>
<span class="sd">        The ``e_ops`` parameter defines the set of values to record at</span>
<span class="sd">        each time step ``t``. If an element is a :obj:`~Qobj` or</span>
<span class="sd">        :obj:`~QobjEvo` the value recorded is the expectation value of that</span>
<span class="sd">        operator given the state at ``t``. If the element is a function, ``f``,</span>
<span class="sd">        the value recorded is ``f(t, state)``.</span>

<span class="sd">        The values are recorded in the ``.expect`` attribute of this result</span>
<span class="sd">        object. ``.expect`` is a list, where each item contains the values</span>
<span class="sd">        of the corresponding ``e_op``.</span>

<span class="sd">    options : :obj:`~SolverResultsOptions`</span>
<span class="sd">        The options for this result class.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict</span>
<span class="sd">        The stats generated by the solver while producing these results. Note</span>
<span class="sd">        that the solver may update the stats directly while producing results.</span>
<span class="sd">        Must include a value for &quot;num_collapse&quot;.</span>

<span class="sd">    kw : dict</span>
<span class="sd">        Additional parameters specific to a result sub-class.</span>

<span class="sd">    Properties</span>
<span class="sd">    ----------</span>
<span class="sd">    collapse : list</span>
<span class="sd">        For each runs, a list of every collapse as a tuple of the time it</span>
<span class="sd">        happened and the corresponding ``c_ops`` index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Collapse are only produced by mcsolve.</span>

    <span class="k">def</span> <span class="nf">_add_collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">collapse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_post_init</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s2">&quot;num_collapse&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_collapse</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">col_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of the times of the collapses for each runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">col_</span><span class="p">))</span>
            <span class="n">col</span> <span class="o">=</span> <span class="p">([]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">col_which</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of the indexes of the collapses for each runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">col_</span><span class="p">))</span>
            <span class="n">col</span> <span class="o">=</span> <span class="p">([]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">photocurrent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average photocurrent or measurement of the evolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)]</span>
        <span class="n">tlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">for</span> <span class="n">collapses</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">which</span> <span class="ow">in</span> <span class="n">collapses</span><span class="p">:</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">mesurement</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tlist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">mesurement</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runs_photocurrent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Photocurrent or measurement of each runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">collapses</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">which</span> <span class="ow">in</span> <span class="n">collapses</span><span class="p">:</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">measurements</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tlist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)</span>
            <span class="p">])</span>
        <span class="k">return</span> <span class="n">measurements</span>


<span class="k">class</span> <span class="nc">McResultImprovedSampling</span><span class="p">(</span><span class="n">McResult</span><span class="p">,</span> <span class="n">MultiTrajResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See docstring for McResult and MultiTrajResult for all relevant documentation.</span>
<span class="sd">    This class computes expectation values and sums of states, etc</span>
<span class="sd">    using the improved sampling algorithm, which samples the no-jump trajectory</span>
<span class="sd">    first and then only samples jump trajectories afterwards.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">MultiTrajResult</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_no_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_no_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_no_jump</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_jump</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">no_jump_prob</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_reduce_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">accu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">accu</span><span class="p">,</span> <span class="n">state</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span><span class="p">,</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_jump</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">accu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">accu</span><span class="p">,</span> <span class="n">state</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_jump</span><span class="p">,</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
            <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_reduce_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="n">dm_final_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_no_jump</span> <span class="o">+=</span> <span class="n">dm_final_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_jump</span> <span class="o">+=</span> <span class="n">dm_final_state</span>

    <span class="k">def</span> <span class="nf">_average_computer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">avg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">avg2</span>

    <span class="k">def</span> <span class="nf">_add_first_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_add_first_traj</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span> <span class="o">=</span> <span class="p">[</span><span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
                                        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_jump</span> <span class="o">=</span> <span class="p">[</span><span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
                                     <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">states</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">final_state</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_no_jump</span> <span class="o">=</span> <span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_jump</span> <span class="o">=</span> <span class="n">qzero_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_dm</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_no_jump</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_no_jump</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">expect</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect</span>

    <span class="k">def</span> <span class="nf">_reduce_expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the average of the expectation values appropriately</span>
<span class="sd">        weighting the jump and no-jump trajectories</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_ops</span><span class="p">):</span>
            <span class="n">expect_traj</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_jump_prob</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span> <span class="o">*</span> <span class="n">p</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span>
                <span class="c1"># no jump trajectory will always be the first one, no need</span>
                <span class="c1"># to worry about including jump trajectories</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">avg2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_traj</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                       <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_expect_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                       <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">avg2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_no_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_expect_jump</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">average_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>

            <span class="c1"># mean(expect**2) - mean(expect)**2 can something be very small</span>
            <span class="c1"># negative (-1e-15) which raise an error for float sqrt.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">std_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">runs_e_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        States averages as density matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_jump_prob</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="n">final_no_jump</span>
                <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">final_jump</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">final_no_jump</span><span class="p">,</span> <span class="n">final_jump</span> <span class="ow">in</span>
                <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_no_jump</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_states_jump</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Last states of each trajectory averaged into a density matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_no_jump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_jump_prob</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">p</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_no_jump</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_final_states_jump</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">photocurrent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average photocurrent or measurement of the evolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)]</span>
        <span class="n">tlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">for</span> <span class="n">collapses</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">which</span> <span class="ow">in</span> <span class="n">collapses</span><span class="p">:</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">mesurement</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_jump_prob</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tlist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_c_ops</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">mesurement</span>


<span class="k">class</span> <span class="nc">NmmcTrajectoryResult</span><span class="p">(</span><span class="n">McTrajectoryResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Result class used by the :class:`qutip.NonMarkovianMCSolver` for single</span>
<span class="sd">    trajectories. Additionally stores the trace of the state along the</span>
<span class="sd">    trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nm_solver</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;__nm_solver&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># This gets called during the Monte-Carlo simulation of the associated</span>
    <span class="c1"># completely positive master equation. To obtain the state of the actual</span>
    <span class="c1"># system, we simply multiply the provided state with the current martingale</span>
    <span class="c1"># before storing it / computing expectation values.</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isket</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">ket2dm</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nm_solver</span><span class="o">.</span><span class="n">current_martingale</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

    <span class="n">add</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Result</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">class</span> <span class="nc">NmmcResult</span><span class="p">(</span><span class="n">McResult</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing the results of the non-Markovian Monte-Carlo solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e_ops : :obj:`~Qobj`, :obj:`~QobjEvo`, function or list or dict of these</span>
<span class="sd">        The ``e_ops`` parameter defines the set of values to record at</span>
<span class="sd">        each time step ``t``. If an element is a :obj:`~Qobj` or</span>
<span class="sd">        :obj:`~QobjEvo` the value recorded is the expectation value of that</span>
<span class="sd">        operator given the state at ``t``. If the element is a function, ``f``,</span>
<span class="sd">        the value recorded is ``f(t, state)``.</span>

<span class="sd">        The values are recorded in the ``.expect`` attribute of this result</span>
<span class="sd">        object. ``.expect`` is a list, where each item contains the values</span>
<span class="sd">        of the corresponding ``e_op``.</span>

<span class="sd">    options : :obj:`~SolverResultsOptions`</span>
<span class="sd">        The options for this result class.</span>

<span class="sd">    solver : str or None</span>
<span class="sd">        The name of the solver generating these results.</span>

<span class="sd">    stats : dict</span>
<span class="sd">        The stats generated by the solver while producing these results. Note</span>
<span class="sd">        that the solver may update the stats directly while producing results.</span>
<span class="sd">        Must include a value for &quot;num_collapse&quot;.</span>

<span class="sd">    kw : dict</span>
<span class="sd">        Additional parameters specific to a result sub-class.</span>

<span class="sd">    Properties</span>
<span class="sd">    ----------</span>
<span class="sd">    average_trace : list</span>
<span class="sd">        The average trace (i.e., averaged over all trajectories) at each time.</span>

<span class="sd">    std_trace : list</span>
<span class="sd">        The standard deviation of the trace at each time.</span>

<span class="sd">    runs_trace : list of lists</span>
<span class="sd">        For each recorded trajectory, the trace at each time.</span>
<span class="sd">        Only present if ``keep_runs_results`` is set in the options.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_post_init</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_trace</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_trace</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">average_trace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_trace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runs_trace</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_trace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_first_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_add_first_traj</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">):</span>
        <span class="n">new_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">trace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum_trace</span> <span class="o">+=</span> <span class="n">new_trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_trace</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_trace</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum_trace</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>
        <span class="n">avg2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum2_trace</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trajectories</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">average_trace</span> <span class="o">=</span> <span class="n">avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;keep_runs_results&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runs_trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">trace</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refers to ``average_trace`` or ``runs_trace``, depending on whether</span>
<span class="sd">        ``keep_runs_results`` is set in the options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runs_trace</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_trace</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Sep 07, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>