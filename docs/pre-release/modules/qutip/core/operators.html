
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qutip.core.operators &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qutip.core.operators</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qutip.core.operators</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functions for generating Qobj representation of a variety</span>
<span class="sd">of commonly occuring quantum operators.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;jmat&#39;</span><span class="p">,</span> <span class="s1">&#39;spin_Jx&#39;</span><span class="p">,</span> <span class="s1">&#39;spin_Jy&#39;</span><span class="p">,</span> <span class="s1">&#39;spin_Jz&#39;</span><span class="p">,</span> <span class="s1">&#39;spin_Jm&#39;</span><span class="p">,</span> <span class="s1">&#39;spin_Jp&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spin_J_set&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmap&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmam&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmax&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmay&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmaz&#39;</span><span class="p">,</span>
           <span class="s1">&#39;destroy&#39;</span><span class="p">,</span> <span class="s1">&#39;create&#39;</span><span class="p">,</span> <span class="s1">&#39;fdestroy&#39;</span><span class="p">,</span> <span class="s1">&#39;fcreate&#39;</span><span class="p">,</span> <span class="s1">&#39;qeye&#39;</span><span class="p">,</span> <span class="s1">&#39;qeye_like&#39;</span><span class="p">,</span>
           <span class="s1">&#39;identity&#39;</span><span class="p">,</span> <span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="s1">&#39;momentum&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;squeeze&#39;</span><span class="p">,</span> <span class="s1">&#39;squeezing&#39;</span><span class="p">,</span>
           <span class="s1">&#39;swap&#39;</span><span class="p">,</span> <span class="s1">&#39;displace&#39;</span><span class="p">,</span> <span class="s1">&#39;commutator&#39;</span><span class="p">,</span> <span class="s1">&#39;qutrit_ops&#39;</span><span class="p">,</span> <span class="s1">&#39;qdiags&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span>
           <span class="s1">&#39;qzero&#39;</span><span class="p">,</span> <span class="s1">&#39;qzero_like&#39;</span><span class="p">,</span> <span class="s1">&#39;enr_destroy&#39;</span><span class="p">,</span> <span class="s1">&#39;enr_identity&#39;</span><span class="p">,</span> <span class="s1">&#39;charge&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tunneling&#39;</span><span class="p">,</span> <span class="s1">&#39;qft&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numbers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">data</span> <span class="k">as</span> <span class="n">_data</span>
<span class="kn">from</span> <span class="nn">.qobj</span> <span class="kn">import</span> <span class="n">Qobj</span>
<span class="kn">from</span> <span class="nn">.dimensions</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">settings</span>


<div class="viewcode-block" id="qdiags"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.qdiags">[docs]</a><span class="k">def</span> <span class="nf">qdiags</span><span class="p">(</span><span class="n">diagonals</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
           <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs an operator from an array of diagonals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    diagonals : sequence of array_like</span>
<span class="sd">        Array of elements to place along the selected diagonals.</span>

<span class="sd">    offsets : sequence of ints, optional</span>
<span class="sd">        Sequence for diagonals to be set:</span>
<span class="sd">            - k=0 main diagonal</span>
<span class="sd">            - k&gt;0 kth upper diagonal</span>
<span class="sd">            - k&lt;0 kth lower diagonal</span>

<span class="sd">    dims : list, optional</span>
<span class="sd">        Dimensions for operator</span>

<span class="sd">    shape : list, tuple, optional</span>
<span class="sd">        Shape of operator.  If omitted, a square operator large enough</span>
<span class="sd">        to contain the diagonals is generated.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; qdiags(sqrt(range(1, 4)), 1) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[4], [4]], \</span>
<span class="sd">shape = [4, 4], type = oper, isherm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.          1.          0.          0.        ]</span>
<span class="sd">     [ 0.          0.          1.41421356  0.        ]</span>
<span class="sd">     [ 0.          0.          0.          1.73205081]</span>
<span class="sd">     [ 0.          0.          0.          0.        ]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">offsets</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">diag</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">diagonals</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="jmat"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.jmat">[docs]</a><span class="k">def</span> <span class="nf">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Higher-order spin operators:</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    which : str</span>
<span class="sd">        Which operator to return &#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;+&#39;,&#39;-&#39;.</span>
<span class="sd">        If no args given, then output is [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jmat : Qobj or tuple of Qobj</span>
<span class="sd">        ``qobj`` for requested spin operator(s).</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; jmat(1) # doctest: +SKIP</span>
<span class="sd">    [ Quantum object: dims = [[3], [3]], \</span>
<span class="sd">shape = [3, 3], type = oper, isHerm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.          0.70710678  0.        ]</span>
<span class="sd">     [ 0.70710678  0.          0.70710678]</span>
<span class="sd">     [ 0.          0.70710678  0.        ]]</span>
<span class="sd">     Quantum object: dims = [[3], [3]], \</span>
<span class="sd">shape = [3, 3], type = oper, isHerm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="sd">     [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="sd">     [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="sd">     Quantum object: dims = [[3], [3]], \</span>
<span class="sd">shape = [3, 3], type = oper, isHerm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 1.  0.  0.]</span>
<span class="sd">     [ 0.  0.  0.]</span>
<span class="sd">     [ 0.  0. -1.]]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If no &#39;args&#39; input, then returns array of [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] operators.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;j must be a non-negative integer or half-integer&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">which</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]]</span><span class="o">*</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_jplus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                    <span class="n">isherm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_jplus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                    <span class="n">isherm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_jplus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                    <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">_jplus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">adjoint</span><span class="p">()),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                    <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_jz</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                    <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid spin operator: &#39;</span> <span class="o">+</span> <span class="n">which</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_jplus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal functions for generating the data representing the J-plus</span>
<span class="sd">    operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">_data</span><span class="o">.</span><span class="n">diag</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_jz</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal functions for generating the data representing the J-z operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="o">-</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_data</span><span class="o">.</span><span class="n">diag</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Spin j operators:</span>
<span class="c1">#</span>
<div class="viewcode-block" id="spin_Jx"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.spin_Jx">[docs]</a><span class="k">def</span> <span class="nf">spin_Jx</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spin-j x operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        ``qobj`` representation of the operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="spin_Jy"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.spin_Jy">[docs]</a><span class="k">def</span> <span class="nf">spin_Jy</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spin-j y operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        ``qobj`` representation of the operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="spin_Jz"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.spin_Jz">[docs]</a><span class="k">def</span> <span class="nf">spin_Jz</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spin-j z operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        ``qobj`` representation of the operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="spin_Jm"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.spin_Jm">[docs]</a><span class="k">def</span> <span class="nf">spin_Jm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spin-j annihilation operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        ``qobj`` representation of the operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="spin_Jp"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.spin_Jp">[docs]</a><span class="k">def</span> <span class="nf">spin_Jp</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spin-j creation operator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operator</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        ``qobj`` representation of the operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">spin_J_set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set of spin-j operators (x, y, z)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float</span>
<span class="sd">        Spin of operators</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list : list of Qobj</span>
<span class="sd">        list of ``qobj`` representating of the spin operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="c1"># Pauli spin-1/2 operators.</span>
<span class="c1">#</span>
<span class="c1"># These are so common in quantum information that we want them to be</span>
<span class="c1"># near-instantaneous to initialise, so we cache them at package import, and</span>
<span class="c1"># just return copies when someone requests one.</span>
<span class="n">_SIGMAP</span> <span class="o">=</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="n">_SIGMAM</span> <span class="o">=</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="n">_SIGMAX</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">_SIGMAY</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">_SIGMAZ</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="sigmap"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.sigmap">[docs]</a><span class="k">def</span> <span class="nf">sigmap</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creation operator for Pauli spins.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sigmap() # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2], [2]], \</span>
<span class="sd">shape = [2, 2], type = oper, isHerm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.  1.]</span>
<span class="sd">     [ 0.  0.]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SIGMAP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="sigmam"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.sigmam">[docs]</a><span class="k">def</span> <span class="nf">sigmam</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Annihilation operator for Pauli spins.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sigmam() # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2], [2]], \</span>
<span class="sd">shape = [2, 2], type = oper, isHerm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.  0.]</span>
<span class="sd">     [ 1.  0.]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SIGMAM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="sigmax"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.sigmax">[docs]</a><span class="k">def</span> <span class="nf">sigmax</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pauli spin 1/2 sigma-x operator</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sigmax() # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2], [2]], \</span>
<span class="sd">shape = [2, 2], type = oper, isHerm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.  1.]</span>
<span class="sd">     [ 1.  0.]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SIGMAX</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="sigmay"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.sigmay">[docs]</a><span class="k">def</span> <span class="nf">sigmay</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pauli spin 1/2 sigma-y operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sigmay() # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2], [2]], \</span>
<span class="sd">shape = [2, 2], type = oper, isHerm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.+0.j  0.-1.j]</span>
<span class="sd">     [ 0.+1.j  0.+0.j]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SIGMAY</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="sigmaz"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.sigmaz">[docs]</a><span class="k">def</span> <span class="nf">sigmaz</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pauli spin 1/2 sigma-z operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sigmaz() # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2], [2]], \</span>
<span class="sd">shape = [2, 2], type = oper, isHerm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 1.  0.]</span>
<span class="sd">     [ 0. -1.]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SIGMAZ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="destroy"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.destroy">[docs]</a><span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Destruction (lowering) operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Dimension of Hilbert space.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Qobj for lowering operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; destroy(4) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>  <span class="c1"># raise error if N not integer</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hilbert space dimension must be integer value&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qdiags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="create"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.create">[docs]</a><span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creation (raising) operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Dimension of Hilbert space.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Qobj for raising operator.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; create(4) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>  <span class="c1"># raise error if N not integer</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Hilbert space dimension must be integer value&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qdiags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="fdestroy"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.fdestroy">[docs]</a><span class="k">def</span> <span class="nf">fdestroy</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fermionic destruction operator.</span>
<span class="sd">    We use the Jordan-Wigner transformation,</span>
<span class="sd">    making use of the Jordan-Wigner ZZ..Z strings,</span>
<span class="sd">    to construct this as follows:</span>

<span class="sd">    .. math::</span>

<span class="sd">        a_j = \\sigma_z^{\\otimes j} \\otimes</span>
<span class="sd">        (\\frac{\\sigma_x + i \\sigma_y}{2})</span>
<span class="sd">        \\otimes I^{\\otimes N-j-1}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_sites : int</span>
<span class="sd">        Number of sites in Fock space.</span>

<span class="sd">    site : int (default 0)</span>
<span class="sd">        The site in Fock space to add a fermion to.</span>
<span class="sd">        Corresponds to j in the above JW transform.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Qobj for destruction operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; fdestroy(2) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims=[[2 2], [2 2]], shape=(4, 4), \</span>
<span class="sd">    type=&#39;oper&#39;, isherm=False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[0. 0. 1. 0.]</span>
<span class="sd">    [0. 0. 0. 1.]</span>
<span class="sd">    [0. 0. 0. 0.]</span>
<span class="sd">    [0. 0. 0. 0.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_f_op</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="s1">&#39;destruction&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="fcreate"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.fcreate">[docs]</a><span class="k">def</span> <span class="nf">fcreate</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fermionic creation operator.</span>
<span class="sd">    We use the Jordan-Wigner transformation,</span>
<span class="sd">    making use of the Jordan-Wigner ZZ..Z strings,</span>
<span class="sd">    to construct this as follows:</span>

<span class="sd">    .. math::</span>

<span class="sd">        a_j = \\sigma_z^{\\otimes j}</span>
<span class="sd">        \\otimes (frac{sigma_x - i sigma_y}{2})</span>
<span class="sd">        \\otimes I^{\\otimes N-j-1}</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_sites : int</span>
<span class="sd">        Number of sites in Fock space.</span>

<span class="sd">    site : int</span>
<span class="sd">        The site in Fock space to add a fermion to.</span>
<span class="sd">        Corresponds to j in the above JW transform.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Qobj for raising operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; fcreate(2) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), \</span>
<span class="sd">    type = oper, isherm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[0. 0. 0. 0.]</span>
<span class="sd">    [0. 0. 0. 0.]</span>
<span class="sd">    [1. 0. 0. 0.]</span>
<span class="sd">    [0. 1. 0. 0.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_f_op</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="s1">&#39;creation&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_f_op</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Makes fermionic creation and destruction operators.</span>
<span class="sd">    We use the Jordan-Wigner transformation,</span>
<span class="sd">    making use of the Jordan-Wigner ZZ..Z strings,</span>
<span class="sd">    to construct this as follows:</span>

<span class="sd">    .. math::</span>

<span class="sd">        a_j = \\sigma_z^{\\otimes j}</span>
<span class="sd">        \\otimes (frac{sigma_x \\pm i sigma_y}{2})</span>
<span class="sd">        \\otimes I^{\\otimes N-j-1}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    action : str</span>
<span class="sd">        The type of operator to build.</span>
<span class="sd">        Can only be &#39;creation&#39; or &#39;destruction&#39;</span>

<span class="sd">    n_sites : int</span>
<span class="sd">        Number of sites in Fock space.</span>

<span class="sd">    site : int</span>
<span class="sd">        The site in Fock space to create/destroy a fermion on.</span>
<span class="sd">        Corresponds to j in the above JW transform.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Qobj for destruction operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get `tensor` and sigma z objects</span>
    <span class="kn">from</span> <span class="nn">.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
    <span class="n">s_z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jmat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># sanity check</span>
    <span class="k">if</span> <span class="n">site</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The specified site </span><span class="si">{</span><span class="n">site</span><span class="si">}</span><span class="s1"> cannot be </span><span class="se">\</span>
<span class="s1">                         less than 0.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="mi">0</span> <span class="o">&gt;=</span> <span class="n">n_sites</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The specified number of sites </span><span class="si">{</span><span class="n">n_sites</span><span class="si">}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                         cannot be equal to or less than 0.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">site</span> <span class="o">&gt;=</span> <span class="n">n_sites</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The specified site </span><span class="si">{</span><span class="n">site</span><span class="si">}</span><span class="s1"> is not in </span><span class="se">\</span>
<span class="s1">                         the range of </span><span class="si">{</span><span class="n">n_sites</span><span class="si">}</span><span class="s1"> sites.&#39;</span><span class="p">)</span>

    <span class="c1"># figure out which operator to build</span>
    <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;creation&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">action</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;destruction&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown operator &#39;</span><span class="si">%s</span><span class="s2">&#39;. `action` must be </span><span class="se">\</span>
<span class="s2">                        either &#39;creation&#39; or &#39;destruction.&#39;&quot;</span> <span class="o">%</span> <span class="n">action</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_z</span><span class="p">]</span> <span class="o">*</span> <span class="n">site</span> <span class="o">+</span> <span class="p">[</span><span class="n">operator</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">eye</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_sites</span> <span class="o">-</span> <span class="n">site</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tensor</span><span class="p">(</span><span class="n">opers</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_implicit_tensor_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Total flattened size and operator dimensions for operator creation routines</span>
<span class="sd">    that automatically perform tensor products.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : (int) or (list of int) or (list of list of int)</span>
<span class="sd">        First dimension of an operator which can create an implicit tensor</span>
<span class="sd">        product.  If the type is `int`, it is promoted first to `[dimensions]`.</span>
<span class="sd">        From there, it should be one of the two-elements `dims` parameter of a</span>
<span class="sd">        `qutip.Qobj` representing an `oper` or `super`, with possible tensor</span>
<span class="sd">        products.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    size : int</span>
<span class="sd">        Dimension of backing matrix required to represent operator.</span>
<span class="sd">    dimensions : list</span>
<span class="sd">        Dimension list in the form required by ``Qobj`` creation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
    <span class="n">flat</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flat</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions must be integers &gt;= 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">flat</span><span class="p">),</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">]</span>


<div class="viewcode-block" id="qzero"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.qzero">[docs]</a><span class="k">def</span> <span class="nf">qzero</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zero operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : (int) or (list of int) or (list of list of int)</span>
<span class="sd">        Dimension of Hilbert space. If provided as a list of ints, then the</span>
<span class="sd">        dimension is the product over this list, but the ``dims`` property of</span>
<span class="sd">        the new Qobj are set to this list.  This can produce either `oper` or</span>
<span class="sd">        `super` depending on the passed `dimensions`.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qzero : qobj</span>
<span class="sd">        Zero operator Qobj.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>
    <span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">_implicit_tensor_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="c1"># A sparse matrix with no data is equal to a zero matrix.</span>
    <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;super&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;oper&#39;</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">zeros</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span>
                <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">qzero_like</span><span class="p">(</span><span class="n">qobj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zero operator of the same dims and type as the reference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qobj : Qobj, QobjEvo</span>
<span class="sd">        Reference quantum object to copy the dims from.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qzero : qobj</span>
<span class="sd">        Zero operator Qobj.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.cy.qobjevo</span> <span class="kn">import</span> <span class="n">QobjEvo</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qobj</span><span class="p">,</span> <span class="n">QobjEvo</span><span class="p">):</span>
        <span class="n">qobj</span> <span class="o">=</span> <span class="n">qobj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qobj</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
        <span class="n">superrep</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">superrep</span><span class="p">,</span> <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>


<div class="viewcode-block" id="qeye"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.qeye">[docs]</a><span class="k">def</span> <span class="nf">qeye</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identity operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : (int) or (list of int) or (list of list of int)</span>
<span class="sd">        Dimension of Hilbert space. If provided as a list of ints, then the</span>
<span class="sd">        dimension is the product over this list, but the ``dims`` property of</span>
<span class="sd">        the new Qobj are set to this list.  This can produce either `oper` or</span>
<span class="sd">        `super` depending on the passed `dimensions`.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Identity operator Qobj.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; qeye(3) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \</span>
<span class="sd">isherm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 1.  0.  0.]</span>
<span class="sd">     [ 0.  1.  0.]</span>
<span class="sd">     [ 0.  0.  1.]]</span>
<span class="sd">    &gt;&gt;&gt; qeye([2,2]) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \</span>
<span class="sd">isherm = True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[1. 0. 0. 0.]</span>
<span class="sd">     [0. 1. 0. 0.]</span>
<span class="sd">     [0. 0. 1. 0.]</span>
<span class="sd">     [0. 0. 0. 1.]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">_implicit_tensor_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;super&#39;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;oper&#39;</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">identity</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">size</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span>
                <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="c1"># Name alias.</span>
<span class="n">identity</span> <span class="o">=</span> <span class="n">qeye</span>


<span class="k">def</span> <span class="nf">qeye_like</span><span class="p">(</span><span class="n">qobj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identity operator with the same dims and type as the reference quantum</span>
<span class="sd">    object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qobj : Qobj, QobjEvo</span>
<span class="sd">        Reference quantum object to copy the dims from.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Identity operator Qobj.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.cy.qobjevo</span> <span class="kn">import</span> <span class="n">QobjEvo</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qobj</span><span class="p">,</span> <span class="n">QobjEvo</span><span class="p">):</span>
        <span class="n">qobj</span> <span class="o">=</span> <span class="n">qobj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">identity_like</span><span class="p">(</span><span class="n">qobj</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
        <span class="n">superrep</span><span class="o">=</span><span class="n">qobj</span><span class="o">.</span><span class="n">superrep</span><span class="p">,</span> <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">isunitary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>


<div class="viewcode-block" id="position"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.position">[docs]</a><span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Position operator x=1/sqrt(2)*(a+a.dag())</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of Fock states in Hilbert space.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Position operator as Qobj.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
    <span class="n">position</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">position</span></div>


<div class="viewcode-block" id="momentum"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.momentum">[docs]</a><span class="k">def</span> <span class="nf">momentum</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Momentum operator p=-1j/sqrt(2)*(a-a.dag())</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of Fock states in Hilbert space.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Momentum operator as Qobj.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">momentum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
    <span class="n">momentum</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">momentum</span></div>


<div class="viewcode-block" id="num"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.num">[docs]</a><span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quantum object for number operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The dimension of the Hilbert space.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper: qobj</span>
<span class="sd">        Qobj for number operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; num(4) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=True</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[0 0 0 0]</span>
<span class="sd">     [0 1 0 0]</span>
<span class="sd">     [0 0 2 0]</span>
<span class="sd">     [0 0 0 3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qdiags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Single-mode squeezing operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Dimension of hilbert space.</span>

<span class="sd">    z : float/complex</span>
<span class="sd">        Squeezing parameter.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : :class:`qutip.Qobj`</span>
<span class="sd">        Squeezing operator.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; squeeze(4, 0.25) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[4], [4]], \</span>
<span class="sd">shape = [4, 4], type = oper, isHerm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="sd">     [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="sd">     [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">asq</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">op</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="n">asq</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">asq</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="squeezing"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.squeezing">[docs]</a><span class="k">def</span> <span class="nf">squeezing</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generalized squeezing operator.</span>

<span class="sd">    .. math::</span>

<span class="sd">        S(z) = \\exp\\left(\\frac{1}{2}\\left(z^*a_1a_2</span>
<span class="sd">        - za_1^\\dagger a_2^\\dagger\\right)\\right)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1 : :class:`qutip.Qobj`</span>
<span class="sd">        Operator 1.</span>

<span class="sd">    a2 : :class:`qutip.Qobj`</span>
<span class="sd">        Operator 2.</span>

<span class="sd">    z : float/complex</span>
<span class="sd">        Squeezing parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : :class:`qutip.Qobj`</span>
<span class="sd">        Squeezing operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a1</span> <span class="o">@</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">@</span> <span class="n">a2</span><span class="o">.</span><span class="n">dag</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">expm</span><span class="p">()</span></div>


<div class="viewcode-block" id="displace"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.displace">[docs]</a><span class="k">def</span> <span class="nf">displace</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Single-mode displacement operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Dimension of Hilbert space.</span>

<span class="sd">    alpha : float/complex</span>
<span class="sd">        Displacement amplitude.</span>

<span class="sd">    offset : int (default 0)</span>
<span class="sd">        The lowest number state that is included in the finite number state</span>
<span class="sd">        representation of the operator.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Displacement operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; displace(4,0.25) # doctest: +SKIP</span>
<span class="sd">    Quantum object: dims = [[4], [4]], \</span>
<span class="sd">shape = [4, 4], type = oper, isHerm = False</span>
<span class="sd">    Qobj data =</span>
<span class="sd">    [[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="sd">     [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="sd">     [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="sd">     [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="commutator"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.commutator">[docs]</a><span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the commutator of kind `kind` (normal, anti) of the</span>
<span class="sd">    two operators A and B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span> <span class="o">-</span> <span class="n">B</span> <span class="o">@</span> <span class="n">A</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;anti&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span> <span class="o">+</span> <span class="n">B</span> <span class="o">@</span> <span class="n">A</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown commutator kind &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span></div>


<div class="viewcode-block" id="qutrit_ops"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.qutrit_ops">[docs]</a><span class="k">def</span> <span class="nf">qutrit_ops</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operators for a three level system (qutrit).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    opers: array</span>
<span class="sd">        `array` of qutrit operators.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.states</span> <span class="kn">import</span> <span class="n">qutrit_basis</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">6</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span> <span class="o">=</span> <span class="n">qutrit_basis</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">one</span> <span class="o">*</span> <span class="n">one</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">two</span> <span class="o">*</span> <span class="n">two</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">three</span> <span class="o">*</span> <span class="n">three</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">one</span> <span class="o">*</span> <span class="n">two</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">two</span> <span class="o">*</span> <span class="n">three</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="n">out</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">three</span> <span class="o">*</span> <span class="n">one</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="phase"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.phase">[docs]</a><span class="k">def</span> <span class="nf">phase</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">phi0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Single-mode Pegg-Barnett phase operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of basis states in Hilbert space.</span>

<span class="sd">    phi0 : float</span>
<span class="sd">        Reference phase.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    oper : qobj</span>
<span class="sd">        Phase operator with respect to reference phase.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dense</span>
    <span class="n">phim</span> <span class="o">=</span> <span class="n">phi0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span>  <span class="c1"># discrete phase angles</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">kk</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">phim</span><span class="p">])</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">states</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="n">N</span><span class="p">],</span> <span class="p">[</span><span class="n">N</span><span class="p">]],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="enr_destroy"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.enr_destroy">[docs]</a><span class="k">def</span> <span class="nf">enr_destroy</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">excitations</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate annilation operators for modes in a excitation-number-restricted</span>
<span class="sd">    state space. For example, consider a system consisting of 4 modes, each</span>
<span class="sd">    with 5 states. The total hilbert space size is 5**4 = 625. If we are</span>
<span class="sd">    only interested in states that contain up to 2 excitations, we only need</span>
<span class="sd">    to include states such as</span>

<span class="sd">        (0, 0, 0, 0)</span>
<span class="sd">        (0, 0, 0, 1)</span>
<span class="sd">        (0, 0, 0, 2)</span>
<span class="sd">        (0, 0, 1, 0)</span>
<span class="sd">        (0, 0, 1, 1)</span>
<span class="sd">        (0, 0, 2, 0)</span>
<span class="sd">        ...</span>

<span class="sd">    This function creates annihilation operators for the 4 modes that act</span>
<span class="sd">    within this state space:</span>

<span class="sd">        a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</span>

<span class="sd">    From this point onwards, the annihiltion operators a1, ..., a4 can be</span>
<span class="sd">    used to setup a Hamiltonian, collapse operators and expectation-value</span>
<span class="sd">    operators, etc., following the usual pattern.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dims : list</span>
<span class="sd">        A list of the dimensions of each subsystem of a composite quantum</span>
<span class="sd">        system.</span>

<span class="sd">    excitations : integer</span>
<span class="sd">        The maximum number of excitations that are to be included in the</span>
<span class="sd">        state space.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_ops : list of qobj</span>
<span class="sd">        A list of annihilation operators for each mode in the composite</span>
<span class="sd">        quantum system described by dims.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.states</span> <span class="kn">import</span> <span class="n">enr_state_dictionaries</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>

    <span class="n">nstates</span><span class="p">,</span> <span class="n">state2idx</span><span class="p">,</span> <span class="n">idx2state</span> <span class="o">=</span> <span class="n">enr_state_dictionaries</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">excitations</span><span class="p">)</span>

    <span class="n">a_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">state1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx2state</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">state1</span><span class="p">):</span>
            <span class="c1"># if s &gt; 0, the annihilation operator of mode idx has a non-zero</span>
            <span class="c1"># entry with one less excitation in mode idx in the final state</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">state2</span> <span class="o">=</span> <span class="n">state1</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">state1</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="n">state2idx</span><span class="p">[</span><span class="n">state2</span><span class="p">]</span>
                <span class="n">a_ops</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">Qobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">a_ops</span><span class="p">]</span></div>


<div class="viewcode-block" id="enr_identity"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.enr_identity">[docs]</a><span class="k">def</span> <span class="nf">enr_identity</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">excitations</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the identity operator for the excitation-number restricted</span>
<span class="sd">    state space defined by the `dims` and `exciations` arguments. See the</span>
<span class="sd">    docstring for enr_fock for a more detailed description of these arguments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dims : list</span>
<span class="sd">        A list of the dimensions of each subsystem of a composite quantum</span>
<span class="sd">        system.</span>

<span class="sd">    excitations : integer</span>
<span class="sd">        The maximum number of excitations that are to be included in the</span>
<span class="sd">        state space.</span>

<span class="sd">    state : list of integers</span>
<span class="sd">        The state in the number basis representation.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op : Qobj</span>
<span class="sd">        A Qobj instance that represent the identity operator in the</span>
<span class="sd">        exication-number-restricted state space defined by `dims` and</span>
<span class="sd">        `exciations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="kn">from</span> <span class="nn">.states</span> <span class="kn">import</span> <span class="n">enr_state_dictionaries</span>
    <span class="n">nstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">enr_state_dictionaries</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">excitations</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">identity</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">nstates</span><span class="p">),</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">dims</span><span class="p">,</span> <span class="n">dims</span><span class="p">],</span>
                <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;oper&#39;</span><span class="p">,</span>
                <span class="n">isherm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">isunitary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="charge"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.charge">[docs]</a><span class="k">def</span> <span class="nf">charge</span><span class="p">(</span><span class="n">Nmax</span><span class="p">,</span> <span class="n">Nmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the diagonal charge operator over charge states</span>
<span class="sd">    from Nmin to Nmax.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nmax : int</span>
<span class="sd">        Maximum charge state to consider.</span>

<span class="sd">    Nmin : int (default = -Nmax)</span>
<span class="sd">        Lowest charge state to consider.</span>

<span class="sd">    frac : float (default = 1)</span>
<span class="sd">        Specify fractional charge if needed.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : Qobj</span>
<span class="sd">        Charge operator over [Nmin, Nmax].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 3.2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">Dia</span>
    <span class="k">if</span> <span class="n">Nmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">Nmax</span>
    <span class="n">diag</span> <span class="o">=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nmin</span><span class="p">,</span> <span class="n">Nmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">qdiags</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="tunneling"><a class="viewcode-back" href="../../../apidoc/functions.html#qutip.core.operators.tunneling">[docs]</a><span class="k">def</span> <span class="nf">tunneling</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tunneling operator with elements of the form</span>
<span class="sd">    :math:`\\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of basis states in Hilbert space.</span>

<span class="sd">    m : int (default = 1)</span>
<span class="sd">        Number of excitations in tunneling event.</span>

<span class="sd">    dtype : type or str</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : Qobj</span>
<span class="sd">        Tunneling operator.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 3.2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diags</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">qdiags</span><span class="p">(</span><span class="n">diags</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">T</span><span class="o">.</span><span class="n">isherm</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">T</span></div>


<span class="k">def</span> <span class="nf">qft</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;dense&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quantum Fourier Transform operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : (int) or (list of int) or (list of list of int)</span>
<span class="sd">        Dimension of Hilbert space. If provided as a list of ints, then the</span>
<span class="sd">        dimension is the product over this list, but the ``dims`` property of</span>
<span class="sd">        the new Qobj are set to this list.</span>

<span class="sd">    dtype : str or type, [keyword only] [optional]</span>
<span class="sd">        Storage representation. Any data-layer known to `qutip.data.to` is</span>
<span class="sd">        accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    QFT: qobj</span>
<span class="sd">        Quantum Fourier transform operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N2</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">=</span> <span class="n">_implicit_tensor_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

    <span class="n">phase</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N2</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N2</span><span class="p">)</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phase</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator that exchanges the order of tensored spaces:</span>

<span class="sd">        swap(N, M) @ tensor(ketN, ketM) == tensor(ketM, ketN)</span>

<span class="sd">    parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of basis states in the first Hilbert space.</span>

<span class="sd">    M : int</span>
<span class="sd">        Number of basis states in the second Hilbert space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">core</span><span class="p">[</span><span class="s2">&quot;default_dtype&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">qeye</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># last entry is nnz</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">M</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">CSR</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">*</span> <span class="n">M</span><span class="p">)),</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">],</span> <span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">]]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../../../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Sep 07, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>