
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Functions &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../static/documentation_options.js"></script>
        <script src="../static/doctools.js"></script>
        <script src="../static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Change Log" href="../changelog.html" />
    <link rel="prev" title="Classes" href="classes.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.states">Quantum States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.operators">Quantum Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.qobj">Quantum Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.superoperator">Superoperators and Liouvillians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.superop_reps">Superoperator Representations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.dimensions">Operators and Superoperator Dimensions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.expect">Expectation Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.tensor">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.core.metrics">Density Matrix Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.continuous_variables">Continuous Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measurement">Measurement</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.measurement">Measurement of quantum states</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.sesolve">Schrödinger Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.mesolve">Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.mcsolve">Monte Carlo Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.krylovsolve">Krylov Subspace Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.brmesolve">Bloch-Redfield Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.heom">Hierarchical Equations of Motion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.correlation">Correlation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.steadystate">Steady-state Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.propagator">Propagators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.scattering">Scattering in Quantum Optical Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.piqs.piqs">Permutational Invariance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.visualization">Graphs and Visualization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.solver.nonmarkov.transfertensor">Non-Markovian Solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.nonmarkov.transfertensor.ttmsolve"><code class="docutils literal notranslate"><span class="pre">ttmsolve</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functions-utilities">Utility Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.solver.parallel">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semidefinite-programming">Semidefinite Programming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="apidoc.html">API documentation</a></li>
      <li class="breadcrumb-item active">Functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h1>
<section id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this heading"></a></h2>
<section id="module-qutip.core.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.core.states" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.basis" title="Permalink to this definition"></a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Qobj representing the requested number state <code class="docutils literal notranslate"><span class="pre">|n&gt;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [1.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]</span>
<span class="go"> [0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.bell_state">
<span class="sig-name descname"><span class="pre">bell_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'00'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#bell_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.bell_state" title="Permalink to this definition"></a></dt>
<dd><p>Returns the selected Bell state:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\lvert B_{00}\rangle &amp;=
    \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\
\lvert B_{01}\rangle &amp;=
    \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\
\lvert B_{10}\rangle &amp;=
    \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\
\lvert B_{11}\rangle &amp;=
    \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\
\end{aligned}\end{split}\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier">str [‘00’, ‘01’, <cite>10</cite>, <cite>11</cite>]</span></dt><dd><p>Which bell state to return</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p>Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.bra">
<span class="sig-name descname"><span class="pre">bra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#bra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.bra" title="Permalink to this definition"></a></dt>
<dd><p>Produces a multiparticle bra state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:</p>
<ul class="simple">
<li><p>‘g’/’e’ (ground and excited state)</p></li>
<li><p>‘u’/’d’ (spin up and down)</p></li>
<li><p>‘H’/’V’ (horizontal and vertical polarization)</p></li>
</ul>
<p>Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bra</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  1.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.  0.  0.  0.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  1.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.  0.  1.  0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.coherent">
<span class="sig-name descname"><span class="pre">coherent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#coherent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.coherent" title="Permalink to this definition"></a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue of coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method ‘analytic’.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent state.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for coherent state</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting state is normalized. With ‘analytic’ method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.coherent_dm">
<span class="sig-name descname"><span class="pre">coherent_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'operator'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#coherent_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.coherent_dm" title="Permalink to this definition"></a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.coherent</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Eigenvalue for coherent state.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p>Method for generating coherent density matrix.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of coherent state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Select method ‘operator’ (default) or ‘analytic’. With the
‘operator’ method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size ‘N’. This method guarantees that the
resulting density matrix is normalized. With ‘analytic’ method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.enr_fock">
<span class="sig-name descname"><span class="pre">enr_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#enr_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.enr_fock" title="Permalink to this definition"></a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.enr_state_dictionaries">
<span class="sig-name descname"><span class="pre">enr_state_dictionaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#enr_state_dictionaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.enr_state_dictionaries" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list</strong></dt><dd><p>A list with the number of states in each sub-system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum numbers of dimension</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>nstates, state2idx, idx2state: integer, dict, list</dt><dd><p>The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a list containing the state tuples
ordered by state indices. state2idx and idx2state are reverses of
each other, i.e., state2idx[idx2state[idx]] = idx and
idx2state[state2idx[state]] = state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.enr_thermal_dm">
<span class="sig-name descname"><span class="pre">enr_thermal_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#enr_thermal_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.enr_thermal_dm" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">integer</span></dt><dd><p>The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">Qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.fock">
<span class="sig-name descname"><span class="pre">fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.fock" title="Permalink to this definition"></a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.basis</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Requested number state <span class="math notranslate nohighlight">\(\left|n\right&gt;\)</span>.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.fock_dm">
<span class="sig-name descname"><span class="pre">fock_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#fock_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.fock_dm" title="Permalink to this definition"></a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.fock</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int or list of ints</span></dt><dd><p>Number of Fock states in Hilbert space.  If a list, then the resultant
object will be a tensor product over spaces with those dimensions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>Integer corresponding to desired number state, defaults to 0 for all
dimensions if omitted.  The shape must match <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>, e.g. if
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is a list, then <code class="docutils literal notranslate"><span class="pre">n</span></code> must either be omitted or a list
of equal length.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or list of ints, optional (default 0 for all dimensions)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the state in the relevant dimension.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix representation of Fock state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.ghz_state">
<span class="sig-name descname"><span class="pre">ghz_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#ghz_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.ghz_state" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Returns the N-qubit GHZ-state:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">|00...00&gt;</span> <span class="pre">+</span> <span class="pre">|11...11&gt;</span> <span class="pre">]</span> <span class="pre">/</span> <span class="pre">sqrt(2)</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int (default=3)</span></dt><dd><p>Number of qubits in state</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">qobj</span></dt><dd><p>N-qubit GHZ-state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.ket">
<span class="sig-name descname"><span class="pre">ket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.ket" title="Permalink to this definition"></a></dt>
<dd><p>Produces a multiparticle ket state for a list or string,
where each element stands for state of the respective particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">str / list of ints or characters</span></dt><dd><p>Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string “1101”).
For qubits it is also possible to use the following conventions:
- ‘g’/’e’ (ground and excited state)
- ‘u’/’d’ (spin up and down)
- ‘H’/’V’ (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int (default: 2) / list of ints</span></dt><dd><p>Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">qobj</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.ket2dm">
<span class="sig-name descname"><span class="pre">ket2dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#ket2dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.ket2dm" title="Permalink to this definition"></a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix formed by outer
product.  This is completely identical to calling <cite>Q.proj()</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">qobj</span></dt><dd><p>Ket or bra type quantum object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.maximally_mixed_dm">
<span class="sig-name descname"><span class="pre">maximally_mixed_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#maximally_mixed_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.maximally_mixed_dm" title="Permalink to this definition"></a></dt>
<dd><p>Returns the maximally mixed density matrix for a Hilbert space of
dimension N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.phase_basis">
<span class="sig-name descname"><span class="pre">phase_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#phase_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.phase_basis" title="Permalink to this definition"></a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis vectors in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Integer corresponding to the mth discrete phase
phi_m = phi0 + 2 * pi * m / N</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float (default=0)</span></dt><dd><p>Reference phase angle.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.projection" title="Permalink to this definition"></a></dt>
<dd><p>The projection operator that projects state <span class="math notranslate nohighlight">\(\lvert m\rangle\)</span> on
state <span class="math notranslate nohighlight">\(\lvert n\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n, m</strong><span class="classifier">float</span></dt><dd><p>The number states in the projection.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the projector.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Requested projection operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.qutrit_basis">
<span class="sig-name descname"><span class="pre">qutrit_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#qutrit_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.qutrit_basis" title="Permalink to this definition"></a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<dl class="simple">
<dt>dtype<span class="classifier">type or str</span></dt><dd><p>storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qstates</strong><span class="classifier">array</span></dt><dd><p>Array of qutrit basis vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.singlet_state">
<span class="sig-name descname"><span class="pre">singlet_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#singlet_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.singlet_state" title="Permalink to this definition"></a></dt>
<dd><p>Returns the two particle singlet-state:</p>
<div class="math notranslate nohighlight">
\[\lvert S\rangle = \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\]</div>
<p>that is identical to the fourth bell state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Bell_state</strong><span class="classifier">qobj</span></dt><dd><p><span class="math notranslate nohighlight">\(\lvert B_{11}\rangle\)</span> Bell state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.spin_coherent">
<span class="sig-name descname"><span class="pre">spin_coherent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ket'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#spin_coherent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.spin_coherent" title="Permalink to this definition"></a></dt>
<dd><p>Generate the coherent spin state <span class="math notranslate nohighlight">\(\lvert \theta, \phi\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle from z axis.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle from x axis.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin coherent state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.spin_state">
<span class="sig-name descname"><span class="pre">spin_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ket'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#spin_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.spin_state" title="Permalink to this definition"></a></dt>
<dd><p>Generates the spin state <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span>, i.e. the
eigenstate of the spin-j Sz operator with eigenvalue m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The spin of the state ().</p>
</dd>
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>Eigenvalue of the spin-j Sz operator.</p>
</dd>
<dt><strong>type</strong><span class="classifier">string {‘ket’, ‘bra’, ‘dm’}</span></dt><dd><p>Type of state to generate.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Qobj quantum object for spin state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.state_index_number">
<span class="sig-name descname"><span class="pre">state_index_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#state_index_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.state_index_number" title="Permalink to this definition"></a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>index</strong><span class="classifier">integer</span></dt><dd><p>The index of the state in standard enumeration ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">tuple</span></dt><dd><p>The state number tuple corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.state_number_enumerate">
<span class="sig-name descname"><span class="pre">state_number_enumerate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#state_number_enumerate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.state_number_enumerate" title="Permalink to this definition"></a></dt>
<dd><p>An iterator that enumerates all the state number tuples (quantum numbers of
the form (n1, n2, n3, …)) for a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span> 
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> 
<span class="go">( 0  0 )</span>
<span class="go">( 0  1 )</span>
<span class="go">( 1  0 )</span>
<span class="go">( 1  1 )</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer (None)</span></dt><dd><p>Restrict state space to states with excitation numbers below or
equal to this value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state_number</strong><span class="classifier">tuple</span></dt><dd><p>Successive state number tuples that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.state_number_index">
<span class="sig-name descname"><span class="pre">state_number_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#state_number_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.state_number_index" title="Permalink to this definition"></a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.state_number_qobj">
<span class="sig-name descname"><span class="pre">state_number_qobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#state_number_qobj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.state_number_qobj" title="Permalink to this definition"></a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or array</span></dt><dd><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list</span></dt><dd><p>State number array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>state</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>The state as a <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code> instance.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deprecated in QuTiP 5.0, use <a class="reference internal" href="#qutip.core.states.basis" title="qutip.core.states.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">basis</span></code></a> instead.</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.thermal_dm">
<span class="sig-name descname"><span class="pre">thermal_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'operator'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#thermal_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.thermal_dm" title="Permalink to this definition"></a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n</strong><span class="classifier">float</span></dt><dd><p>Expectation value for number of particles in thermal state.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘operator’, ‘analytic’}</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">string</span></code> that sets the method used to generate the
thermal state probabilities</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Thermal state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘operator’ method (default) generates
the thermal state using the truncated number operator <code class="docutils literal notranslate"><span class="pre">num(N)</span></code>. This
is the method that should be used in computations. The
‘analytic’ method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;analytic&#39;</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.triplet_states">
<span class="sig-name descname"><span class="pre">triplet_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#triplet_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.triplet_states" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the two particle triplet-states:</p>
<div class="math notranslate nohighlight">
\[\lvert T_1\rangle = \lvert11\rangle
\lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle)
\lvert T_3\rangle = \lvert00\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>trip_states</strong><span class="classifier">list</span></dt><dd><p>2 particle triplet states</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.w_state">
<span class="sig-name descname"><span class="pre">w_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#w_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.w_state" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Returns the N-qubit W-state:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">|100..0&gt;</span> <span class="pre">+</span> <span class="pre">|010..0&gt;</span> <span class="pre">+</span> <span class="pre">|001..0&gt;</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">|000..1&gt;</span> <span class="pre">]</span> <span class="pre">/</span> <span class="pre">sqrt(n)</span></code></p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int (default=3)</span></dt><dd><p>Number of qubits in state</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>W</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>N-qubit W-state</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.states.zero_ket">
<span class="sig-name descname"><span class="pre">zero_ket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/states.html#zero_ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.states.zero_ket" title="Permalink to this definition"></a></dt>
<dd><p>Creates the zero ket vector with shape Nx1 and dimensions <cite>dims</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Hilbert space dimensionality</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Optional dimensions if ket corresponds to
a composite Hilbert space.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>zero_ket</strong><span class="classifier">qobj</span></dt><dd><p>Zero ket on given Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.core.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.core.operators" title="Permalink to this heading"></a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.charge">
<span class="sig-name descname"><span class="pre">charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Nmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#charge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.charge" title="Permalink to this definition"></a></dt>
<dd><p>Generate the diagonal charge operator over charge states
from Nmin to Nmax.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Nmax</strong><span class="classifier">int</span></dt><dd><p>Maximum charge state to consider.</p>
</dd>
<dt><strong>Nmin</strong><span class="classifier">int (default = -Nmax)</span></dt><dd><p>Lowest charge state to consider.</p>
</dd>
<dt><strong>frac</strong><span class="classifier">float (default = 1)</span></dt><dd><p>Specify fractional charge if needed.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">Qobj</span></dt><dd><p>Charge operator over [Nmin, Nmax].</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.commutator">
<span class="sig-name descname"><span class="pre">commutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'normal'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.commutator" title="Permalink to this definition"></a></dt>
<dd><p>Return the commutator of kind <cite>kind</cite> (normal, anti) of the
two operators A and B.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.create">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#create"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.create" title="Permalink to this definition"></a></dt>
<dd><p>Creation (raising) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for raising operator.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.destroy">
<span class="sig-name descname"><span class="pre">destroy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#destroy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Destruction (lowering) operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for lowering operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.displace">
<span class="sig-name descname"><span class="pre">displace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#displace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.displace" title="Permalink to this definition"></a></dt>
<dd><p>Single-mode displacement operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of Hilbert space.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float/complex</span></dt><dd><p>Displacement amplitude.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Displacement operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.enr_destroy">
<span class="sig-name descname"><span class="pre">enr_destroy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#enr_destroy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.enr_destroy" title="Permalink to this definition"></a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div><p>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
…</p>
</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div><p>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</p>
</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, …, a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a_ops</strong><span class="classifier">list of qobj</span></dt><dd><p>A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.enr_identity">
<span class="sig-name descname"><span class="pre">enr_identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excitations</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#enr_identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.enr_identity" title="Permalink to this definition"></a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong><span class="classifier">list of integers</span></dt><dd><p>The state in the number basis representation.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p>A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.fcreate">
<span class="sig-name descname"><span class="pre">fcreate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sites</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">site</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#fcreate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.fcreate" title="Permalink to this definition"></a></dt>
<dd><p>Fermionic creation operator.
We use the Jordan-Wigner transformation,
making use of the Jordan-Wigner ZZ..Z strings,
to construct this as follows:</p>
<div class="math notranslate nohighlight">
\[a_j = \sigma_z^{\otimes j}
\otimes (frac{sigma_x - i sigma_y}{2})
\otimes I^{\otimes N-j-1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_sites</strong><span class="classifier">int</span></dt><dd><p>Number of sites in Fock space.</p>
</dd>
<dt><strong>site</strong><span class="classifier">int</span></dt><dd><p>The site in Fock space to add a fermion to.
Corresponds to j in the above JW transform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for raising operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fcreate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4),     type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[0. 0. 0. 0.]</span>
<span class="go">[0. 0. 0. 0.]</span>
<span class="go">[1. 0. 0. 0.]</span>
<span class="go">[0. 1. 0. 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.fdestroy">
<span class="sig-name descname"><span class="pre">fdestroy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sites</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">site</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#fdestroy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.fdestroy" title="Permalink to this definition"></a></dt>
<dd><p>Fermionic destruction operator.
We use the Jordan-Wigner transformation,
making use of the Jordan-Wigner ZZ..Z strings,
to construct this as follows:</p>
<div class="math notranslate nohighlight">
\[a_j = \sigma_z^{\otimes j} \otimes
(\frac{\sigma_x + i \sigma_y}{2})
\otimes I^{\otimes N-j-1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_sites</strong><span class="classifier">int</span></dt><dd><p>Number of sites in Fock space.</p>
</dd>
<dt><strong>site</strong><span class="classifier">int (default 0)</span></dt><dd><p>The site in Fock space to add a fermion to.
Corresponds to j in the above JW transform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Qobj for destruction operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fdestroy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> 
<span class="go">Quantum object: dims=[[2 2], [2 2]], shape=(4, 4),     type=&#39;oper&#39;, isherm=False</span>
<span class="go">Qobj data =</span>
<span class="go">[[0. 0. 1. 0.]</span>
<span class="go">[0. 0. 0. 1.]</span>
<span class="go">[0. 0. 0. 0.]</span>
<span class="go">[0. 0. 0. 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.identity">
<span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.operators.identity" title="Permalink to this definition"></a></dt>
<dd><p>Identity operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[1. 0. 0. 0.]</span>
<span class="go"> [0. 1. 0. 0.]</span>
<span class="go"> [0. 0. 1. 0.]</span>
<span class="go"> [0. 0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.jmat">
<span class="sig-name descname"><span class="pre">jmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#jmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.jmat" title="Permalink to this definition"></a></dt>
<dd><p>Higher-order spin operators:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>which</strong><span class="classifier">str</span></dt><dd><p>Which operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no args given, then output is [‘x’,’y’,’z’]</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>jmat</strong><span class="classifier">Qobj or tuple of Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> for requested spin operator(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.momentum">
<span class="sig-name descname"><span class="pre">momentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#momentum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.momentum" title="Permalink to this definition"></a></dt>
<dd><p>Momentum operator p=-1j/sqrt(2)*(a-a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Momentum operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.num">
<span class="sig-name descname"><span class="pre">num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#num"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.num" title="Permalink to this definition"></a></dt>
<dd><p>Quantum object for number operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>The dimension of the Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>oper: qobj</dt><dd><p>Qobj for number operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
<span class="go">Quantum object: dims=[[4], [4]], shape=(4, 4), type=&#39;oper&#39;, isherm=True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.phase" title="Permalink to this definition"></a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>phi0</strong><span class="classifier">float</span></dt><dd><p>Reference phase.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Phase operator with respect to reference phase.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.position">
<span class="sig-name descname"><span class="pre">position</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#position"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.position" title="Permalink to this definition"></a></dt>
<dd><p>Position operator x=1/sqrt(2)*(a+a.dag())</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Position operator as Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.qdiags">
<span class="sig-name descname"><span class="pre">qdiags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#qdiags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.qdiags" title="Permalink to this definition"></a></dt>
<dd><p>Constructs an operator from an array of diagonals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diagonals</strong><span class="classifier">sequence of array_like</span></dt><dd><p>Array of elements to place along the selected diagonals.</p>
</dd>
<dt><strong>offsets</strong><span class="classifier">sequence of ints, optional</span></dt><dd><dl class="simple">
<dt>Sequence for diagonals to be set:</dt><dd><ul class="simple">
<li><p>k=0 main diagonal</p></li>
<li><p>k&gt;0 kth upper diagonal</p></li>
<li><p>k&lt;0 kth lower diagonal</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>dims</strong><span class="classifier">list, optional</span></dt><dd><p>Dimensions for operator</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list, tuple, optional</span></dt><dd><p>Shape of operator.  If omitted, a square operator large enough
to contain the diagonals is generated.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qdiags</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          1.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.41421356  0.        ]</span>
<span class="go"> [ 0.          0.          0.          1.73205081]</span>
<span class="go"> [ 0.          0.          0.          0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.qeye">
<span class="sig-name descname"><span class="pre">qeye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#qeye"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.qeye" title="Permalink to this definition"></a></dt>
<dd><p>Identity operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Identity operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[1. 0. 0. 0.]</span>
<span class="go"> [0. 1. 0. 0.]</span>
<span class="go"> [0. 0. 1. 0.]</span>
<span class="go"> [0. 0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.qutrit_ops">
<span class="sig-name descname"><span class="pre">qutrit_ops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#qutrit_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.qutrit_ops" title="Permalink to this definition"></a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>opers: array</dt><dd><p><cite>array</cite> of qutrit operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.qzero">
<span class="sig-name descname"><span class="pre">qzero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#qzero"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.qzero" title="Permalink to this definition"></a></dt>
<dd><p>Zero operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qzero</strong><span class="classifier">qobj</span></dt><dd><p>Zero operator Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.sigmam">
<span class="sig-name descname"><span class="pre">sigmam</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#sigmam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.sigmam" title="Permalink to this definition"></a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.sigmap">
<span class="sig-name descname"><span class="pre">sigmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#sigmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.sigmap" title="Permalink to this definition"></a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmap</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.sigmax">
<span class="sig-name descname"><span class="pre">sigmax</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#sigmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.sigmax" title="Permalink to this definition"></a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.sigmay">
<span class="sig-name descname"><span class="pre">sigmay</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#sigmay"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.sigmay" title="Permalink to this definition"></a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.sigmaz">
<span class="sig-name descname"><span class="pre">sigmaz</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#sigmaz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.sigmaz" title="Permalink to this definition"></a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span> 
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.spin_Jm">
<span class="sig-name descname"><span class="pre">spin_Jm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#spin_Jm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.spin_Jm" title="Permalink to this definition"></a></dt>
<dd><p>Spin-j annihilation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.spin_Jp">
<span class="sig-name descname"><span class="pre">spin_Jp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#spin_Jp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.spin_Jp" title="Permalink to this definition"></a></dt>
<dd><p>Spin-j creation operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.spin_Jx">
<span class="sig-name descname"><span class="pre">spin_Jx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#spin_Jx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.spin_Jx" title="Permalink to this definition"></a></dt>
<dd><p>Spin-j x operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.spin_Jy">
<span class="sig-name descname"><span class="pre">spin_Jy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#spin_Jy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.spin_Jy" title="Permalink to this definition"></a></dt>
<dd><p>Spin-j y operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.spin_Jz">
<span class="sig-name descname"><span class="pre">spin_Jz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#spin_Jz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.spin_Jz" title="Permalink to this definition"></a></dt>
<dd><p>Spin-j z operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>Spin of operator</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#squeeze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.squeeze" title="Permalink to this definition"></a></dt>
<dd><p>Single-mode squeezing operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Dimension of hilbert space.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int (default 0)</span></dt><dd><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span> 
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.squeezing">
<span class="sig-name descname"><span class="pre">squeezing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#squeezing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.squeezing" title="Permalink to this definition"></a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math notranslate nohighlight">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a1</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Operator 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Operator 2.</p>
</dd>
<dt><strong>z</strong><span class="classifier">float/complex</span></dt><dd><p>Squeezing parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Squeezing operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.operators.tunneling">
<span class="sig-name descname"><span class="pre">tunneling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/operators.html#tunneling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.operators.tunneling" title="Permalink to this definition"></a></dt>
<dd><p>Tunneling operator with elements of the form
<span class="math notranslate nohighlight">\(\\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>m</strong><span class="classifier">int (default = 1)</span></dt><dd><p>Number of excitations in tunneling event.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">Qobj</span></dt><dd><p>Tunneling operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="module-qutip.core.qobj">
<span id="quantum-objects"></span><span id="functions-rand"></span><h3>Quantum Objects<a class="headerlink" href="#module-qutip.core.qobj" title="Permalink to this heading"></a></h3>
<p>The Quantum Object (Qobj) class, for representing quantum states and
operators, and related functions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.qobj.ptrace">
<span class="sig-name descname"><span class="pre">ptrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#ptrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.ptrace" title="Permalink to this definition"></a></dt>
<dd><p>Partial trace of the Qobj with selected components remaining.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Composite quantum object.</p>
</dd>
<dt><strong>sel</strong><span class="classifier">int/list</span></dt><dd><p>An <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of components to keep after partial trace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Quantum object representing partial trace with selected components
remaining.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is for legacy compatibility only. It is recommended to use
the <code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> Qobj method.</p>
</dd></dl>

</section>
<section id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this heading"></a></h3>
<p>This module is a collection of random state and operator generators.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_dm">
<span class="sig-name descname"><span class="pre">rand_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ginibre'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition"></a></dt>
<dd><p>Creates a random density matrix of the desired dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <code class="docutils literal notranslate"><span class="pre">oper</span></code> or
<code class="docutils literal notranslate"><span class="pre">super</span></code> depending on the passed <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Density between [0,1] of output density matrix. Used by the “pure”,
“eigen” and “herm”.</p>
</dd>
<dt><strong>distribution</strong><span class="classifier">str {“ginibre”, “hs”, “pure”, “eigen”, “uniform”}</span></dt><dd><p>Method used to obtain the density matrices.</p>
<ul class="simple">
<li><p>“ginibre” : Ginibre random density operator of rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using
the algorithm of <a class="reference internal" href="../biblio.html#bcsz08" id="id2"><span>[BCSZ08]</span></a>.</p></li>
<li><p>“hs” : Hilbert-Schmidt ensemble, equivalent to a full rank ginibre
operator.</p></li>
<li><p>“pure” : Density matrix created from a random ket.</p></li>
<li><p>“eigen” : A density matrix with the given <code class="docutils literal notranslate"><span class="pre">eigenvalues</span></code>.</p></li>
<li><p>“herm” : Build from a random hermitian matrix using <code class="docutils literal notranslate"><span class="pre">rand_herm</span></code>.</p></li>
</ul>
</dd>
<dt><strong>eigenvalues</strong><span class="classifier">array_like, optional</span></dt><dd><p>Eigenvalues of the output Hermitian matrix. The len must match the
shape of the matrix.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int, optional</span></dt><dd><p>When using the “ginibre” distribution, rank of the density matrix.
Will default to a full rank operator when not provided.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_herm">
<span class="sig-name descname"><span class="pre">rand_herm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fill'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition"></a></dt>
<dd><p>Creates a random sparse Hermitian quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float, [0.30]</span></dt><dd><p>Density between [0,1] of output Hermitian operator.</p>
</dd>
<dt><strong>distribution</strong><span class="classifier">str {“fill”, “pos_def”, “eigen”}</span></dt><dd><p>Method used to obtain the density matrices.</p>
<ul class="simple">
<li><p>“fill” : Uses <span class="math notranslate nohighlight">\(H=0.5*(X+X^{+})\)</span> where <span class="math notranslate nohighlight">\(X\)</span> is a randomly
generated quantum operator with elements uniformly distributed
between <code class="docutils literal notranslate"><span class="pre">[-1,</span> <span class="pre">1]</span> <span class="pre">+</span> <span class="pre">[-1j,</span> <span class="pre">1j]</span></code>.</p></li>
<li><p>“eigen” : A density matrix with the given <code class="docutils literal notranslate"><span class="pre">eigenvalues</span></code>. It uses
random complex Jacobi rotations to shuffle the operator.</p></li>
<li><p>“pos_def” : Return a positive semi-definite matrix by diagonal
dominance.</p></li>
</ul>
</dd>
<dt><strong>eigenvalues</strong><span class="classifier">array_like, optional</span></dt><dd><p>Eigenvalues of the output Hermitian matrix. The len must match the
shape of the matrix.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qobj</span></code></span></dt><dd><p>Hermitian quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If given a list of eigenvalues the object is created using complex Jacobi
rotations.  While this method is fast for small matrices, it should not be
repeatedly used for generating matrices larger than ~1000x1000.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_ket">
<span class="sig-name descname"><span class="pre">rand_ket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'haar'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition"></a></dt>
<dd><p>Creates a random ket vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float, [1]</span></dt><dd><p>Density between [0,1] of output ket state when using the <code class="docutils literal notranslate"><span class="pre">fill</span></code>
method.</p>
</dd>
<dt><strong>distribution</strong><span class="classifier">str {“haar”, “fill”}</span></dt><dd><p>Method used to obtain the kets.</p>
<ul class="simple">
<li><p>haar : Haar random pure state obtained by applying a Haar random
unitary to a fixed pure state.</p></li>
<li><p>fill : Fill the ket with uniformly distributed random complex number.</p></li>
</ul>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Ket quantum state vector.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_stochastic">
<span class="sig-name descname"><span class="pre">rand_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_stochastic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_stochastic" title="Permalink to this definition"></a></dt>
<dd><p>Generates a random stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float, [0.75]</span></dt><dd><p>Density between [0,1] of output density matrix.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str (Default = ‘left’)</span></dt><dd><p>Generate ‘left’ or ‘right’ stochastic matrix.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Quantum operator form of stochastic matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_super">
<span class="sig-name descname"><span class="pre">rand_super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">superrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'super'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_super" title="Permalink to this definition"></a></dt>
<dd><p>Returns a randomly drawn superoperator acting on operators acting on
N dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>superrop</strong><span class="classifier">str, optional, {“super”}</span></dt><dd><p>Representation of the super operator</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_super_bcsz">
<span class="sig-name descname"><span class="pre">rand_super_bcsz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enforce_tp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">superrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'super'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_super_bcsz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_super_bcsz" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random superoperator drawn from the Bruzda
et al ensemble for CPTP maps <a class="reference internal" href="../biblio.html#bcsz08" id="id3"><span>[BCSZ08]</span></a>. Note that due to
finite numerical precision, for ranks less than full-rank,
zero eigenvalues may become slightly negative, such that the
returned operator is not actually completely positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If an int is provided, it is understood as
the Square root of the dimension of the superoperator to be returned,
with the corresponding dims as <code class="docutils literal notranslate"><span class="pre">[[[N],[N]],</span> <span class="pre">[[N],[N]]]</span></code>. If provided
as a list of ints, then the dimensions is understood as the space of
density matrices this superoperator is applied to: <code class="docutils literal notranslate"><span class="pre">dimensions=[2,2]</span></code>
<code class="docutils literal notranslate"><span class="pre">dims=[[[2,2],[2,2]],</span> <span class="pre">[[2,2],[2,2]]]</span></code>.</p>
</dd>
<dt><strong>enforce_tp</strong><span class="classifier">bool</span></dt><dd><p>If True, the trace-preserving condition of <a class="reference internal" href="../biblio.html#bcsz08" id="id4"><span>[BCSZ08]</span></a> is enforced;
otherwise only complete positivity is enforced.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or None</span></dt><dd><p>Rank of the sampled superoperator. If None, a full-rank
superoperator is generated.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>superrop</strong><span class="classifier">str, optional, {“super”}</span></dt><dd><p>representation of the</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>A superoperator acting on vectorized dim × dim density operators,
sampled from the BCSZ distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.random_objects.rand_unitary">
<span class="sig-name descname"><span class="pre">rand_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'haar'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition"></a></dt>
<dd><p>Creates a random sparse unitary quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">(int) or (list of int) or (list of list of int)</span></dt><dd><p>Dimension of Hilbert space. If provided as a list of ints, then the
dimension is the product over this list, but the <code class="docutils literal notranslate"><span class="pre">dims</span></code> property of
the new Qobj are set to this list.  This can produce either <cite>oper</cite> or
<cite>super</cite> depending on the passed <cite>dimensions</cite>.</p>
</dd>
<dt><strong>density</strong><span class="classifier">float, [1]</span></dt><dd><p>Density between [0,1] of output unitary operator.</p>
</dd>
<dt><strong>distribution</strong><span class="classifier">[“haar”, “exp”]</span></dt><dd><p>Method used to obtain the unitary matrices.</p>
<ul class="simple">
<li><p>haar : Haar random unitary matrix using the algorithm of <a class="reference internal" href="../biblio.html#mez07" id="id5"><span>[Mez07]</span></a>.</p></li>
<li><p>exp : Uses <span class="math notranslate nohighlight">\(\exp(-iH)\)</span>, where H is a randomly generated
Hermitian operator.</p></li>
</ul>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, Generator, optional</span></dt><dd><p>Seed to create the random number generator or a pre prepared
generator. When none is suplied, a default generator is used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or str</span></dt><dd><p>Storage representation. Any data-layer known to <cite>qutip.data.to</cite> is
accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Unitary quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.core.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.core.superoperator" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.lindblad_dissipator">
<span class="sig-name descname"><span class="pre">lindblad_dissipator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#lindblad_dissipator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.lindblad_dissipator" title="Permalink to this definition"></a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math notranslate nohighlight">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Left part of collapse operator.</p>
</dd>
<dt><strong>b</strong><span class="classifier">Qobj or QobjEvo (optional)</span></dt><dd><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</dd>
<dt><strong>chi</strong><span class="classifier">float [None]</span></dt><dd><p>In some systems it is possible to determine the statistical moments (mean, variance, etc) of the
probability distribution of the occupation numbers of states by numerically evaluating the derivatives
of the steady state occupation probability as a function of an artificial phase parameter <code class="docutils literal notranslate"><span class="pre">chi</span></code>
which multiplies the <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">\rho</span> <span class="pre">a^dagger</span></code> term of the dissipator by <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">^</span> <span class="pre">(i</span> <span class="pre">*</span> <span class="pre">chi)</span></code>. The factor <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">^</span> <span class="pre">(i</span> <span class="pre">*</span> <span class="pre">chi)</span></code>
is introduced via the generating function of the statistical moments. For examples of the technique,
see <a class="reference external" href="https://arxiv.org/abs/cond-mat/0410322">Full counting statistics of nano-electromechanical systems</a>
and <a class="reference external" href="https://arxiv.org/abs/1303.7449">Photon-mediated electron transport in hybrid circuit-QED</a>.
This parameter is deprecated and may be removed in QuTiP 5.</p>
</dd>
<dt><strong>data_only</strong><span class="classifier">bool [False]</span></dt><dd><p>Return the data object instead of a Qobj</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">qobj, QobjEvo</span></dt><dd><p>Lindblad dissipator superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.liouvillian">
<span class="sig-name descname"><span class="pre">liouvillian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#liouvillian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.liouvillian" title="Permalink to this definition"></a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">Qobj or QobjEvo (optional)</span></dt><dd><p>System Hamiltonian or Hamiltonian component of a Liouvillian.
Considered <cite>0</cite> if not given.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">array_like of Qobj or QobjEvo</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of collapse operators.</p>
</dd>
<dt><strong>data_only</strong><span class="classifier">bool [False]</span></dt><dd><p>Return the data object instead of a Qobj</p>
</dd>
<dt><strong>chi</strong><span class="classifier">array_like of float [None]</span></dt><dd><p>In some systems it is possible to determine the statistical moments (mean, variance, etc) of the
probability distributions of occupation of various states by numerically evaluating the derivatives
of the steady state occupation probability as a function of artificial phase parameters <code class="docutils literal notranslate"><span class="pre">chi</span></code>
which are included in the <a class="reference internal" href="#qutip.core.superoperator.lindblad_dissipator" title="qutip.core.superoperator.lindblad_dissipator"><code class="xref py py-func docutils literal notranslate"><span class="pre">lindblad_dissipator</span></code></a> for each collapse operator. See
the documentation of <a class="reference internal" href="#qutip.core.superoperator.lindblad_dissipator" title="qutip.core.superoperator.lindblad_dissipator"><code class="xref py py-func docutils literal notranslate"><span class="pre">lindblad_dissipator</span></code></a> for references and further details.
This parameter is deprecated and may be removed in QuTiP 5.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Liouvillian superoperator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.operator_to_vector">
<span class="sig-name descname"><span class="pre">operator_to_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#operator_to_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.operator_to_vector" title="Permalink to this definition"></a></dt>
<dd><p>Create a vector representation given a quantum operator in matrix form.
The passed object should have a <code class="docutils literal notranslate"><span class="pre">Qobj.type</span></code> of ‘oper’ or ‘super’; this
function is not designed for general-purpose matrix reshaping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator in matrix form.  This must have a type of ‘oper’ or
‘super’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj or QobjEvo</dt><dd><p>The same object, but re-cast into a column-stacked-vector form of type
‘operator-ket’.  The output is the same type as the passed object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.spost">
<span class="sig-name descname"><span class="pre">spost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#spost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.spost" title="Permalink to this definition"></a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input qauntum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.spre">
<span class="sig-name descname"><span class="pre">spre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#spre"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.spre" title="Permalink to this definition"></a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>super :Qobj or QobjEvo</dt><dd><p>Superoperator formed from input quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.sprepost">
<span class="sig-name descname"><span class="pre">sprepost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#sprepost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.sprepost" title="Permalink to this definition"></a></dt>
<dd><p>Superoperator formed from pre-multiplication by A and post-multiplication
by B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for pre-multiplication.</p>
</dd>
<dt><strong>B</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator for post-multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>super</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Superoperator formed from input quantum objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superoperator.vector_to_operator">
<span class="sig-name descname"><span class="pre">vector_to_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superoperator.html#vector_to_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superoperator.vector_to_operator" title="Permalink to this definition"></a></dt>
<dd><p>Create a matrix representation given a quantum operator in vector form.
The passed object should have a <code class="docutils literal notranslate"><span class="pre">Qobj.type</span></code> of ‘operator-ket’; this
function is not designed for general-purpose matrix reshaping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">Qobj or QobjEvo</span></dt><dd><p>Quantum operator in column-stacked-vector form.  This must have a type
of ‘operator-ket’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj or QobjEvo</dt><dd><p>The same object, but re-cast into “standard” operator form.  The output
is the same type as the passed object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.core.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.core.superop_reps" title="Permalink to this heading"></a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.kraus_to_choi">
<span class="sig-name descname"><span class="pre">kraus_to_choi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kraus_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#kraus_to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.kraus_to_choi" title="Permalink to this definition"></a></dt>
<dd><p>Take a list of Kraus operators and returns the Choi matrix for the channel
represented by the Kraus operators in <cite>kraus_list</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.kraus_to_super">
<span class="sig-name descname"><span class="pre">kraus_to_super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kraus_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#kraus_to_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.kraus_to_super" title="Permalink to this definition"></a></dt>
<dd><p>Convert a list of Kraus operators to a superoperator.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.to_chi">
<span class="sig-name descname"><span class="pre">to_chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#to_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.to_chi" title="Permalink to this definition"></a></dt>
<dd><p>Converts a Qobj representing a quantum map to a representation as a chi
(process) matrix in the Pauli basis, such that the trace of the returned
operator is equal to the dimension of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Chi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_chi(A)</span> <span class="pre">==</span> <span class="pre">to_chi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">chi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;chi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be converted</dt><dd><p>to Chi representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.to_choi">
<span class="sig-name descname"><span class="pre">to_choi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#to_choi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.to_choi" title="Permalink to this definition"></a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Choi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_choi(A)</span> <span class="pre">==</span> <span class="pre">to_choi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>choi</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be converted</dt><dd><p>to Choi representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.to_kraus">
<span class="sig-name descname"><span class="pre">to_kraus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#to_kraus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.to_kraus" title="Permalink to this definition"></a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to Kraus representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_kraus(A)</span> <span class="pre">==</span> <span class="pre">to_kraus(sprepost(A,</span> <span class="pre">A.dag()))</span> <span class="pre">==</span> <span class="pre">[A]</span></code>.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">Float</span></dt><dd><p>Optional threshold parameter for eigenvalues/Kraus ops to be discarded.
The default is to=1e-9.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kraus_ops</strong><span class="classifier">list of Qobj</span></dt><dd><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError: if the given quantum object is not a map, or cannot be</dt><dd><p>decomposed into Kraus operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.to_stinespring">
<span class="sig-name descname"><span class="pre">to_stinespring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#to_stinespring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.to_stinespring" title="Permalink to this definition"></a></dt>
<dd><p>Converts a Qobj representing a quantum map $Lambda$ to a pair of partial
isometries $A$ and $B$ such that $Lambda(X) = Tr_2(A X B^dagger)$ for
all inputs $X$, where the partial trace is taken over a a new index on the
output dimensions of $A$ and $B$.</p>
<p>For completely positive inputs, $A$ will always equal $B$ up to precision
errors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to a Stinespring pair.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A, B</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum objects representing each of the Stinespring matrices for the
input Qobj.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.superop_reps.to_super">
<span class="sig-name descname"><span class="pre">to_super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/superop_reps.html#to_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.superop_reps.to_super" title="Permalink to this definition"></a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q_oper</strong><span class="classifier">Qobj</span></dt><dd><p>Superoperator to be converted to supermatrix representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_super(A)</span> <span class="pre">==</span> <span class="pre">sprepost(A,</span> <span class="pre">A.dag())</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>superop</strong><span class="classifier">Qobj</span></dt><dd><p>A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the given quantum object is not a map, or cannot be converted
to supermatrix representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.core.dimensions">
<span id="operators-and-superoperator-dimensions"></span><h3>Operators and Superoperator Dimensions<a class="headerlink" href="#module-qutip.core.dimensions" title="Permalink to this heading"></a></h3>
<p>Internal use module for manipulating dims specifications.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.collapse_dims_oper">
<span class="sig-name descname"><span class="pre">collapse_dims_oper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#collapse_dims_oper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.collapse_dims_oper" title="Permalink to this definition"></a></dt>
<dd><p>Given the dimensions specifications for a ket-, bra- or oper-type
Qobj, returns a dimensions specification describing the same shape
by collapsing all composite systems. For instance, the bra-type
dimensions specification <code class="docutils literal notranslate"><span class="pre">[[2,</span> <span class="pre">3],</span> <span class="pre">[1]]</span></code> collapses to
<code class="docutils literal notranslate"><span class="pre">[[6],</span> <span class="pre">[1]]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Dimensions specifications to be collapsed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapsed_dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Collapsed dimensions specification describing the same shape
such that <code class="docutils literal notranslate"><span class="pre">len(collapsed_dims[0])</span> <span class="pre">==</span> <span class="pre">len(collapsed_dims[1])</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.collapse_dims_super">
<span class="sig-name descname"><span class="pre">collapse_dims_super</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#collapse_dims_super"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.collapse_dims_super" title="Permalink to this definition"></a></dt>
<dd><p>Given the dimensions specifications for an operator-ket-, operator-bra- or
super-type Qobj, returns a dimensions specification describing the same shape
by collapsing all composite systems. For instance, the super-type
dimensions specification <code class="docutils literal notranslate"><span class="pre">[[[2,</span> <span class="pre">3],</span> <span class="pre">[2,</span> <span class="pre">3]],</span> <span class="pre">[[2,</span> <span class="pre">3],</span> <span class="pre">[2,</span> <span class="pre">3]]]</span></code> collapses to
<code class="docutils literal notranslate"><span class="pre">[[[6],</span> <span class="pre">[6]],</span> <span class="pre">[[6],</span> <span class="pre">[6]]]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Dimensions specifications to be collapsed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapsed_dims</strong><span class="classifier">list of lists of ints</span></dt><dd><p>Collapsed dimensions specification describing the same shape
such that <code class="docutils literal notranslate"><span class="pre">len(collapsed_dims[i][j])</span> <span class="pre">==</span> <span class="pre">1</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>
in <code class="docutils literal notranslate"><span class="pre">range(2)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.deep_remove">
<span class="sig-name descname"><span class="pre">deep_remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">what</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#deep_remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.deep_remove" title="Permalink to this definition"></a></dt>
<dd><p>Removes scalars from all levels of a nested list.</p>
<p>Given a list containing a mix of scalars and lists,
returns a list of the same structure, but where one or
more scalars have been removed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deep_remove</span><span class="p">([[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> 
<span class="go">[[[[1, 2]], [3, 4], [], [6, 7]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.dims_idxs_to_tensor_idxs">
<span class="sig-name descname"><span class="pre">dims_idxs_to_tensor_idxs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#dims_idxs_to_tensor_idxs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.dims_idxs_to_tensor_idxs" title="Permalink to this definition"></a></dt>
<dd><p>Given the dims of a Qobj instance, and some indices into
dims, returns the corresponding tensor indices. This helps
resolve, for instance, that column-stacking for superoperators,
oper-ket and oper-bra implies that the input and output tensor
indices are reversed from their order in dims.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">int, list or tuple</span></dt><dd><p>Indices to convert to tensor indices. Can be specified
as a single index, or as a collection of indices.
In the latter case, this can be nested arbitrarily
deep. For instance, [0, [0, (2, 3)]].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tens_indices</strong><span class="classifier">int, list or tuple</span></dt><dd><p>Container of the same structure as indices containing
the tensor indices for each element of indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.dims_to_tensor_perm">
<span class="sig-name descname"><span class="pre">dims_to_tensor_perm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#dims_to_tensor_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.dims_to_tensor_perm" title="Permalink to this definition"></a></dt>
<dd><p>Given the dims of a Qobj instance, returns a list representing
a permutation from the flattening of that dims specification to
the corresponding tensor indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list</span></dt><dd><p>A list such that <code class="docutils literal notranslate"><span class="pre">data[flatten(dims)[idx]]</span></code> gives the
index of the tensor <code class="docutils literal notranslate"><span class="pre">data</span></code> corresponding to the <code class="docutils literal notranslate"><span class="pre">idx``th</span>
<span class="pre">dimension</span> <span class="pre">of</span> <span class="pre">``dims</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.dims_to_tensor_shape">
<span class="sig-name descname"><span class="pre">dims_to_tensor_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#dims_to_tensor_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.dims_to_tensor_shape" title="Permalink to this definition"></a></dt>
<dd><p>Given the dims of a Qobj instance, returns the shape of the
corresponding tensor. This helps, for instance, resolve the
column-stacking convention for superoperators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions specification for a Qobj.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_shape</strong><span class="classifier">tuple</span></dt><dd><p>NumPy shape of the corresponding tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.enumerate_flat">
<span class="sig-name descname"><span class="pre">enumerate_flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#enumerate_flat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.enumerate_flat" title="Permalink to this definition"></a></dt>
<dd><p>Labels the indices at which scalars occur in a flattened list.</p>
<p>Given a list containing a mix of scalars and lists,
returns a list of the same structure, where each scalar
has been replaced by an index into the flattened list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">enumerate_flat</span><span class="p">([[[</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]],</span> <span class="mi">40</span><span class="p">]))</span> 
<span class="go">[[[0], [1, 2]], 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#flatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.flatten" title="Permalink to this definition"></a></dt>
<dd><p>Flattens a list of lists to the first level.</p>
<p>Given a list containing a mix of scalars and lists,
flattens down to a list of the scalars within the original
list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span> 
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.is_scalar">
<span class="sig-name descname"><span class="pre">is_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#is_scalar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.is_scalar" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if a dims specification is effectively
a scalar (has dimension 1).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.dimensions.unflatten">
<span class="sig-name descname"><span class="pre">unflatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idxs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/dimensions.html#unflatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.dimensions.unflatten" title="Permalink to this definition"></a></dt>
<dd><p>Unflattens a list by a given structure.</p>
<p>Given a list of scalars and a deep list of indices
as produced by <cite>flatten</cite>, returns an “unflattened”
form of the list. This perfectly inverts <cite>flatten</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">]]]</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">idxs</span> <span class="o">=</span> <span class="n">enumerate_flat</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">unflatten</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">idxs</span><span class="p">)</span> <span class="o">==</span> <span class="n">l</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this heading"></a></h2>
<section id="module-qutip.core.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.core.expect" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.expect.expect">
<span class="sig-name descname"><span class="pre">expect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/expect.html#expect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.expect.expect" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the expectation value for operator(s) and state(s).  The
expectation of state <cite>k</cite> on operator <cite>A</cite> is defined as <cite>k.dag() &#64; A &#64; k</cite>,
and for density matrix <cite>R</cite> on operator <cite>A</cite> it is <cite>trace(A &#64; R)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/array-like</span></dt><dd><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expt</strong><span class="classifier">float/complex/array-like</span></dt><dd><p>Expectation value.  <code class="docutils literal notranslate"><span class="pre">real</span></code> if <cite>oper</cite> is Hermitian, <code class="docutils literal notranslate"><span class="pre">complex</span></code>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span> 
<span class="go">    True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.expect.variance">
<span class="sig-name descname"><span class="pre">variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/expect.html#variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.expect.variance" title="Permalink to this definition"></a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">qobj</span></dt><dd><p>Operator for expectation value.</p>
</dd>
<dt><strong>state</strong><span class="classifier">qobj/list</span></dt><dd><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>var</strong><span class="classifier">float</span></dt><dd><p>Variance of operator ‘oper’ for given state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.core.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.core.tensor" title="Permalink to this heading"></a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.tensor.composite">
<span class="sig-name descname"><span class="pre">composite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/tensor.html#composite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.tensor.composite" title="Permalink to this definition"></a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <code class="docutils literal notranslate"><span class="pre">to_super</span></code>,
while kets and bras are promoted by taking their projectors and
using <code class="docutils literal notranslate"><span class="pre">operator_to_vector(ket2dm(arg))</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.tensor.super_tensor">
<span class="sig-name descname"><span class="pre">super_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/tensor.html#super_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.tensor.super_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the tensor product of input superoperators, by tensoring together
the underlying Hilbert spaces on which each vectorized operator acts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects with <code class="docutils literal notranslate"><span class="pre">type=&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.tensor.tensor">
<span class="sig-name descname"><span class="pre">tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/tensor.html#tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.tensor.tensor" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">array_like</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects for tensor product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">qobj</span></dt><dd><p>A composite quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span> 
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.tensor.tensor_contract">
<span class="sig-name descname"><span class="pre">tensor_contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">pairs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/tensor.html#tensor_contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.tensor.tensor_contract" title="Permalink to this definition"></a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">tuple</span></dt><dd><p>One or more tuples <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> indicating that the
<code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> dimensions of the original qobj
should be contracted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cqobj</strong><span class="classifier">Qobj</span></dt><dd><p>The original Qobj with all named index pairs contracted
away.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.partial_transpose.partial_transpose">
<span class="sig-name descname"><span class="pre">partial_transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dense'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition"></a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>A density matrix.</p>
</dd>
<dt><strong>mask</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>A mask that selects which subsystems should be transposed.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rho_pr: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></dt><dd><p>A density matrix with the selected subsystems transposed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.concurrence">
<span class="sig-name descname"><span class="pre">concurrence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#concurrence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Ket, bra, or density matrix for a two-qubit state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>concur</strong><span class="classifier">float</span></dt><dd><p>Concurrence</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r8ba8a4d22c3a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Concurrence_(quantum_computing">https://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.entropy_conditional">
<span class="sig-name descname"><span class="pre">entropy_conditional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the conditional entropy <span class="math notranslate nohighlight">\(S(A|B)=S(A,B)-S(B)\)</span>
of a selected density matrix component.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix of composite object</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p>Selected components for density matrix B</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_cond</strong><span class="classifier">float</span></dt><dd><p>Value of conditional entropy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.entropy_linear">
<span class="sig-name descname"><span class="pre">entropy_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition"></a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>sensity matrix or ket/bra vector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Linear entropy of rho.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.entropy_mutual">
<span class="sig-name descname"><span class="pre">entropy_mutual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix for composite quantum systems</p>
</dd>
<dt><strong>selA</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</dd>
<dt><strong>selB</strong><span class="classifier">int/list</span></dt><dd><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_mut</strong><span class="classifier">float</span></dt><dd><p>Mutual information between selected components.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.entropy_relative">
<span class="sig-name descname"><span class="pre">entropy_relative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_relative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_relative" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the relative entropy S(rho||sigma) between two density
matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>First density matrix (or ket which will be converted to a density
matrix).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Second density matrix (or ket which will be converted to a density
matrix).</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm. Defaults to e.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Flag to use sparse solver when determining the eigenvectors
of the density matrices. Defaults to False.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance to use to detect 0 eigenvalues or dot producted between
eigenvectors. Defaults to 1e-12.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rel_ent</strong><span class="classifier">float</span></dt><dd><p>Value of relative entropy. Guaranteed to be greater than zero
and should equal zero only when rho and sigma are identical.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>See Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”,
Section 11.3.1, pg. 511 for a detailed explanation of quantum relative
entropy.</p>
<p class="rubric">Examples</p>
<p>First we define two density matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;00&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">qutip</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qutip</span><span class="o">.</span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;01&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
</pre></div>
</div>
<p>Then we calculate their relative entropy using base 2 (i.e. <code class="docutils literal notranslate"><span class="pre">log2</span></code>)
and base e (i.e. <code class="docutils literal notranslate"><span class="pre">log</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">entropy_relative</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">entropy_relative</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.6931471805599453</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.entropy.entropy_vn">
<span class="sig-name descname"><span class="pre">entropy_vn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.718281828459045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition"></a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix.</p>
</dd>
<dt><strong>base</strong><span class="classifier">{e,2}</span></dt><dd><p>Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False,True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-qutip.core.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.core.metrics" title="Permalink to this heading"></a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.average_gate_fidelity">
<span class="sig-name descname"><span class="pre">average_gate_fidelity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#average_gate_fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.average_gate_fidelity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average gate fidelity of a quantum channel to the target
channel, or to the identity channel if no target is given.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>/list</span></dt><dd><p>A unitary operator, or a superoperator in supermatrix, Choi or
chi-matrix form, or a list of Kraus operators</p>
</dd>
<dt><strong>target</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>A unitary operator</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Average gate fidelity between oper and target,
or between oper and identity.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The average gate fidelity is defined for example in:
A. Gilchrist, N.K. Langford, M.A. Nielsen, Phys. Rev. A 71, 062310 (2005).
The definition of state fidelity that the average gate fidelity is based on
is the one from R. Jozsa, Journal of Modern Optics, 41:12, 2315 (1994).
It is the square of the fidelity implemented in
<a class="reference internal" href="#qutip.core.metrics.fidelity" title="qutip.core.metrics.fidelity"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.metrics.fidelity</span></code></a> which follows Nielsen &amp; Chuang,
“Quantum Computation and Quantum Information”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.bures_angle">
<span class="sig-name descname"><span class="pre">bures_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#bures_angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.bures_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Bures angle between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.bures_dist">
<span class="sig-name descname"><span class="pre">bures_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#bures_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.bures_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Bures distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.dnorm">
<span class="sig-name descname"><span class="pre">dnorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CVXOPT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_solve</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#dnorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.dnorm" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the diamond norm of the quantum map q_oper, using
the simplified semidefinite program of <a class="reference internal" href="../biblio.html#wat13" id="id7"><span>[Wat13]</span></a>.</p>
<p>The diamond norm SDP is solved by using <a class="reference external" href="https://www.cvxpy.org/en/latest/..">CVXPY</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum map to take the diamond norm of.</p>
</dd>
<dt><strong>B</strong><span class="classifier">Qobj or None</span></dt><dd><p>If provided, the diamond norm of <span class="math notranslate nohighlight">\(A - B\)</span> is taken instead.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>Solver to use with CVXPY. One of “CVXOPT” (default) or “SCS”. The
latter tends to be significantly faster, but somewhat less accurate.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints additional information about the solution.</p>
</dd>
<dt><strong>force_solve</strong><span class="classifier">bool</span></dt><dd><p>If True, forces dnorm to solve the associated SDP, even if a special
case is known for the argument.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Whether to use sparse matrices in the convex optimisation problem.
Default True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dn</strong><span class="classifier">float</span></dt><dd><p>Diamond norm of q_oper.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ImportError</dt><dd><p>If CVXPY cannot be imported.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.fidelity">
<span class="sig-name descname"><span class="pre">fidelity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.fidelity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Fidelity pseudo-metric between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">0.24104350624628332</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.hellinger_dist">
<span class="sig-name descname"><span class="pre">hellinger_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#hellinger_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.hellinger_dist" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the quantum Hellinger distance between two density matrices.</p>
<p>Formula:
hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B)))</p>
<p>See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, “Geometric
measures of quantum correlations with Bures and Hellinger distances”
arXiv:1611.03449</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False, True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hellinger_dist</strong><span class="classifier">float</span></dt><dd><p>Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">hellinger_dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">1.3725145002591095</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.hilbert_dist">
<span class="sig-name descname"><span class="pre">hilbert_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#hilbert_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.hilbert_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">float</span></dt><dd><p>Hilbert-Schmidt distance between density matrices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.process_fidelity">
<span class="sig-name descname"><span class="pre">process_fidelity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#process_fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.process_fidelity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the process fidelity of a quantum channel to the target
channel, or to the identity channel if no target is given.
The process fidelity between two channels is defined as the state
fidelity between their normalized Choi matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>/list</span></dt><dd><p>A unitary operator, or a superoperator in supermatrix, Choi or
chi-matrix form, or a list of Kraus operators</p>
</dd>
<dt><strong>target</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>/list</span></dt><dd><p>A unitary operator, or a superoperator in supermatrix, Choi or
chi-matrix form, or a list of Kraus operators</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fid</strong><span class="classifier">float</span></dt><dd><p>Process fidelity between oper and target, or between oper and identity.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Since Qutip 5.0, this function computes the process fidelity as defined
for example in: A. Gilchrist, N.K. Langford, M.A. Nielsen,
Phys. Rev. A 71, 062310 (2005). Previously, it computed a function
that is now implemented in
<code class="xref py py-func docutils literal notranslate"><span class="pre">control.fidcomp.FidCompUnitary.get_fidelity</span></code>.
The definition of state fidelity that the process fidelity is based on
is the one from R. Jozsa, Journal of Modern Optics, 41:12, 2315 (1994).
It is the square of the one implemented in
<a class="reference internal" href="#qutip.core.metrics.fidelity" title="qutip.core.metrics.fidelity"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.metrics.fidelity</span></code></a> which follows Nielsen &amp; Chuang,
“Quantum Computation and Quantum Information”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.tracedist">
<span class="sig-name descname"><span class="pre">tracedist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#tracedist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.tracedist" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, “Quantum Computation and Quantum Information”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong><span class="classifier">qobj</span></dt><dd><p>Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">{False, True}</span></dt><dd><p>Use sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tracedist</strong><span class="classifier">float</span></dt><dd><p>Trace distance between A and B.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="mf">0.9705143161472971</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.core.metrics.unitarity">
<span class="sig-name descname"><span class="pre">unitarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oper</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/metrics.html#unitarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.metrics.unitarity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unitarity of a quantum map, defined as the Frobenius norm
of the unital block of that map’s superoperator representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>oper</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum map under consideration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">float</span></dt><dd><p>Unitarity of <code class="docutils literal notranslate"><span class="pre">oper</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.continuous_variables">
<span id="continuous-variables"></span><h3>Continuous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this heading"></a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.correlation_matrix">
<span class="sig-name descname"><span class="pre">correlation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math notranslate nohighlight">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.correlation_matrix_field">
<span class="sig-name descname"><span class="pre">correlation_matrix_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the correlation matrix for given field operators <span class="math notranslate nohighlight">\(a_1\)</span> and
<span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.correlation_matrix_quadrature">
<span class="sig-name descname"><span class="pre">correlation_matrix_quadrature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>Array of complex numbers or Qobj’s
A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.covariance_matrix">
<span class="sig-name descname"><span class="pre">covariance_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>List of operators that defines the basis for the covariance matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>symmetrized</strong><span class="classifier">bool {True, False}</span></dt><dd><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.logarithmic_negativity">
<span class="sig-name descname"><span class="pre">logarithmic_negativity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the logarithmic negativity given a symmetrized covariance
matrix, see <a class="reference internal" href="#qutip.continuous_variables.covariance_matrix" title="qutip.continuous_variables.covariance_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.continuous_variables.covariance_matrix</span></code></a>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>V</strong><span class="classifier"><em>2d array</em></span></dt><dd><p>The covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N</strong><span class="classifier">float</span></dt><dd><p>The logarithmic negativity for the two-mode Gaussian state
that is described by the the Wigner covariance matrix V.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.continuous_variables.wigner_covariance_matrix">
<span class="sig-name descname"><span class="pre">wigner_covariance_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the Wigner covariance matrix
<span class="math notranslate nohighlight">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math notranslate nohighlight">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math notranslate nohighlight">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a1</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong><span class="classifier">Qobj</span></dt><dd><p>Field operator for mode 2.</p>
</dd>
<dt><strong>R</strong><span class="classifier">ndarray</span></dt><dd><p>The quadrature correlation matrix.</p>
</dd>
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g ** 2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov_mat</strong><span class="classifier">ndarray</span></dt><dd><p>A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="measurement">
<h2>Measurement<a class="headerlink" href="#measurement" title="Permalink to this heading"></a></h2>
<section id="module-qutip.measurement">
<span id="measurement-of-quantum-states"></span><h3>Measurement of quantum states<a class="headerlink" href="#module-qutip.measurement" title="Permalink to this heading"></a></h3>
<p>Module for measuring quantum objects.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure" title="Permalink to this definition"></a></dt>
<dd><p>A dispatch method that provides measurement results handling both
observable style measurements and projector style measurements (POVMs and
PVMs).</p>
<p>For return signatures, please check:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qutip.measurement.measure_observable" title="qutip.measurement.measure_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_observable</span></code></a> for observable measurements.</p></li>
<li><p><a class="reference internal" href="#qutip.measurement.measure_povm" title="qutip.measurement.measure_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure_povm</span></code></a> for POVM measurements.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><ul class="simple">
<li><p>measurement observable (<a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>); or</p></li>
<li><p>list of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets (list of
<a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>) Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measure_observable">
<span class="sig-name descname"><span class="pre">measure_observable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure_observable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure_observable" title="Permalink to this definition"></a></dt>
<dd><p>Perform a measurement specified by an operator on the given state.</p>
<p>This function simulates the classic quantum measurement described in many
introductory texts on quantum mechanics. The measurement collapses the
state to one of the eigenstates of the given operator and the result of the
measurement is the corresponding eigenvalue.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>op</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The measurement operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>measured_value</strong><span class="classifier">float</span></dt><dd><p>The result of the measurement (one of the eigenvalues of op).</p>
</dd>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The new state (a ket if a ket was given, otherwise a density matrix).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Measure the z-component of the spin of the spin-up basis state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sigmaz</span><span class="p">())</span>
<span class="go">(1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[-1.]</span>
<span class="go"> [ 0.]])</span>
</pre></div>
</div>
<p>Since the spin-up basis is an eigenstate of sigmaz, this measurement always
returns 1 as the measurement result (the eigenvalue of the spin-up basis)
and the original state (up to a global phase).</p>
<p>Measure the x-component of the spin of the spin-down basis state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sigmax</span><span class="p">())</span>
<span class="go">(-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[-0.70710678]</span>
<span class="go"> [ 0.70710678]])</span>
</pre></div>
</div>
<p>This measurement returns 1 fifty percent of the time and -1 the other fifty
percent of the time. The new state returned is the corresponding eigenstate
of sigmax.</p>
<p>One may also perform a measurement on a density matrix. Below we perform
the same measurement as above, but on the density matrix representing the
pure spin-down state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure_observable</span><span class="p">(</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">sigmax</span><span class="p">())</span>
<span class="go">(-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5 -0.5]</span>
<span class="go"> [-0.5  0.5]])</span>
</pre></div>
</div>
<p>The measurement result is the same, but the new state is returned as a
density matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measure_povm">
<span class="sig-name descname"><span class="pre">measure_povm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measure_povm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measure_povm" title="Permalink to this definition"></a></dt>
<dd><p>Perform a measurement specified by list of POVMs.</p>
<p>This function simulates a POVM measurement. The measurement collapses the
state to one of the resultant states of the measurement and returns the
index of the operator corresponding to the collapsed state as well as the
collapsed state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>List of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets.  Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>index</strong><span class="classifier">float</span></dt><dd><p>The resultant index of the measurement.</p>
</dd>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The new state (a ket if a ket was given, otherwise a density matrix).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measurement_statistics">
<span class="sig-name descname"><span class="pre">measurement_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics" title="Permalink to this definition"></a></dt>
<dd><p>A dispatch method that provides measurement statistics handling both
observable style measurements and projector style measurements(POVMs and
PVMs).</p>
<p>For return signatures, please check:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qutip.measurement.measurement_statistics_observable" title="qutip.measurement.measurement_statistics_observable"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_observable</span></code></a> for observable measurements.</p></li>
<li><p><a class="reference internal" href="#qutip.measurement.measurement_statistics_povm" title="qutip.measurement.measurement_statistics_povm"><code class="xref py py-func docutils literal notranslate"><span class="pre">measurement_statistics_povm</span></code></a> for POVM measurements.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><ul class="simple">
<li><p>measurement observable (:class:.Qobj); or</p></li>
<li><p>list of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets (list of
<a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>) Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger * M_i\)</span></p></li>
<li><p>projection operators if ops correspond to projectors (s.t.
<span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measurement_statistics_observable">
<span class="sig-name descname"><span class="pre">measurement_statistics_observable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics_observable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics_observable" title="Permalink to this definition"></a></dt>
<dd><p>Return the measurement eigenvalues, eigenstates (or projectors) and
measurement probabilities for the given state and measurement operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>op</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The measurement operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>eigenvalues: list of float</dt><dd><p>The list of eigenvalues of the measurement operator.</p>
</dd>
<dt>eigenstates_or_projectors: list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></dt><dd><p>If the state was a ket, return the eigenstates of the measurement
operator. Otherwise return the projectors onto the eigenstates.</p>
</dd>
<dt>probabilities: list of float</dt><dd><p>The probability of measuring the state as being in the corresponding
eigenstate (and the measurement result being the corresponding
eigenvalue).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.measurement.measurement_statistics_povm">
<span class="sig-name descname"><span class="pre">measurement_statistics_povm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/measurement.html#measurement_statistics_povm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.measurement.measurement_statistics_povm" title="Permalink to this definition"></a></dt>
<dd><p>Returns measurement statistics (resultant states and probabilities) for a
measurement specified by a set of positive operator valued measurements on
a specified ket or density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The ket or density matrix specifying the state to measure.</p>
</dd>
<dt><strong>ops</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>List of measurement operators <span class="math notranslate nohighlight">\(M_i\)</span> or kets.  Either:</p>
<ol class="arabic simple">
<li><p>specifying a POVM s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger M_i\)</span></p></li>
<li><p>projection operators if ops correspond to
projectors (s.t. <span class="math notranslate nohighlight">\(E_i = M_i^\dagger = M_i\)</span>)</p></li>
<li><p>kets (transformed to projectors)</p></li>
</ol>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>collapsed_states</strong><span class="classifier">list of <a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The collapsed states obtained after measuring the qubits and obtaining
the qubit specified by the target in the state specified by the index.</p>
</dd>
<dt><strong>probabilities</strong><span class="classifier">list of floats</span></dt><dd><p>The probability of measuring a state in a the state specified by the
index.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this heading"></a></h2>
<section id="module-qutip.solver.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.solver.sesolve" title="Permalink to this heading"></a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.sesolve.sesolve">
<span class="sig-name descname"><span class="pre">sesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sesolve.html#sesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sesolve.sesolve" title="Permalink to this definition"></a></dt>
<dd><p>Schrodinger equation evolution of a state vector or unitary matrix
for a given Hamiltonian.</p>
<p>Evolve the state vector (<cite>psi0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system. Alternatively evolve a unitary matrix in
solving the Schrodinger operator equation.</p>
<p>The output is either the state vector or unitary matrix at arbitrary points
in time (<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values. e_ops cannot be used in conjunction
with solving the Schrodinger operator equation</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be a <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> or
object that can be interpreted as <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> such as a list of
(Qobj, Coefficient) pairs or a function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>initial state vector (ket)
or initial unitary operator <cite>psi0 = U</cite></p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, callable, or list.</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str [“adams”, “bdf”, “lsoda”, “dop853”, “vern9”, etc.]
Which differential equation integration method to use.</p></li>
<li><p>atol, rtol : float
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps :
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, 0
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-ode">Integrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
a <em>list of array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, and/or a <em>list</em> <cite>result.states</cite> of state vectors
or density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite>
is an empty list of <cite>store_states=True</cite> in options].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.solver.mesolve" title="Permalink to this heading"></a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.mesolve.mesolve">
<span class="sig-name descname"><span class="pre">mesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mesolve.html#mesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mesolve.mesolve" title="Permalink to this definition"></a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian or Liouvillian (<cite>H</cite>) and an optional set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows the solution of master equations that are not in standard
Lindblad form.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be a <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> or
object that can be interpreted as <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> such as a list of
(Qobj, Coefficient) pairs or a function.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument. Many
ODE integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When no collapse operator are given and the <cite>H</cite> is not a superoperator,
it will defer to <code class="xref py py-func docutils literal notranslate"><span class="pre">sesolve</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. List of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of (<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format)</span></dt><dd><p>Single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators. None is equivalent to an empty list.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code> / callback function</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str [“adams”, “bdf”, “lsoda”, “dop853”, “vern9”, etc.]
Which differential equation integration method to use.</p></li>
<li><p>atol, rtol : float
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps :
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, 0
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-ode">Integrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
a <em>list of array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, and/or a <em>list</em> <cite>result.states</cite> of state vectors
or density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite>
is an empty list of <cite>store_states=True</cite> in options].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.solver.mcsolve" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.mcsolve">
<span class="sig-name descname"><span class="pre">mcsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mcsolve.html#mcsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mcsolve.mcsolve" title="Permalink to this definition"></a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators. Options for the
underlying ODE solver are given by the Options class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, callable.</span></dt><dd><p>System Hamiltonian as a Qobj, QobjEvo. It can also be any input type
that QobjEvo accepts (see <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code>’s documentation).
<code class="docutils literal notranslate"><span class="pre">H</span></code> can also be a superoperator (liouvillian) if some collapse
operators are to be treated deterministically.</p>
</dd>
<dt><strong>state</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial state vector.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>Times at which results are recorded.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators in any input type that QobjEvo accepts
(see <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code>’s documentation). They must be operators
even if <code class="docutils literal notranslate"><span class="pre">H</span></code> is a superoperator. If none are given, the solver will
defer to <code class="docutils literal notranslate"><span class="pre">sesolve</span></code> or <code class="docutils literal notranslate"><span class="pre">mesolve</span></code>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list, [optional]</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of operator as Qobj, QobjEvo or callable with signature of
(t, state: Qobj) for calculating expectation values. When no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>
are given, the solver will default to save the states.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Maximum number of trajectories to run. Can be cut short if a time limit
is passed with the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> keyword or if the target tolerance is
reached, see <code class="docutils literal notranslate"><span class="pre">target_tol</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool, [False]
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, NoneType, [None]
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, [‘text’]
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict, [{“chunk_size”: 10}]
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str {“adams”, “bdf”, “dop853”, “vern9”, etc.}, [“adams”]
Which differential equation integration method to use.</p></li>
<li><p>keep_runs_results : bool, [False]
Whether to store results from all trajectories or just store the
averages.</p></li>
<li><p>map : str {“serial”, “parallel”, “loky”}, [“serial”]
How to run the trajectories. “parallel” uses concurent module to run
in parallel while “loky” use the module of the same name to do so.</p></li>
<li><p>job_timeout : NoneType, int, [None]
Maximum time to compute one trajectory.</p></li>
<li><p>num_cpus : NoneType, int, [None]
Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p></li>
<li><p>norm_t_tol, norm_tol, norm_steps : float, float, int, [1e-6, 1e-4, 5]
Parameters used to find the collapse location. <code class="docutils literal notranslate"><span class="pre">norm_t_tol</span></code> and
<code class="docutils literal notranslate"><span class="pre">norm_tol</span></code> are the tolerance in time and norm respectively.
An error will be raised if the collapse could not be found within
<code class="docutils literal notranslate"><span class="pre">norm_steps</span></code> tries.</p></li>
<li><p>mc_corr_eps : float, [1e-10]
Small number used to detect non-physical collapse caused by numerical
imprecision.</p></li>
<li><p>atol, rtol : float, [1e-8, 1e-6]
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps : int [2500]
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, [0]
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
<li><p>improved_sampling : Bool
Whether to use the improved sampling algorithm from Abdelhafez et al.
PRA (2019)</p></li>
</ul>
</dd>
<dt><strong>seeds</strong><span class="classifier">int, SeedSequence, list, [optional]</span></dt><dd><p>Seed for the random number generator. It can be a single seed used to
spawn seeds for each trajectory or a list of seeds, one for each
trajectory. Seeds are saved in the result and they can be reused with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seeds</span><span class="o">=</span><span class="n">prev_result</span><span class="o">.</span><span class="n">seeds</span>
</pre></div>
</div>
</dd>
<dt><strong>target_tol</strong><span class="classifier">float, tuple, list, [optional]</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower than
this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife resampling.
<code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair of absolute and
relative tolerance, in that order. Lastly, it can be a list of pairs of
(atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float, [optional]</span></dt><dd><p>Maximum time for the evolution in second. When reached, no more
trajectories will be computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.McResult</span></code></span></dt><dd><p>Object storing all results from the simulation. Which results is saved
depends on the presence of <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> and the options used. <code class="docutils literal notranslate"><span class="pre">collapse</span></code>
and <code class="docutils literal notranslate"><span class="pre">photocurrent</span></code> is available to Monte Carlo simulation results.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-qutip.solver.nm_mcsolve"></span><dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.nm_mcsolve">
<span class="sig-name descname"><span class="pre">nm_mcsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops_and_rates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#nm_mcsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.nm_mcsolve" title="Permalink to this definition"></a></dt>
<dd><p>Monte-Carlo evolution corresponding to a Lindblad equation with “rates”
that may be negative. Usage of this function is analogous to <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code>,
but the <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> parameter is replaced by an <code class="docutils literal notranslate"><span class="pre">ops_and_rates</span></code> parameter
to allow for negative rates. Options for the underlying ODE solver are
given by the Options class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, callable.</span></dt><dd><p>System Hamiltonian as a Qobj, QobjEvo. It can also be any input type
that QobjEvo accepts (see <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code>’s documentation).
<code class="docutils literal notranslate"><span class="pre">H</span></code> can also be a superoperator (liouvillian) if some collapse
operators are to be treated deterministically.</p>
</dd>
<dt><strong>state</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial state vector.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>Times at which results are recorded.</p>
</dd>
<dt><strong>ops_and_rates</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of tuples <code class="docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">Gamma)</span></code>, where the Lindblad operator <code class="docutils literal notranslate"><span class="pre">L</span></code>
is a <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code> and <code class="docutils literal notranslate"><span class="pre">Gamma</span></code> represents the corresponding
rate, which is allowed to be negative. The Lindblad operators must be
operators even if <code class="docutils literal notranslate"><span class="pre">H</span></code> is a superoperator. If none are given, the
solver will defer to <code class="docutils literal notranslate"><span class="pre">sesolve</span></code> or <code class="docutils literal notranslate"><span class="pre">mesolve</span></code>. Each rate <code class="docutils literal notranslate"><span class="pre">Gamma</span></code>
may be just a number (in the case of a constant rate) or, otherwise,
specified using any format accepted by <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.coefficient</span></code>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list, [optional]</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of operator as Qobj, QobjEvo or callable with signature of
(t, state: Qobj) for calculating expectation values. When no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>
are given, the solver will default to save the states.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Maximum number of trajectories to run. Can be cut short if a time limit
is passed with the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> keyword or if the target tolerance is
reached, see <code class="docutils literal notranslate"><span class="pre">target_tol</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool, [False]
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, NoneType, [None]
Whether or not to store the state density matrices.
On <code class="docutils literal notranslate"><span class="pre">None</span></code> the states will be saved if no expectation operators are
given.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, [‘text’]
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict, [{“chunk_size”: 10}]
kwargs to pass to the progress_bar. Qutip’s bars use <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p></li>
<li><p>method : str {“adams”, “bdf”, “dop853”, “vern9”, etc.}, [“adams”]
Which differential equation integration method to use.</p></li>
<li><p>keep_runs_results : bool, [False]
Whether to store results from all trajectories or just store the
averages.</p></li>
<li><p>map : str {“serial”, “parallel”, “loky”}, [“serial”]
How to run the trajectories. “parallel” uses concurrent module to run
in parallel while “loky” use the module of the same name to do so.</p></li>
<li><p>job_timeout : NoneType, int, [None]
Maximum time to compute one trajectory.</p></li>
<li><p>num_cpus : NoneType, int, [None]
Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p></li>
<li><p>norm_t_tol, norm_tol, norm_steps : float, float, int, [1e-6, 1e-4, 5]
Parameters used to find the collapse location. <code class="docutils literal notranslate"><span class="pre">norm_t_tol</span></code> and
<code class="docutils literal notranslate"><span class="pre">norm_tol</span></code> are the tolerance in time and norm respectively.
An error will be raised if the collapse could not be found within
<code class="docutils literal notranslate"><span class="pre">norm_steps</span></code> tries.</p></li>
<li><p>mc_corr_eps : float, [1e-10]
Small number used to detect non-physical collapse caused by numerical
imprecision.</p></li>
<li><p>atol, rtol : float, [1e-8, 1e-6]
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps : int [2500]
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, [0]
Maximum length of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
<li><p>completeness_rtol, completeness_atol : float, float, [1e-5, 1e-8]
Parameters used in determining whether the given Lindblad operators
satisfy a certain completeness relation. If they do not, an
additional Lindblad operator is added automatically (with zero rate).</p></li>
<li><p>martingale_quad_limit : float or int, [100]
An upper bound on the number of subintervals used in the adaptive
integration of the martingale.</p></li>
</ul>
</dd>
<dt><strong>seeds</strong><span class="classifier">int, SeedSequence, list, [optional]</span></dt><dd><p>Seed for the random number generator. It can be a single seed used to
spawn seeds for each trajectory or a list of seeds, one for each
trajectory. Seeds are saved in the result and they can be reused with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seeds</span><span class="o">=</span><span class="n">prev_result</span><span class="o">.</span><span class="n">seeds</span>
</pre></div>
</div>
</dd>
<dt><strong>target_tol</strong><span class="classifier">float, tuple, list, [optional]</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower than
this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife resampling.
<code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair of absolute and
relative tolerance, in that order. Lastly, it can be a list of pairs of
(atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float, [optional]</span></dt><dd><p>Maximum time for the evolution in seconds. When reached, no more
trajectories will be computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.NmmcResult</span></code></span></dt><dd><p>Object storing all results from the simulation. Compared to a result
returned by <code class="docutils literal notranslate"><span class="pre">mcsolve</span></code>, this result contains the additional field
<code class="docutils literal notranslate"><span class="pre">trace</span></code> (and <code class="docutils literal notranslate"><span class="pre">runs_trace</span></code> if <code class="docutils literal notranslate"><span class="pre">store_final_state</span></code> is set). Note
that the states on the individual trajectories are not normalized. This
field contains the average of their trace, which will converge to one
in the limit of sufficiently many trajectories.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.krylovsolve">
<span id="krylov-subspace-solver"></span><h3>Krylov Subspace Solver<a class="headerlink" href="#module-qutip.solver.krylovsolve" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.krylovsolve.krylovsolve">
<span class="sig-name descname"><span class="pre">krylovsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">krylov_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/krylovsolve.html#krylovsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.krylovsolve.krylovsolve" title="Permalink to this definition"></a></dt>
<dd><p>Schrodinger equation evolution of a state vector for time independent
Hamiltonians using Krylov method.</p>
<p>Evolve the state vector (“psi0”) finding an approximation for the time
evolution operator of Hamiltonian (“H”) by obtaining the projection of
the time evolution operator on a set of small dimensional Krylov
subspaces (m &lt;&lt; dim(H)).</p>
<p>The output is either the state vector or unitary matrix at arbitrary points
in time (<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values. e_ops cannot be used in conjunction
with solving the Schrodinger operator equation</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>initial state vector (ket)
or initial unitary operator <cite>psi0 = U</cite></p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>krylov_dim: int</strong></dt><dd><p>Dimension of Krylov approximation subspaces used for the time
evolution approximation.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, callable, or list.</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>dictionary of parameters for time-dependent Hamiltonians</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool, [False]
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, [None]
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool, [True]
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, [“text”]
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict, [{“chunk_size”: 10}]
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>atol: float [1e-7]
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps : int [100]
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>min_step, max_step : float, [1e-5, 1e5]
Miniumum and maximum lenght of one internal step.</p></li>
<li><p>always_compute_step: bool [False]
If True, the step lenght is computed each time a new Krylov
subspace is computed. Otherwise it is computed only once when
creating the integrator.</p></li>
<li><p>sub_system_tol: float, [1e-7]
Tolerance to detect an happy breakdown. An happy breakdown happens
when the initial ket is in a subspace of the Hamiltonian smaller
than <code class="docutils literal notranslate"><span class="pre">krylov_dim</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
a <em>list of array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, and/or a <em>list</em> <cite>result.states</cite> of state vectors
or density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite>
is an empty list of <cite>store_states=True</cite> in options].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.brmesolve">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.solver.brmesolve" title="Permalink to this heading"></a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.brmesolve">
<span class="sig-name descname"><span class="pre">brmesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sec_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/brmesolve.html#brmesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.brmesolve.brmesolve" title="Permalink to this definition"></a></dt>
<dd><p>Solves for the dynamics of a system using the Bloch-Redfield master
equation, given an input Hamiltonian, Hermitian bath-coupling terms and
their associated spectral functions, as well as possible Lindblad collapse
operators.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. list of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>psi0: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for evaluating evolution</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list of (a_op, spectra)</span></dt><dd><p>Nested list of system operators that couple to the environment,
and the corresponding bath spectra.</p>
<dl>
<dt>a_op<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></span></dt><dd><p>The operator coupling to the environment. Must be hermitian.</p>
</dd>
<dt>spectra<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>, str, func</span></dt><dd><p>The corresponding bath spectral responce.
Can be a <cite>Coefficient</cite> using an ‘w’ args, a function of the
frequence or a string. Coefficient build from a numpy array are
understood as a function of <code class="docutils literal notranslate"><span class="pre">w</span></code> instead of <code class="docutils literal notranslate"><span class="pre">t</span></code>. Function are
expected to be of the signature <code class="docutils literal notranslate"><span class="pre">f(w)</span></code> or <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">w,</span> <span class="pre">**args)</span></code>.</p>
<p>The spectra function can depend on <code class="docutils literal notranslate"><span class="pre">t</span></code> if the corresponding
<code class="docutils literal notranslate"><span class="pre">a_op</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_ops</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="p">(</span><span class="s1">&#39;w&gt;0&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})),</span>
    <span class="p">(</span><span class="n">QobjEvo</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="s1">&#39;w &gt; exp(-t)&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">QobjEvo</span><span class="p">([</span><span class="n">b</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="o">...</span><span class="p">]),</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="o">...</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">SpectraCoefficient</span><span class="p">(</span><span class="n">coefficient</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">tlist</span><span class="o">=</span><span class="n">ws</span><span class="p">))),</span>
<span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code> / callback function</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of (<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format)</span></dt><dd><p>List of collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of parameters for time-dependent Hamiltonians and
collapse operators. The key <code class="docutils literal notranslate"><span class="pre">w</span></code> is reserved for the spectra function.</p>
</dd>
<dt><strong>sec_cutoff</strong><span class="classifier">float {0.1}</span></dt><dd><p>Cutoff for secular approximation. Use <code class="docutils literal notranslate"><span class="pre">-1</span></code> if secular approximation
is not used when evaluating bath-coupling terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>tensor_type : str [‘sparse’, ‘dense’, ‘data’]
Which data type to use when computing the brtensor.
With a cutoff ‘sparse’ is usually the most efficient.</p></li>
<li><p>sparse_eigensolver : bool {False}
Whether to use the sparse eigensolver</p></li>
<li><p>method : str [“adams”, “bdf”, “lsoda”, “dop853”, “vern9”, etc.]
Which differential equation integration method to use.</p></li>
<li><p>atol, rtol : float
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps :
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, 0
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-ode">Integrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.solver.floquet" title="Permalink to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FMESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">floquet_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver" title="Permalink to this definition"></a></dt>
<dd><p>Solver for the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Operators (<code class="docutils literal notranslate"><span class="pre">c_ops</span></code> and <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>) are in the laboratory basis.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>floquet_basis</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.FloquetBasis</span></code></span></dt><dd><p>The system Hamiltonian wrapped in a FloquetBasis object. Choosing a
different integrator for the <code class="docutils literal notranslate"><span class="pre">floquet_basis</span></code> than for the evolution
of the floquet state can improve the performance.</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list of tuple(<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>, callable)</span></dt><dd><p>List of collapse operators and the corresponding function for the noise
power spectrum. The collapse operator must be a <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code> and
cannot be time dependent. The spectrum function must take and return
an numpy array.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature of the environment in units of Hamiltonian frequency.</p>
</dd>
<dt><strong>kmax</strong><span class="classifier">int [5]</span></dt><dd><p>The truncation of the number of sidebands..</p>
</dd>
<dt><strong>nT</strong><span class="classifier">int [20*kmax]</span></dt><dd><p>The number of integration steps (for calculating X) within one period.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">FMESolver.options</span></code> and
<a class="reference external" href="./classes.html#classes-ode">Integrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.resultclass">
<span class="sig-name descname"><span class="pre">resultclass</span></span><a class="headerlink" href="#qutip.solver.floquet.FMESolver.resultclass" title="Permalink to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">FloquetResult</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the evolution of the quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state0</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Each times of the list must be increasing, but does not
need to be uniformy distributed.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether the initial state in the floquet basis or laboratory basis.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Not supported</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list {None}</span></dt><dd><p>List of Qobj, QobjEvo or callable to compute the expectation
values. Function[s] must have the signature
f(t : float, state : Qobj) -&gt; expect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.FloquetResult</span></code></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.
<code class="docutils literal notranslate"><span class="pre">options</span></code> for the evolutions are read at this step.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether the initial state is in the floquet basis or laboratory
basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional {True}</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether to return the state in the floquet basis or laboratory
basis.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Not supported</p>
</dd>
<dt><strong>.. note::</strong></dt><dd><p>The state must be initialized first by calling <code class="docutils literal notranslate"><span class="pre">start</span></code> or
<code class="docutils literal notranslate"><span class="pre">run</span></code>. If <code class="docutils literal notranslate"><span class="pre">run</span></code> is called, <code class="docutils literal notranslate"><span class="pre">step</span></code> will continue from the last
time and state obtained.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FloquetBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis" title="Permalink to this definition"></a></dt>
<dd><p>Utility to compute floquet modes and states.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>U</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propagator</span></code></span></dt><dd><p>The propagator of the Hamiltonian over one period.</p>
</dd>
<dt><strong>evecs</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>Matrix where each column is an initial Floquet mode.</p>
</dd>
<dt><strong>e_quasi</strong><span class="classifier">np.ndarray[float]</span></dt><dd><p>The quasi energies of the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.from_floquet_basis">
<span class="sig-name descname"><span class="pre">from_floquet_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">floquet_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.from_floquet_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.from_floquet_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform a ket or density matrix from the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>
to the lab basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>floquet_basis</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>Initial state in the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>. May be either a
ket or density matrix.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float [0]</span></dt><dd><p>The time at which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>The state in the lab basis. The return type is the same as the type
of the input state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.mode" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Floquet modes at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet mode.</p>
</dd>
<dt><strong>data</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to return the states as a single data matrix or a list of
ket states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>A list of Floquet states for the time <code class="docutils literal notranslate"><span class="pre">t</span></code> or the states as column
in a single matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.state">
<span class="sig-name descname"><span class="pre">state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.state" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the floquet states at time t.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>data</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to return the states as a single data matrix or a list of
ket states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>A list of Floquet states for the time <code class="docutils literal notranslate"><span class="pre">t</span></code> or the states as column
in a single matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.to_floquet_basis">
<span class="sig-name descname"><span class="pre">to_floquet_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.to_floquet_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.to_floquet_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform a ket or density matrix in the lab basis
to the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lab_basis</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>Initial state in the lab basis.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float [0]</span></dt><dd><p>The time at which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.Data</span></code></span></dt><dd><p>The state in the Floquet basis. The return type is the same as the
type of the input state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.floquet.floquet_tensor">
<span class="sig-name descname"><span class="pre">floquet_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectra_cb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#floquet_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.floquet_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Construct a tensor that represents the master equation in the floquet
basis.</p>
<p>Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Periodic Hamiltonian</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>list of collapse operators.</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list callback functions</span></dt><dd><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature in units of frequency.</p>
</dd>
<dt><strong>kmax</strong><span class="classifier">int</span></dt><dd><p>The truncation of the number of sidebands (default 5).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array</span></dt><dd><p>The Floquet-Markov master equation tensor <cite>R</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.floquet.fmmesolve">
<span class="sig-name descname"><span class="pre">fmmesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectra_cb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#fmmesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.fmmesolve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>Periodic system Hamiltonian as <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>. List of
[<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>rho0 / psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>List of collapse operators. Time dependent collapse operators are not
supported.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code> / callback function</span></dt><dd><p>List of operators for which to evaluate expectation values.
The states are reverted to the lab basis before applying the</p>
</dd>
<dt><strong>spectra_cb</strong><span class="classifier">list callback functions</span></dt><dd><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>The period of the time-dependence of the hamiltonian. The default value
‘None’ indicates that the ‘tlist’ spans a single period of the driving.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature of the environment in units of frequency.
For example, if the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion:</p>
<blockquote>
<div><p>temperature = 25e-3 # unit K
h = 6.626e-34
kB = 1.38e-23
args[‘w_th’] = temperature * (kB / h) * 2 * pi * 1e-9</p>
</div></blockquote>
</dd>
<dt><strong>args</strong><span class="classifier"><em>dictionary</em></span></dt><dd><p>Dictionary of parameters for time-dependent Hamiltonian</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>store_floquet_states : bool
Whether or not to store the density matrices in the floquet basis in
<code class="docutils literal notranslate"><span class="pre">result.floquet_states</span></code>.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str [“adams”, “bdf”, “lsoda”, “dop853”, “vern9”, etc.]
Which differential equation integration method to use.</p></li>
<li><p>atol, rtol : float
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps :
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, 0
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-ode">Integrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
the expectation values for the times specified by <cite>tlist</cite>, and/or the
state density matrices corresponding to the times.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.floquet.fsesolve">
<span class="sig-name descname"><span class="pre">fsesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#fsesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.fsesolve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>Periodic system Hamiltonian as <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>. List of
[<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>Initial state vector (ket). If an operator is provided,</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function, optional</span></dt><dd><p>List of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float, default=tlist[-1]</span></dt><dd><p>The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary, optional</span></dt><dd><p>Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the results.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></span></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.solver.stochastic" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.stochastic.smesolve">
<span class="sig-name descname"><span class="pre">smesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heterodyne</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/stochastic.html#smesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.stochastic.smesolve" title="Permalink to this definition"></a></dt>
<dd><p>Solve stochastic master equation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>rho0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of (<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format)</span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of (<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format)</span></dt><dd><p>List of stochastic collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, callable, or list.</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>Dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int [500]</span></dt><dd><p>Number of trajectories to compute.</p>
</dd>
<dt><strong>heterodyne</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to use heterodyne or homodyne detection.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">int, SeedSequence, list, [optional]</span></dt><dd><p>Seed for the random number generator. It can be a single seed used to
spawn seeds for each trajectory or a list of seeds, one for each
trajectory. Seeds are saved in the result and they can be reused with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seeds</span><span class="o">=</span><span class="n">prev_result</span><span class="o">.</span><span class="n">seeds</span>
</pre></div>
</div>
<p>When using a parallel map, the trajectories can be re-ordered.</p>
</dd>
<dt><strong>target_tol</strong><span class="classifier">{float, tuple, list}, optional</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower than
this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife resampling.
<code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair of absolute and
relative tolerance, in that order. Lastly, it can be a list of pairs of
<code class="docutils literal notranslate"><span class="pre">(atol,</span> <span class="pre">rtol)</span></code> for each e_ops.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float [optional]</span></dt><dd><p>Maximum time for the evolution in second. When reached, no more
trajectories will be computed. Overwrite the option of the same name.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool, [False]
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None, [None]
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>store_measurement: bool, [False]
Whether to store the measurement and wiener process for each
trajectories.</p></li>
<li><p>keep_runs_results : bool, [False]
Whether to store results from all trajectories or just store the
averages.</p></li>
<li><p>normalize_output : bool, [False]
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, [“text”]
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict, [{“chunk_size”: 10}]
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str, [“rouchon”]
Which stochastic differential equation integration method to use.
Main ones are {“euler”, “rouchon”, “platen”, “taylor1.5_imp”}</p></li>
<li><p>map : str {“serial”, “parallel”, “loky”}, [“serial”]
How to run the trajectories. “parallel” uses concurent module to run
in parallel while “loky” use the module of the same name to do so.</p></li>
<li><p>job_timeout : NoneType, int, [None]
Maximum time to compute one trajectory.</p></li>
<li><p>num_cpus : NoneType, int, [None]
Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p></li>
<li><p>dt : float [0.001 ~ 0.0001]
The finite steps lenght for the Stochastic integration method.
Default change depending on the integrator.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-sode">SIntegrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>output: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.stochastic.ssesolve">
<span class="sig-name descname"><span class="pre">ssesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heterodyne</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/stochastic.html#ssesolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.stochastic.ssesolve" title="Permalink to this definition"></a></dt>
<dd><p>Solve stochastic Schrodinger equation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial state vector (ket).</p>
</dd>
<dt><strong>tlist</strong><span class="classifier"><em>list</em> / <em>array</em></span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of (<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format)</span></dt><dd><p>List of stochastic collapse operators.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, callable, or list.</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / <em>dictionary</em></span></dt><dd><p>Dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int [500]</span></dt><dd><p>Number of trajectories to compute.</p>
</dd>
<dt><strong>heterodyne</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to use heterodyne or homodyne detection.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">int, SeedSequence, list, [optional]</span></dt><dd><p>Seed for the random number generator. It can be a single seed used to
spawn seeds for each trajectory or a list of seeds, one for each
trajectory. Seeds are saved in the result and they can be reused with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seeds</span><span class="o">=</span><span class="n">prev_result</span><span class="o">.</span><span class="n">seeds</span>
</pre></div>
</div>
</dd>
<dt><strong>target_tol</strong><span class="classifier">{float, tuple, list}, optional</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower than
this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife resampling.
<code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair of absolute and
relative tolerance, in that order. Lastly, it can be a list of pairs of
(atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float [optional]</span></dt><dd><p>Maximum time for the evolution in second. When reached, no more
trajectories will be computed. Overwrite the option of the same name.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None / dict</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool, [False]
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None, [None]
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>store_measurement: bool, [False]
Whether to store the measurement and wiener process, or brownian
noise for each trajectories.</p></li>
<li><p>keep_runs_results : bool, [False]
Whether to store results from all trajectories or just store the
averages.</p></li>
<li><p>normalize_output : bool, [False]
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, [“text”]
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict, [{“chunk_size”: 10}]
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>method : str, [“rouchon”]
Which stochastic differential equation integration method to use.
Main ones are {“euler”, “rouchon”, “platen”, “taylor1.5_imp”}</p></li>
<li><p>map : str {“serial”, “parallel”, “loky”}, [“serial”]
How to run the trajectories. “parallel” uses concurent module to run
in parallel while “loky” use the module of the same name to do so.</p></li>
<li><p>job_timeout : NoneType, int, [None]
Maximum time to compute one trajectory.</p></li>
<li><p>num_cpus : NoneType, int, [None]
Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p></li>
<li><p>dt : float [0.001 ~ 0.0001]
The finite steps lenght for the Stochastic integration method.
Default change depending on the integrator.</p></li>
</ul>
<p>Other options could be supported depending on the integration method,
see <a class="reference external" href="./classes.html#classes-sode">SIntegrator</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>output: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.heom">
<span id="hierarchical-equations-of-motion"></span><h3>Hierarchical Equations of Motion<a class="headerlink" href="#module-qutip.solver.heom" title="Permalink to this heading"></a></h3>
<p>This module provides solvers for system-bath evoluation using the
HEOM (hierarchy equations of motion).</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_equations_of_motion">https://en.wikipedia.org/wiki/Hierarchical_equations_of_motion</a> for a very
basic introduction to the technique.</p>
<p>The implementation is derived from the BoFiN library (see
<a class="reference external" href="https://github.com/tehruhn/bofin">https://github.com/tehruhn/bofin</a>) which was itself derived from an earlier
implementation in QuTiP itself.</p>
<p>For backwards compatibility with QuTiP 4.6 and below, a new version of
HSolverDL (the Drude-Lorentz specific HEOM solver) is provided. It is
implemented on top of the new HEOMSolver but should largely be a drop-in
replacement for the old HSolverDL.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.heom.heomsolve">
<span class="sig-name descname"><span class="pre">heomsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#heomsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.heomsolve" title="Permalink to this definition"></a></dt>
<dd><p>Hierarchical Equations of Motion (HEOM) solver that supports multiple
baths.</p>
<p>The baths must be all either bosonic or fermionic baths.</p>
<p>If you need to run many evolutions of the same system and bath, consider
using <a class="reference internal" href="classes.html#qutip.solver.heom.HEOMSolver" title="qutip.solver.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> directly to avoid having to continually
reconstruct the equation hierarchy for every evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. list of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>bath</strong><span class="classifier">Bath or list of Bath</span></dt><dd><p>A <a class="reference internal" href="classes.html#qutip.solver.heom.Bath" title="qutip.solver.heom.Bath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bath</span></code></a> containing the exponents of the expansion of the
bath correlation funcion and their associated coefficients
and coupling operators, or a list of baths.</p>
<p>If multiple baths are given, they must all be either fermionic
or bosonic baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the heirarchy (i.e. the maximum number of bath
exponent “excitations” to retain).</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code> or <a class="reference internal" href="classes.html#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a> or array-like</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">rho0</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code> the it is the initial state
of the system (i.e. a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code> density matrix).</p>
<p>If it is a <a class="reference internal" href="classes.html#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a> or array-like, then
<code class="docutils literal notranslate"><span class="pre">rho0</span></code> gives the initial state of all ADOs.</p>
<p>Usually the state of the ADOs would be determine from a previous
call to <code class="docutils literal notranslate"><span class="pre">.run(...)</span></code> with the solver results option <code class="docutils literal notranslate"><span class="pre">store_ados</span></code>
set to True. For example, <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">solver.run(...)</span></code> could be
followed by <code class="docutils literal notranslate"><span class="pre">solver.run(result.ado_states[-1],</span> <span class="pre">tlist)</span></code>.</p>
<p>If a numpy array-like is passed its shape must be
<code class="docutils literal notranslate"><span class="pre">(number_of_ados,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> where <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> is the system shape
(i.e. shape of the system density matrix) and the ADOs must
be in the same order as in <code class="docutils literal notranslate"><span class="pre">.ados.labels</span></code>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list</span></dt><dd><p>An ordered list of times at which to return the value of the state.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">Qobj / QobjEvo / callable / list / dict / None, optional</span></dt><dd><p>A list or dictionary of operators as <code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> and/or callable functions (they can be mixed) or
a single operator or callable function. For an operator <code class="docutils literal notranslate"><span class="pre">op</span></code>, the
result will be computed using <code class="docutils literal notranslate"><span class="pre">(state</span> <span class="pre">*</span> <span class="pre">op).tr()</span></code> and the state
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>. For callable functions, <code class="docutils literal notranslate"><span class="pre">f</span></code>, the result is
computed using <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">ado_state)</span></code>. The values are stored in the
<code class="docutils literal notranslate"><span class="pre">expect</span></code> and <code class="docutils literal notranslate"><span class="pre">e_data</span></code> attributes of the result (see the return
section below).</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the RHS for the evolution.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Generic solver options.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>store_ados : bool {False, True}
Whether or not to store the HEOM ADOs.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>progress_bar : str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}
How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p></li>
<li><p>progress_kwargs : dict
kwargs to pass to the progress_bar. Qutip’s bars use <cite>chunk_size</cite>.</p></li>
<li><p>state_data_type: str {‘dense’}
Name of the data type of the state used during the ODE evolution.
Use an empty string to keep the input state type. Many integrator can
only work with <cite>Dense</cite>.</p></li>
<li><p>method : str [“adams”, “bdf”, “lsoda”, “dop853”, “vern9”, etc.]
Which differential equation integration method to use.</p></li>
<li><p>atol, rtol : float
Absolute and relative tolerance of the ODE integrator.</p></li>
<li><p>nsteps :
Maximum number of (internally defined) steps allowed in one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
step.</p></li>
<li><p>max_step : float, 0
Maximum lenght of one internal step. When using pulses, it should be
less than half the width of the thinnest pulse.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><a class="reference internal" href="classes.html#qutip.solver.heom.HEOMResult" title="qutip.solver.heom.HEOMResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMResult</span></code></a></dt><dd><p>The results of the simulation run, with the following important
attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">times</span></code>: the times <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e. the <code class="docutils literal notranslate"><span class="pre">tlist</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">states</span></code>: the system state at each time <code class="docutils literal notranslate"><span class="pre">t</span></code> (only available
if <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> was <code class="docutils literal notranslate"><span class="pre">None</span></code> or if the solver option
<code class="docutils literal notranslate"><span class="pre">store_states</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ado_states</span></code>: the full ADO state at each time (only available
if the results option <code class="docutils literal notranslate"><span class="pre">ado_return</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>).
Each element is an instance of <a class="reference internal" href="classes.html#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a>.
The state of a particular ADO may be extracted from
<code class="docutils literal notranslate"><span class="pre">result.ado_states[i]</span></code> by calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expect</span></code>: a list containing the values of each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> at
time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">e_data</span></code>: a dictionary containing the values of each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>
at tme <code class="docutils literal notranslate"><span class="pre">t</span></code>. The keys are those given by <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> if it was
a dict, otherwise they are the indexes of the supplied <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>.</p></li>
</ul>
<p>See <a class="reference internal" href="classes.html#qutip.solver.heom.HEOMResult" title="qutip.solver.heom.HEOMResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMResult</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> for the complete
list of attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.solver.correlation" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.coherence_function_g1">
<span class="sig-name descname"><span class="pre">coherence_function_g1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#coherence_function_g1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.coherence_function_g1" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[g^{(1)}(\tau) =
\frac{\langle A^\dagger(\tau)A(0)\rangle}
{\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle
        \langle A^\dagger(0)A(0)\rangle}}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of {<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>}</span></dt><dd><p>List of collapse operators</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g1, G1</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.coherence_function_g2">
<span class="sig-name descname"><span class="pre">coherence_function_g2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#coherence_function_g2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.coherence_function_g2" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[ g^{(2)}(\tau) =
\frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}
{\langle A^\dagger(\tau)A(\tau)\rangle
 \langle A^\dagger(0)A(0)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators, may be time-dependent for solver choice of
<cite>me</cite>.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of arguments to be passed to solver.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g2, G2</strong><span class="classifier">tuple</span></dt><dd><p>The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.correlation_2op_1t">
<span class="sig-name descname"><span class="pre">correlation_2op_1t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#correlation_2op_1t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.correlation_2op_1t" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the two-operator one-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(\tau)B(0)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of {<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>}</span></dt><dd><p>List of collapse operators</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">ndarray</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#qutip.solver.correlation.correlation_3op" title="qutip.solver.correlation.correlation_3op"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlation_3op</span></code></a></dt><dd><p>Similar function supporting various solver types.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.correlation_2op_2t">
<span class="sig-name descname"><span class="pre">correlation_2op_2t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#correlation_2op_2t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.correlation_2op_2t" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <code class="docutils literal notranslate"><span class="pre">solver</span></code> parameter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one <code class="docutils literal notranslate"><span class="pre">tlist</span></code>
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>.
If <code class="docutils literal notranslate"><span class="pre">tlist</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">tlist=[0]</span></code> is assumed.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of {<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>}</span></dt><dd><p>List of collapse operators</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator B.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool {False}</span></dt><dd><p>If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">ndarray</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#qutip.solver.correlation.correlation_3op" title="qutip.solver.correlation.correlation_3op"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlation_3op</span></code></a></dt><dd><p>Similar function supporting various solver types.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.correlation_3op">
<span class="sig-name descname"><span class="pre">correlation_3op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#correlation_3op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.correlation_3op" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the three-operator two-time correlation function:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p>from a open system <code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code>.</p>
<p>Note: it is not possible to calculate a physically meaningful correlation
where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>solver</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MESolver</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BRSolver</span></code></span></dt><dd><p>Qutip solver for an open system.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>A, B, C: :class:`Qobj`, :class:`QobjEvo`, optional, default=None</strong></dt><dd><p>Operators <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code> from the equation <code class="docutils literal notranslate"><span class="pre">&lt;A(t)B(t+\tau)C(t)&gt;</span></code>
in the Schrodinger picture. They do not need to be all provided. For
exemple, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is not provided, <code class="docutils literal notranslate"><span class="pre">&lt;B(t+\tau)C(t)&gt;</span></code> is computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.correlation_3op_1t">
<span class="sig-name descname"><span class="pre">correlation_3op_1t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#correlation_3op_1t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.correlation_3op_1t" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(0)B(\tau)C(0)\right&gt;\)</span> along one time axis using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of {<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>}</span></dt><dd><p>List of collapse operators</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_vec</strong><span class="classifier">array</span></dt><dd><p>An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#qutip.solver.correlation.correlation_3op" title="qutip.solver.correlation.correlation_3op"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlation_3op</span></code></a></dt><dd><p>Similar function supporting various solver types.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.correlation.correlation_3op_2t">
<span class="sig-name descname"><span class="pre">correlation_3op_2t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taulist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'me'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/correlation.html#correlation_3op_2t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.correlation.correlation_3op_2t" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span> along two time axes using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>System Hamiltonian, may be time-dependent for solver choice of <cite>me</cite>.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If ‘state0’ is ‘None’, then the steady state will
be used as the initial state. The ‘steady-state’ is only implemented
if <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> are provided and the Hamiltonian is constant.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>.
If <code class="docutils literal notranslate"><span class="pre">tlist</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">tlist=[0]</span></code> is assumed.</p>
</dd>
<dt><strong>taulist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of {<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>}</span></dt><dd><p>List of collapse operators</p>
</dd>
<dt><strong>a_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator B.</p>
</dd>
<dt><strong>c_op</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></span></dt><dd><p>Operator C.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str {‘me’, ‘es’}</span></dt><dd><p>Choice of solver, <cite>me</cite> for master-equation, and <cite>es</cite> for exponential
series. <cite>es</cite> is equivalent to <cite>me</cite> with <code class="docutils literal notranslate"><span class="pre">options={&quot;method&quot;:</span> <span class="pre">&quot;diag&quot;}</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver. Only used with <cite>me</cite> solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corr_mat</strong><span class="classifier">array</span></dt><dd><p>An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#qutip.solver.correlation.correlation_3op" title="qutip.solver.correlation.correlation_3op"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlation_3op</span></code></a></dt><dd><p>Similar function supporting various solver types.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<span class="target" id="module-qutip.solver.spectrum"></span><dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.spectrum.spectrum">
<span class="sig-name descname"><span class="pre">spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'es'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/spectrum.html#spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.spectrum.spectrum" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt><dd><p>system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>List of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators.</p>
</dd>
<dt><strong>a_op</strong><span class="classifier">Qobj</span></dt><dd><p>Operator A.</p>
</dd>
<dt><strong>b_op</strong><span class="classifier">Qobj</span></dt><dd><p>Operator B.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>Choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse, <cite>solve</cite> for generic solver).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spectrum</strong><span class="classifier">array</span></dt><dd><p>An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.spectrum.spectrum_correlation_fft">
<span class="sig-name descname"><span class="pre">spectrum_correlation_fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/spectrum.html#spectrum_correlation_fft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.spectrum.spectrum_correlation_fft" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list/array of times <span class="math notranslate nohighlight">\(t\)</span> which the correlation function is given.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>list/array of correlations corresponding to time delays <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>inverse: boolean</strong></dt><dd><p>boolean parameter for using a positive exponent in the Fourier
Transform instead. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w, S</strong><span class="classifier">tuple</span></dt><dd><p>Returns an array of angular frequencies ‘w’ and the corresponding
two-sided power spectrum ‘S(w)’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.solver.steadystate" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.steadystate.pseudo_inverse">
<span class="sig-name descname"><span class="pre">pseudo_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhoss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'splu'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_rcm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/steadystate.html#pseudo_inverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.steadystate.pseudo_inverse" title="Permalink to this definition"></a></dt>
<dd><p>Compute the pseudo inverse for a Liouvillian superoperator, optionally
given its steady state density matrix (which will be computed if not
given).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>L</strong><span class="classifier">Qobj</span></dt><dd><p>A Liouvillian superoperator for which to compute the pseudo inverse.</p>
</dd>
<dt><strong>rhoss</strong><span class="classifier">Qobj</span></dt><dd><p>A steadystate density matrix as Qobj instance, for the Liouvillian
superoperator L.</p>
</dd>
<dt><strong>w</strong><span class="classifier">double</span></dt><dd><p>frequency at which to evaluate pseudo-inverse.  Can be zero for dense
systems and large sparse systems. Small sparse systems can fail for
zero frequencies.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Flag that indicate whether to use sparse or dense matrix methods when
computing the pseudo inverse.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string</span></dt><dd><p>Method used to compte matrix inverse.
Choice are ‘pinv’ to use scipy’s function of the same name, or a linear
system solver.
Default supported solver are:</p>
<ul class="simple">
<li><p>“solve”, “lstsq”
dense solver from numpy.linalg</p></li>
<li><p>“spsolve”, “gmres”, “lgmres”, “bicgstab”, “splu”
sparse solver from scipy.sparse.linalg</p></li>
<li><p>“mkl_spsolve”,
sparse solver by mkl.</p></li>
</ul>
<p>Extension to qutip, such as qutip-tensorflow, can use come with their
own solver. When <code class="docutils literal notranslate"><span class="pre">L</span></code> use these data backends, see the corresponding
libraries <code class="docutils literal notranslate"><span class="pre">linalg</span></code> for available solver.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dictionary</span></dt><dd><p>Additional keyword arguments for setting parameters for solver methods.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">Qobj</span></dt><dd><p>Returns a Qobj instance representing the pseudo inverse of L.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general the inverse of a sparse matrix will be dense.  If you
are applying the inverse to a density matrix then it is better to
cast the problem as an Ax=b type problem where the explicit calculation
of the inverse is not required. See page 67 of “Electrons in
nanostructures” C. Flindt, PhD Thesis available online:
<a class="reference external" href="https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/">https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/</a>
file_4732600/content</p>
<p>Note also that the definition of the pseudo-inverse herein is different
from numpys pinv() alone, as it includes pre and post projection onto
the subspace defined by the projector Q.</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.steadystate.steadystate">
<span class="sig-name descname"><span class="pre">steadystate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/steadystate.html#steadystate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.steadystate.steadystate" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the supplied
Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of
collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, default=’direct’</span></dt><dd><p>The allowed methods are composed of 2 parts, the steadystate method:
- “direct”: Solving <code class="docutils literal notranslate"><span class="pre">L(rho_ss)</span> <span class="pre">=</span> <span class="pre">0</span></code>
- “eigen” : Eigenvalue problem
- “svd” : Singular value decomposition
- “power” : Inverse-power method</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str, default=None</span></dt><dd><p>‘direct’ and ‘power’ methods only.
Solver to use when solving the <code class="docutils literal notranslate"><span class="pre">L(rho_ss)</span> <span class="pre">=</span> <span class="pre">0</span></code> equation.
Default supported solver are:</p>
<ul class="simple">
<li><p>“solve”, “lstsq”
dense solver from numpy.linalg</p></li>
<li><p>“spsolve”, “gmres”, “lgmres”, “bicgstab”
sparse solver from scipy.sparse.linalg</p></li>
<li><p>“mkl_spsolve”
sparse solver by mkl.</p></li>
</ul>
<p>Extension to qutip, such as qutip-tensorflow, can use come with their
own solver. When <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> use these data backends, see the
corresponding libraries <code class="docutils literal notranslate"><span class="pre">linalg</span></code> for available solver.</p>
<p>Extra options for these solver can be passed in <code class="docutils literal notranslate"><span class="pre">**kw</span></code>.</p>
</dd>
<dt><strong>use_rcm</strong><span class="classifier">bool, default False</span></dt><dd><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU
factorization of the Liouvillian.
Used with ‘direct’ or ‘power’ method.</p>
</dd>
<dt><strong>use_wbm</strong><span class="classifier">bool, default False</span></dt><dd><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only. Used with ‘direct’ or ‘power’ method.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.
Used with ‘direct’ method.</p>
</dd>
<dt><strong>power_tol</strong><span class="classifier">float, default 1e-12</span></dt><dd><p>Tolerance for the solution when using the ‘power’ method.</p>
</dd>
<dt><strong>power_maxiter</strong><span class="classifier">int, default 10</span></dt><dd><p>Maximum number of iteration to use when looking for a solution when
using the ‘power’ method.</p>
</dd>
<dt><strong>power_eps: double, default 1e-15</strong></dt><dd><p>Small weight used in the “power” method.</p>
</dd>
<dt><strong>sparse: bool</strong></dt><dd><p>Whether to use the sparse eigen solver with the “eigen” method
(default sparse).  With “direct” and “power” method, when the solver is
not specified, it is used to set whether “solve” or “spsolve” is
used as default solver.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra options to pass to the linear system solver. See the
documentation of the used solver in <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> or
<code class="docutils literal notranslate"><span class="pre">scipy.sparse.linalg</span></code> to see what extra arguments are supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Steady state density matrix.</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary containing solver-specific information about the solution.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.steadystate.steadystate_floquet">
<span class="sig-name descname"><span class="pre">steadystate_floquet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Op_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_it</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/steadystate.html#steadystate_floquet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.steadystate.steadystate_floquet" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Calculates the effective steady state for a driven</dt><dd><p>system with a time-dependent cosinusoidal term:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\mathcal{\hat{H}}(t) = \hat{H}_0 +
 \mathcal{\hat{O}} \cos(\omega_d t)\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H_0</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>A list of collapse operators.</p>
</dd>
<dt><strong>Op_t</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></span></dt><dd><p>The the interaction operator which is multiplied by the cosine</p>
</dd>
<dt><strong>w_d</strong><span class="classifier">float, default 1.0</span></dt><dd><p>The frequency of the drive</p>
</dd>
<dt><strong>n_it</strong><span class="classifier">int, default 3</span></dt><dd><p>The number of iterations for the solver</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, default False</span></dt><dd><p>Solve for the steady state using sparse algorithms.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str, default=None</span></dt><dd><p>Solver to use when solving the linear system.
Default supported solver are:</p>
<ul class="simple">
<li><p>“solve”, “lstsq”
dense solver from numpy.linalg</p></li>
<li><p>“spsolve”, “gmres”, “lgmres”, “bicgstab”
sparse solver from scipy.sparse.linalg</p></li>
<li><p>“mkl_spsolve”
sparse solver by mkl.</p></li>
</ul>
<p>Extensions to qutip, such as qutip-tensorflow, may provide their own solvers.
When <code class="docutils literal notranslate"><span class="pre">H_0</span></code> and <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> use these data backends, see their documentation
for the names and details of additional solvers they may provide.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Extra options to pass to the linear system solver. See the
documentation of the used solver in <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> or
<code class="docutils literal notranslate"><span class="pre">scipy.sparse.linalg</span></code> to see what extra arguments are supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dm</strong><span class="classifier">qobj</span></dt><dd><p>Steady state density matrix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See: Sze Meng Tan,
<a class="reference external" href="https://copilot.caltech.edu/documents/16743/qousersguide.pdf">https://copilot.caltech.edu/documents/16743/qousersguide.pdf</a>,
Section (10.16)</p>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.solver.propagator" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.propagator.propagator">
<span class="sig-name descname"><span class="pre">propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/propagator.html#propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.propagator.propagator" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math notranslate nohighlight">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math notranslate nohighlight">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> compatible format.</span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. <code class="docutils literal notranslate"><span class="pre">list</span></code> of [<code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> are also accepted.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float or array-like</span></dt><dd><p>Time or list of times for which to evaluate the propagator.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list, optional</span></dt><dd><p>List of Qobj or QobjEvo collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary, optional</span></dt><dd><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Extra parameters to use when creating the <code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code> from a list
format <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj, list</span></dt><dd><p>Instance representing the propagator(s) <span class="math notranslate nohighlight">\(U(t)\)</span>. Return a single
Qobj when <code class="docutils literal notranslate"><span class="pre">t</span></code> is a number or a list when <code class="docutils literal notranslate"><span class="pre">t</span></code> is a list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.propagator.propagator_steadystate">
<span class="sig-name descname"><span class="pre">propagator_steadystate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/propagator.html#propagator_steadystate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.propagator.propagator_steadystate" title="Permalink to this definition"></a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math notranslate nohighlight">\(U\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">qobj</span></dt><dd><p>Operator representing the propagator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">qobj</span></dt><dd><p>Instance representing the steady-state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.scattering">
<span id="scattering-in-quantum-optical-systems"></span><h3>Scattering in Quantum Optical Systems<a class="headerlink" href="#module-qutip.solver.scattering" title="Permalink to this heading"></a></h3>
<p>Photon scattering in quantum optical systems</p>
<p>This module includes a collection of functions for numerically computing photon
scattering in driven arbitrary systems coupled to some configuration of output
waveguides. The implementation of these functions closely follows the
mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent
Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.scattering.scattering_probability">
<span class="sig-name descname"><span class="pre">scattering_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_emissions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_zero_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">construct_effective_hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/scattering.html#scattering_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.scattering.scattering_probability" title="Permalink to this definition"></a></dt>
<dd><p>Compute the integrated probability of scattering n photons in an arbitrary
system. This function accepts a nonlinearly spaced array of times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from H and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photons emitted by the system (into any combination of
waveguides).</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest; tlist need not be
linearly spaced.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<cite>basis(systemDims, 0)</cite>.</p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and
c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scattering_prob</strong><span class="classifier">float</span></dt><dd><p>The probability of scattering n photons from the system over the time
range specified.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.scattering.temporal_basis_vector">
<span class="sig-name descname"><span class="pre">temporal_basis_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">waveguide_emission_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_time_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_emissions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/scattering.html#temporal_basis_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.scattering.temporal_basis_vector" title="Permalink to this definition"></a></dt>
<dd><p>Generate a temporal basis vector for emissions at specified time bins into
specified waveguides.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>waveguide_emission_indices</strong><span class="classifier">list or tuple</span></dt><dd><p>List of indices where photon emission occurs for each waveguide,
e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].</p>
</dd>
<dt><strong>n_time_bins</strong><span class="classifier">int</span></dt><dd><p>Number of time bins; the range over which each index can vary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>temporal_basis_vector</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>A basis vector representing photon scattering at the specified indices.
If there are W waveguides, T times, and N photon emissions, then the
basis vector has dimensionality (W*T)^N.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.scattering.temporal_scattered_state">
<span class="sig-name descname"><span class="pre">temporal_scattered_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_emissions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_zero_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">construct_effective_hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/scattering.html#temporal_scattered_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.scattering.temporal_scattered_state" title="Permalink to this definition"></a></dt>
<dd><p>Compute the scattered n-photon state projected onto the temporal basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">:class: qutip.Qobj or list</span></dt><dd><p>System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from <cite>H</cite> and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong><span class="classifier">int</span></dt><dd><p>Number of photon emissions to calculate.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span></p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest.</p>
</dd>
<dt><strong>system_zero_state</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>State representing zero excitations in the system. Defaults to
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span></p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong><span class="classifier">bool</span></dt><dd><p>Whether an effective Hamiltonian should be constructed from H and
c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>phi_n</strong><span class="classifier">:class: qutip.Qobj</span></dt><dd><p>The scattered bath state projected onto the temporal basis given by
tlist. If there are W waveguides, T times, and N photon emissions, then
the state is a tensor product state with dimensionality T^(W*N).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.piqs.piqs">
<span id="permutational-invariance"></span><h3>Permutational Invariance<a class="headerlink" href="#module-qutip.piqs.piqs" title="Permalink to this heading"></a></h3>
<p>Permutational Invariant Quantum Solver (PIQS)</p>
<p>This module calculates the Liouvillian for the dynamics of ensembles of
identical two-level systems (TLS) in the presence of local and collective
processes by exploiting permutational symmetry and using the Dicke basis.
It also allows to characterize nonlinear functions of the density matrix.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.am">
<span class="sig-name descname"><span class="pre">am</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#am"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.am" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the operator <code class="docutils literal notranslate"><span class="pre">am</span></code> used later.</p>
<p>The action of <code class="docutils literal notranslate"><span class="pre">ap</span></code> is given by:
<span class="math notranslate nohighlight">\(J_{-}\lvert j,m\rangle = A_{-}(jm)\lvert j,m-1\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j: float</strong></dt><dd><p>The value for j.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The value for m.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>a_minus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{-}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.ap">
<span class="sig-name descname"><span class="pre">ap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#ap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.ap" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the coefficient <code class="docutils literal notranslate"><span class="pre">ap</span></code> by applying <span class="math notranslate nohighlight">\(J_+\lvert j,m\rangle\)</span>.</p>
<p>The action of ap is given by:
<span class="math notranslate nohighlight">\(J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j, m: float</strong></dt><dd><p>The value for j and m in the dicke basis <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>a_plus: float</dt><dd><p>The value of <span class="math notranslate nohighlight">\(a_{+}\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.block_matrix">
<span class="sig-name descname"><span class="pre">block_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ones'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#block_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.block_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Construct the block-diagonal matrix for the Dicke basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of two-level systems.</p>
</dd>
<dt><strong>elements</strong><span class="classifier">str {‘ones’ (default),’degeneracy’}</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>block_matr</strong><span class="classifier">ndarray</span></dt><dd><p>A 2D block-diagonal matrix with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems. Filled with ones or the value of degeneracy
at each matrix element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.collapse_uncoupled">
<span class="sig-name descname"><span class="pre">collapse_uncoupled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#collapse_uncoupled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.collapse_uncoupled" title="Permalink to this definition"></a></dt>
<dd><p>Create the collapse operators (c_ops) of the Lindbladian in the
uncoupled basis</p>
<p>These operators are in the uncoupled basis of the two-level
system (TLS) SU(2) Pauli matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>c_ops: list</dt><dd><p>The list of collapse operators as <cite>qutip.Qobj</cite> for the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The collapse operator list can be given to <cite>qutip.mesolve</cite>.
Notice that the operators are placed in a Hilbert space of
dimension <span class="math notranslate nohighlight">\(2^N\)</span>. Thus the method is suitable only for
small N (of the order of 10).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.css">
<span class="sig-name descname"><span class="pre">css</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7071067811865475</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7071067811865475</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cartesian'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#css"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.css" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density matrix of the Coherent Spin State (CSS).</p>
<p>It can be defined as,
<span class="math notranslate nohighlight">\(\lvert CSS\rangle = \prod_i^N(a\lvert1\rangle_i+b\lvert0\rangle_i)\)</span>
with <span class="math notranslate nohighlight">\(a = sin(\frac{\theta}{2})\)</span>,
<span class="math notranslate nohighlight">\(b = e^{i \phi}\cos(\frac{\theta}{2})\)</span>.
The default basis is that of Dicke space
<span class="math notranslate nohighlight">\(\lvert j, m\rangle \langle j, m'\rvert\)</span>.
The default state is the symmetric CSS,
<span class="math notranslate nohighlight">\(\lvert CSS\rangle = \lvert+\rangle\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>x, y: float</strong></dt><dd><p>The coefficients of the CSS state.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
<dt><strong>coordinates: str</strong></dt><dd><p>Either “cartesian” or “polar”. If polar then the coefficients
are constructed as sin(x/2), cos(x/2)e^(iy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The CSS state density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.dicke">
<span class="sig-name descname"><span class="pre">dicke</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.dicke" title="Permalink to this definition"></a></dt>
<dd><p>Generate a Dicke state as a pure density matrix in the Dicke basis.</p>
<p>For instance, the superradiant state given by
<span class="math notranslate nohighlight">\(\lvert  j, m\rangle = \lvert 1, 0\rangle\)</span> for N = 2,
and the state is represented as a density matrix of size (nds, nds) or
(4, 4), with the (1, 1) element set to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>The eigenvalue j of the Dicke state (j, m).</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>The eigenvalue m of the Dicke state (j, m).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.dicke_basis">
<span class="sig-name descname"><span class="pre">dicke_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jmm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#dicke_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.dicke_basis" title="Permalink to this definition"></a></dt>
<dd><p>Initialize the density matrix of a Dicke state for several (j, m, m1).</p>
<p>This function can be used to build arbitrary states in the Dicke basis
<span class="math notranslate nohighlight">\(\lvert j, m\rangle\langle j, m'\rvert\)</span>. We create coefficients for
each (j, m, m1) value in the dictionary jmm1. The mapping for the (i, k)
index of the density matrix to the <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> values is
given by the cythonized function <cite>jmm1_dictionary</cite>. A density matrix is
created from the given dictionary of coefficients for each (j, m, m1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>jmm1: dict</strong></dt><dd><p>A dictionary of {(j, m, m1): p} that gives a density p for the
(j, m, m1) matrix element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>rho: :class: qutip.Qobj</dt><dd><p>The density matrix in the Dicke basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.dicke_blocks">
<span class="sig-name descname"><span class="pre">dicke_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#dicke_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.dicke_blocks" title="Permalink to this definition"></a></dt>
<dd><p>Create the list of blocks for block-diagonal density matrix in the Dicke basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>square_blocks: list of np.array</dt><dd><p>Give back the blocks list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.dicke_blocks_full">
<span class="sig-name descname"><span class="pre">dicke_blocks_full</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#dicke_blocks_full"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.dicke_blocks_full" title="Permalink to this definition"></a></dt>
<dd><p>Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>full_blocks</strong><span class="classifier">list</span></dt><dd><p>The list of blocks expanded in the 2^N space for N qubits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.dicke_function_trace">
<span class="sig-name descname"><span class="pre">dicke_function_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#dicke_function_trace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.dicke_function_trace" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the trace of a function on a Dicke density matrix.
:param f: A Taylor-expandable function of <cite>rho</cite>.
:type f: function
:param rho: A density matrix in the Dicke basis.
:type rho: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>res</strong><span class="classifier">float</span></dt><dd><p>Trace of a nonlinear function on <cite>rho</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.energy_degeneracy">
<span class="sig-name descname"><span class="pre">energy_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#energy_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.energy_degeneracy" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the number of Dicke states with same energy.</p>
<p>The use of the <cite>Decimals</cite> class allows to explore N &gt; 1000,
unlike the built-in function <cite>scipy.special.binom</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>Total spin z-axis projection eigenvalue.
This is proportional to the total energy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The energy degeneracy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.entropy_vn_dicke">
<span class="sig-name descname"><span class="pre">entropy_vn_dicke</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#entropy_vn_dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.entropy_vn_dicke" title="Permalink to this definition"></a></dt>
<dd><p>Von Neumann Entropy of a Dicke-basis density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>A 2D block-diagonal matrix of ones with dimension (nds,nds),
where nds is the number of Dicke states for N two-level
systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>entropy_dm: float</dt><dd><p>Entropy. Use degeneracy to multiply each block.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.excited">
<span class="sig-name descname"><span class="pre">excited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#excited"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.excited" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density matrix for the excited state.</p>
<p>This state is given by (N/2, N/2) in the default Dicke basis. If the
argument <cite>basis</cite> is “uncoupled” then it generates the state in a
2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The excited state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.ghz">
<span class="sig-name descname"><span class="pre">ghz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#ghz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.ghz" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density matrix of the GHZ state.</p>
<p>If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The GHZ state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.ground">
<span class="sig-name descname"><span class="pre">ground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#ground"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.ground" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density matrix of the ground state.</p>
<p>This state is given by (N/2, -N/2) in the Dicke basis. If the argument
<cite>basis</cite> is “uncoupled” then it generates the state in a
<span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The ground state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.identity_uncoupled">
<span class="sig-name descname"><span class="pre">identity_uncoupled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#identity_uncoupled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.identity_uncoupled" title="Permalink to this definition"></a></dt>
<dd><p>Generate the identity in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<p>The identity matrix is formed from the tensor product of N TLSs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>identity: :class: qutip.Qobj</dt><dd><p>The identity matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.isdiagonal">
<span class="sig-name descname"><span class="pre">isdiagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#isdiagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.isdiagonal" title="Permalink to this definition"></a></dt>
<dd><p>Check if the input matrix is diagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat: ndarray/Qobj</strong></dt><dd><p>A 2D numpy array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>diag: bool</dt><dd><p>True/False depending on whether the input matrix is diagonal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.jspin">
<span class="sig-name descname"><span class="pre">jspin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#jspin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.jspin" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the list of collective operators of the total algebra.</p>
<p>The Dicke basis <span class="math notranslate nohighlight">\(\lvert j,m\rangle\langle j,m'\rvert\)</span> is used by
default. Otherwise with “uncoupled” the operators are in a
<span class="math notranslate nohighlight">\(2^N\)</span> space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>Number of two-level systems.</p>
</dd>
<dt><strong>op: str</strong></dt><dd><p>The operator to return ‘x’,’y’,’z’,’+’,’-‘.
If no operator given, then output is the list of operators
for [‘x’,’y’,’z’].</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis of the operators - “dicke” or “uncoupled”
default: “dicke”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>j_alg: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> representing all the operators in
the “dicke” or “uncoupled” basis or a single operator requested.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.m_degeneracy">
<span class="sig-name descname"><span class="pre">m_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#m_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.m_degeneracy" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the number of Dicke states <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> with
same energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>m: float</strong></dt><dd><p>Total spin z-axis projection eigenvalue (proportional to the total
energy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The m-degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.num_dicke_ladders">
<span class="sig-name descname"><span class="pre">num_dicke_ladders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#num_dicke_ladders"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.num_dicke_ladders" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the total number of ladders in the Dicke space.</p>
<p>For a collection of N two-level systems it counts how many different
“j” exist or the number of blocks in the block-diagonal matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Nj: int</dt><dd><p>The number of Dicke ladders.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.num_dicke_states">
<span class="sig-name descname"><span class="pre">num_dicke_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#num_dicke_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.num_dicke_states" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the number of Dicke states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>nds: int</dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.num_tls">
<span class="sig-name descname"><span class="pre">num_tls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#num_tls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.num_tls" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the number of two-level systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nds: int</strong></dt><dd><p>The number of Dicke states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>N: int</dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.purity_dicke">
<span class="sig-name descname"><span class="pre">purity_dicke</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#purity_dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.purity_dicke" title="Permalink to this definition"></a></dt>
<dd><p>Calculate purity of a density matrix in the Dicke basis.
It accounts for the degenerate blocks in the density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Density matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>purity</strong><span class="classifier">float</span></dt><dd><p>The purity of the quantum state.
It’s 1 for pure states, 0&lt;=purity&lt;1 for mixed states.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.spin_algebra">
<span class="sig-name descname"><span class="pre">spin_algebra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#spin_algebra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.spin_algebra" title="Permalink to this definition"></a></dt>
<dd><p>Create the list [sx, sy, sz] with the spin operators.</p>
<p>The operators are constructed for a collection of N two-level systems
(TLSs). Each element of the list, i.e., sx, is a vector of <cite>qutip.Qobj</cite>
objects (spin matrices), as it cointains the list of the SU(2) Pauli
matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),
is placed in a <span class="math notranslate nohighlight">\(2^N\)</span>-dimensional Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>spin_operators: list or :class: qutip.Qobj</dt><dd><p>A list of <cite>qutip.Qobj</cite> operators - [sx, sy, sz] or the
requested operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>sx[i] is <span class="math notranslate nohighlight">\(\frac{\sigma_x}{2}\)</span> in the composite Hilbert space.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.state_degeneracy">
<span class="sig-name descname"><span class="pre">state_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#state_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.state_degeneracy" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the degeneracy of the Dicke state.</p>
<p>Each state <span class="math notranslate nohighlight">\(\lvert j, m\rangle\)</span> includes D(N,j) irreducible
representations <span class="math notranslate nohighlight">\(\lvert j, m, \alpha\rangle\)</span>.</p>
<p>Uses Decimals to calculate higher numerator and denominators numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>Total spin eigenvalue (cooperativity).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>degeneracy: int</dt><dd><p>The state degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.superradiant">
<span class="sig-name descname"><span class="pre">superradiant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dicke'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#superradiant"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.superradiant" title="Permalink to this definition"></a></dt>
<dd><p>Generate the density matrix of the superradiant state.</p>
<p>This state is given by (N/2, 0) or (N/2, 0.5) in the Dicke basis.
If the argument <cite>basis</cite> is “uncoupled” then it generates the state
in a 2**N dim Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>basis: str</strong></dt><dd><p>The basis to use. Either “dicke” or “uncoupled”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>state: :class: qutip.Qobj</dt><dd><p>The superradiant state density matrix in the requested basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.piqs.piqs.tau_column">
<span class="sig-name descname"><span class="pre">tau_column</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#tau_column"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.tau_column" title="Permalink to this definition"></a></dt>
<dd><p>Determine the column index for the non-zero elements of the matrix for a
particular row <cite>k</cite> and the value of <cite>j</cite> from the Dicke space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau: str</strong></dt><dd><p>The tau function to check for this <cite>k</cite> and <cite>j</cite>.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>The row of the matrix M for which the non zero elements have
to be calculated.</p>
</dd>
<dt><strong>j: float</strong></dt><dd><p>The value of <cite>j</cite> for this row.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this heading"></a></h2>
<section id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.wigner.qfunc">
<span class="sig-name descname"><span class="pre">qfunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><span class="pre">Qobj</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_memory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1024</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#qfunc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition"></a></dt>
<dd><p>Husimi-Q function of a given state vector or density matrix at phase-space
points <code class="docutils literal notranslate"><span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(xvec</span> <span class="pre">+</span> <span class="pre">i*yvec)</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="classes.html#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A state vector or density matrix.  This cannot have tensor-product
structure.</p>
</dd>
<dt><strong>xvec, yvec</strong><span class="classifier">array_like</span></dt><dd><p>x- and y-coordinates at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float, default sqrt(2)</span></dt><dd><p>Scaling factor for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">iy)</span></code>.  The value of <cite>g</cite> is
related to the value of <span class="math notranslate nohighlight">\(\hbar\)</span> in the commutation relation
<span class="math notranslate nohighlight">\([x,\,y] = i\hbar\)</span> via <span class="math notranslate nohighlight">\(\hbar=2/g^2\)</span>, so the default
corresponds to <span class="math notranslate nohighlight">\(\hbar=1\)</span>.</p>
</dd>
<dt><strong>precompute_memory</strong><span class="classifier">real, default 1024</span></dt><dd><p>Size in MB that may be used during calculations as working space when
dealing with density-matrix inputs.  This is ignored for state-vector
inputs.  The bound is not quite exact due to other, order-of-magnitude
smaller, intermediaries being necessary, but is a good approximation.
If you want to use the same iterative algorithm for density matrices
that is used for single kets, set <code class="docutils literal notranslate"><span class="pre">precompute_memory=None</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>Values representing the Husimi-Q function calculated over the specified
range <code class="docutils literal notranslate"><span class="pre">[xvec,</span> <span class="pre">yvec]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="classes.html#qutip.QFunc" title="qutip.wigner.QFunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QFunc</span></code></a></dt><dd><p>a class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.wigner.spin_q_function">
<span class="sig-name descname"><span class="pre">spin_q_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#spin_q_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.spin_q_function" title="Permalink to this definition"></a></dt>
<dd><p>The Husimi Q function for spins is defined as <code class="docutils literal notranslate"><span class="pre">Q(theta,</span> <span class="pre">phi)</span> <span class="pre">=</span>
<span class="pre">SCS.dag()</span> <span class="pre">*</span> <span class="pre">rho</span> <span class="pre">*</span> <span class="pre">SCS</span></code> for the spin coherent state <code class="docutils literal notranslate"><span class="pre">SCS</span> <span class="pre">=</span> <span class="pre">spin_coherent(</span>
<span class="pre">j,</span> <span class="pre">theta,</span> <span class="pre">phi)</span></code> where j is the spin length.
The implementation here is more efficient as it doesn’t
generate all of the SCS at theta and phi (see references).</p>
<p>The spin Q function is normal when integrated over the surface of the
sphere</p>
<div class="math notranslate nohighlight">
\[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta
Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>Polar (colatitude) angle at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>Azimuthal angle at which to calculate the Husimi-Q function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Q, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Husimi Q function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Lee Loh, Y., &amp; Kim, M. (2015). American J. of Phys., 83(1), 30–35.
<a class="reference external" href="https://doi.org/10.1119/1.4898595">https://doi.org/10.1119/1.4898595</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.wigner.spin_wigner">
<span class="sig-name descname"><span class="pre">spin_wigner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#spin_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.spin_wigner" title="Permalink to this definition"></a></dt>
<dd><p>Wigner function for a spin-j system.</p>
<p>The spin W function is normal when integrated over the surface of the
sphere</p>
<div class="math notranslate nohighlight">
\[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta
W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like</span></dt><dd><p>Polar (colatitude) angle at which to calculate the W function.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">array_like</span></dt><dd><p>Azimuthal angle at which to calculate the W function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W, THETA, PHI</strong><span class="classifier">2d-array</span></dt><dd><p>Values representing the spin Wigner function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.
<a class="reference external" href="https://doi.org/10.1103/PhysRevA.24.2889">https://doi.org/10.1103/PhysRevA.24.2889</a></p>
<p>[2] Dowling, J. P., Agarwal, G. S., &amp; Schleich, W. P. (1994).
Phys. Rev. A, 49(5), 4101–4109. <a class="reference external" href="https://doi.org/10.1103/PhysRevA.49.4101">https://doi.org/10.1103/PhysRevA.49.4101</a></p>
<p>[3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients
taken from Wikipedia (<a class="reference external" href="https://en.wikipedia.org/wiki/3-j_symbol">https://en.wikipedia.org/wiki/3-j_symbol</a>)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.wigner.wigner">
<span class="sig-name descname"><span class="pre">wigner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clenshaw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parfor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition"></a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float</span></dt><dd><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.
The value of <cite>g</cite> is related to the value of <cite>hbar</cite> in the commutation
relation <cite>[x, y] = i * hbar</cite> via <cite>hbar=2/g^2</cite> giving the default
value <cite>hbar=1</cite>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}</span></dt><dd><p>Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’
and ‘iterative’ use an iterative method to evaluate the Wigner functions for density
matrices <span class="math notranslate nohighlight">\(|m&gt;&lt;n|\)</span>, while ‘laguerre’ uses the Laguerre polynomials
in scipy for the same task. The ‘fft’ method evaluates the Fourier
transform of the density matrix. The ‘iterative’ method is default, and
in general recommended, but the ‘laguerre’ method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The ‘clenshaw’ method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50). ‘clenshaw’ is a fast and numerically stable method.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Tells the default solver whether or not to keep the input density
matrix in sparse format.  As the dimensions of the density matrix
grow, setthing this flag can result in increased performance.</p>
</dd>
<dt><strong>parfor</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Flag for calculating the Laguerre polynomial based Wigner function
method=’laguerre’ in parallel using the parfor function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array</span></dt><dd><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</dd>
<dt><strong>yvex</strong><span class="classifier">array</span></dt><dd><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘fft’ method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</section>
<section id="module-qutip.visualization">
<span id="graphs-and-visualization"></span><h3>Graphs and Visualization<a class="headerlink" href="#module-qutip.visualization" title="Permalink to this heading"></a></h3>
<p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.hinton">
<span class="sig-name descname"><span class="pre">hinton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_top</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#hinton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition"></a></dt>
<dd><p>Draws a Hinton diagram to visualize a density matrix or superoperator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier">qobj</span></dt><dd><p>Input density matrix or superoperator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hinton plots of superoperators are currently only
supported for qubits.</p>
</div>
</dd>
<dt><strong>x_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels to represent x basis of the input.</p>
</dd>
<dt><strong>y_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of y ticklabels to represent y basis of the input.</p>
</dd>
<dt><strong>color_style</strong><span class="classifier">string, default=”scaled”</span></dt><dd><p>Determines how colors are assigned to each square:</p>
<ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;scaled&quot;</span></code> (default), each color is chosen by
passing the absolute value of the corresponding matrix
element into <cite>cmap</cite> with the sign of the real part.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;threshold&quot;</span></code>, each square is plotted as
the maximum of <cite>cmap</cite> for the positive real part and as
the minimum for the negative part of the matrix element;
note that this generalizes <cite>“threshold”</cite> to complex numbers.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code>, each color is chosen according to
the angle of the corresponding matrix element.</p></li>
</ul>
</dd>
<dt><strong>label_top</strong><span class="classifier">bool, default=True</span></dt><dd><p>If True, x ticklabels will be placed on top, otherwise
they will appear below the plot.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The ax context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not a quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qutip</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">rand_dm</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">colorblind_safe</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">color_style</span><span class="o">=</span><span class="s2">&quot;threshold&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qutip</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">colorblind_safe</span> <span class="o">=</span> <span class="kc">False</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">hinton</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">color_style</span><span class="o">=</span><span class="s2">&quot;phase&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.matrix_histogram">
<span class="sig-name descname"><span class="pre">matrix_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition"></a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>M</strong><span class="classifier">Matrix of Qobj</span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>x_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels</p>
</dd>
<dt><strong>y_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of y ticklabels</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers, optional</span></dt><dd><p>The z-axis limits [min, max]</p>
</dd>
<dt><strong>bar_style</strong><span class="classifier">string, default=”real”</span></dt><dd><ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> (default), each bar is plotted
as the real part of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;img&quot;</span></code>, each bar is plotted
as the imaginary part of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;abs&quot;</span></code>, each bar is plotted
as the absolute value of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code> (default), each bar is plotted
as the angle of the corresponding matrix element</p></li>
</ul>
</dd>
<dt><strong>color_limits</strong><span class="classifier">list/array with two float numbers, optional</span></dt><dd><p>The limits of colorbar [min, max]</p>
</dd>
<dt><strong>color_style</strong><span class="classifier">string, default=”real”</span></dt><dd><p>Determines how colors are assigned to each square:</p>
<ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> (default), each color is chosen
according to the real part of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;img&quot;</span></code>, each color is chosen according to
the imaginary part of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;abs&quot;</span></code>, each color is chosen according to
the absolute value of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code>, each color is chosen according to
the angle of the corresponding matrix element.</p></li>
</ul>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>show colorbar</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary containing extra options for the plot.
The names (keys) and values of the options are
described below:</p>
<dl class="simple">
<dt>‘zticks’<span class="classifier">list of numbers, optional</span></dt><dd><p>A list of z-axis tick locations.</p>
</dd>
<dt>‘bars_spacing’<span class="classifier">float, default=0.1</span></dt><dd><p>spacing between bars.</p>
</dd>
<dt>‘bars_alpha’<span class="classifier">float, default=1.</span></dt><dd><p>transparency of bars, should be in range 0 - 1</p>
</dd>
<dt>‘bars_lw’<span class="classifier">float, default=0.5</span></dt><dd><p>linewidth of bars’ edges.</p>
</dd>
<dt>‘bars_edgecolor’<span class="classifier">color, default=’k’</span></dt><dd><p>The colors of the bars’ edges.
Examples: ‘k’, (0.1, 0.2, 0.5) or ‘#0f0f0f80’.</p>
</dd>
<dt>‘shade’<span class="classifier">bool, default=True</span></dt><dd><p>Whether to shade the dark sides of the bars (True) or not (False).
The shading is relative to plot’s source of light.</p>
</dd>
<dt>‘azim’<span class="classifier">float, default=-35</span></dt><dd><p>The azimuthal viewing angle.</p>
</dd>
<dt>‘elev’<span class="classifier">float, default=35</span></dt><dd><p>The elevation viewing angle.</p>
</dd>
<dt>‘stick’<span class="classifier">bool, default=False</span></dt><dd><p>Changes xlim and ylim in such a way that bars next to
XZ and YZ planes will stick to those planes.
This option has no effect if <code class="docutils literal notranslate"><span class="pre">ax</span></code> is passed as a parameter.</p>
</dd>
<dt>‘cbar_pad’<span class="classifier">float, default=0.04</span></dt><dd><p>The fraction of the original axes between the colorbar
and the new image axes.
(i.e. the padding between the 3D figure and the colorbar).</p>
</dd>
<dt>‘cbar_to_z’<span class="classifier">bool, default=False</span></dt><dd><p>Whether to set the color of maximum and minimum z-values to the
maximum and minimum colors in the colorbar (True) or not (False).</p>
</dd>
<dt>‘threshold’: float, optional</dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_energy_levels">
<span class="sig-name descname"><span class="pre">plot_energy_levels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy_levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition"></a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_list</strong><span class="classifier">List of Qobj</span></dt><dd><p>A list of Hamiltonians.</p>
</dd>
<dt><strong>h_lables</strong><span class="classifier">List of string, optional</span></dt><dd><p>A list of xticklabels for each Hamiltonian</p>
</dd>
<dt><strong>energy_levels</strong><span class="classifier">List of string, optional</span></dt><dd><p>A list of  yticklabels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int, default=0</span></dt><dd><p>The number of energy levels to plot</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_expectation_values">
<span class="sig-name descname"><span class="pre">plot_expectation_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition"></a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.
:param results: List of results objects returned by any of the QuTiP evolution solvers.
:type results: (list of) <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>
:param ylabels: The y-axis labels. List should be of the same length as <cite>results</cite>.
:type ylabels: list of strings, optional
:param fig: The Figure canvas in which the plot will be drawn.
:type fig: a matplotlib Figure instance, optional
:param axes: The axes context in which the plot will be drawn.
:type axes: (list of)  axes instances, optional</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fig, axes</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and array of axes instances
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_fock_distribution">
<span class="sig-name descname"><span class="pre">plot_fock_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_numbers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'green'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_y_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><cite>qutip.Qobj</cite></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fock_numbers</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels to represent fock numbers</p>
</dd>
<dt><strong>color</strong><span class="classifier">color or list of colors, default=”green”</span></dt><dd><p>The colors of the bar faces.</p>
</dd>
<dt><strong>unit_y_range</strong><span class="classifier">bool, default=True</span></dt><dd><p>Set y-axis limits [0, 1] or not</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_qubism">
<span class="sig-name descname"><span class="pre">plot_qubism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition"></a></dt>
<dd><p>Qubism plot for pure states of many qudits.  Works best for spin chains,
especially with even number of particles of the same dimension.  Allows to
see entanglement between first 2k particles and the rest.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>colorblind_safe does not apply because of its unique colormap</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ or ‘dark’, default=’light’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>how</strong><span class="classifier">‘pairs’, ‘pairs_skewed’ or ‘before_after’, default=’pairs’</span></dt><dd><p>Type of Qubism plotting.  Options:</p>
<ul class="simple">
<li><p>‘pairs’ - typical coordinates,</p></li>
<li><p>‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,</p></li>
<li><p>‘before_after’ - related to Schmidt plot (see also: plot_schmidt).</p></li>
</ul>
</dd>
<dt><strong>grid_iteration</strong><span class="classifier">int, default=1</span></dt><dd><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</dd>
<dt><strong>legend_iteration</strong><span class="classifier">int or ‘grid_iteration’ or ‘all’, default=0</span></dt><dd><p>Show labels for first <code class="docutils literal notranslate"><span class="pre">2*legend_iteration</span></code> particles.  Option
‘grid_iteration’ sets the same number of particles as for
grid_iteration.  Option ‘all’ makes label for all particles.  Typically
it should be 0, 1, 2 or perhaps 3.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See also <a class="reference internal" href="#r226a66bbc30b-1" id="id13">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r226a66bbc30b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">1</a><span class="fn-bracket">]</span></span>
<p>J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein
and G. Sierra, <em>Qubism: self-similar visualization of many-body
wavefunctions</em>, <a class="reference external" href="https://dx.doi.org/10.1088/1367-2630/14/5/053028">New J. Phys. 14 053028</a>, arXiv:1112.3560
(2012), open access.</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_schmidt">
<span class="sig-name descname"><span class="pre">plot_schmidt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(3,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition"></a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=’before_after’ for a similar plot.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>colorblind_safe does not apply because of its unique colormap</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ket</strong><span class="classifier">Qobj</span></dt><dd><p>Pure state for plotting.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ or ‘dark’, default=’light’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>splitting</strong><span class="classifier">int, optional</span></dt><dd><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</dd>
<dt><strong>labels_iteration</strong><span class="classifier">int or pair of ints, default=(3,2)</span></dt><dd><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_spin_distribution">
<span class="sig-name descname"><span class="pre">plot_spin_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">THETA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PHI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_spin_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Plots a spin distribution (given as meshgrid data).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>P</strong><span class="classifier">matrix</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate. Its range is between 0 and pi</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate. Its range is between 0 and 2*pi</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}, default=’2d’</strong></dt><dd><p>Specify whether the spin distribution function is to be plotted as a 2D
projection where the surface of the unit sphere is mapped on
the unit disk (‘2d’) or surface plot (‘3d’).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance, optional</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_wigner">
<span class="sig-name descname"><span class="pre">plot_wigner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clenshaw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition"></a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><cite>qutip.Qobj</cite></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like, optional</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like, optional</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’},</span></dt><dd><p>default=’clenshaw’
The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}, default=’2d’</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance, optional</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.plot_wigner_sphere">
<span class="sig-name descname"><span class="pre">plot_wigner_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wigner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Plots a coloured Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wigner</strong><span class="classifier">a wigner transformation</span></dt><dd><p>The wigner transformation at <cite>steps</cite> different theta and phi.</p>
</dd>
<dt><strong>reflections</strong><span class="classifier">bool, default=False</span></dt><dd><p>If the reflections of the sphere should be plotted as well.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The ax context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Special thanks to Russell P Rundle for writing this function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.visualization.sphereplot">
<span class="sig-name descname"><span class="pre">sphereplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/visualization.html#sphereplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition"></a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">array</span></dt><dd><p>Data set to be plotted</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle with respect to z-axis. Its range is between 0 and pi</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle in x-y plane. Its range is between 0 and 2*pi</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, output</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the axes instance or animation
instance used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-qutip.animation"></span><p>Functions to animate results of quantum dynamics simulations,</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_fock_distribution">
<span class="sig-name descname"><span class="pre">anim_fock_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_numbers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'green'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_y_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_fock_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_fock_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Animation of the Fock distribution for a density matrix (or ket)
that describes an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rhos</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fock_numbers</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels to represent fock numbers</p>
</dd>
<dt><strong>color</strong><span class="classifier">color or list of colors, default=”green”</span></dt><dd><p>The colors of the bar faces.</p>
</dd>
<dt><strong>unit_y_range</strong><span class="classifier">bool, default=True</span></dt><dd><p>Set y-axis limits [0, 1] or not</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_hinton">
<span class="sig-name descname"><span class="pre">anim_hinton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_top</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_hinton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_hinton" title="Permalink to this definition"></a></dt>
<dd><p>Draws an animation of Hinton diagram.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rhos</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Input density matrix or superoperator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hinton plots of superoperators are currently only
supported for qubits.</p>
</div>
</dd>
<dt><strong>x_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels to represent x basis of the input.</p>
</dd>
<dt><strong>y_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of y ticklabels to represent y basis of the input.</p>
</dd>
<dt><strong>color_style</strong><span class="classifier">string, default=”scaled”</span></dt><dd><p>Determines how colors are assigned to each square:</p>
<ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;scaled&quot;</span></code> (default), each color is chosen by
passing the absolute value of the corresponding matrix
element into <cite>cmap</cite> with the sign of the real part.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;threshold&quot;</span></code>, each square is plotted as
the maximum of <cite>cmap</cite> for the positive real part and as
the minimum for the negative part of the matrix element;
note that this generalizes <cite>“threshold”</cite> to complex numbers.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code>, each color is chosen according to
the angle of the corresponding matrix element.</p></li>
</ul>
</dd>
<dt><strong>label_top</strong><span class="classifier">bool, default=True</span></dt><dd><p>If True, x ticklabels will be placed on top, otherwise
they will appear below the plot.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The ax context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not a quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_matrix_histogram">
<span class="sig-name descname"><span class="pre">anim_matrix_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_matrix_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_matrix_histogram" title="Permalink to this definition"></a></dt>
<dd><p>Draw an animation of a histogram for the matrix M,
with the given x and y labels.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Ms</strong><span class="classifier">list of matrices or <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></span></dt><dd><p>The matrix to visualize</p>
</dd>
<dt><strong>x_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of x ticklabels</p>
</dd>
<dt><strong>y_basis</strong><span class="classifier">list of strings, optional</span></dt><dd><p>list of y ticklabels</p>
</dd>
<dt><strong>limits</strong><span class="classifier">list/array with two float numbers, optional</span></dt><dd><p>The z-axis limits [min, max]</p>
</dd>
<dt><strong>bar_style</strong><span class="classifier">string, default=”real”</span></dt><dd><ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> (default), each bar is plotted
as the real part of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;img&quot;</span></code>, each bar is plotted
as the imaginary part of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;abs&quot;</span></code>, each bar is plotted
as the absolute value of the corresponding matrix element</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code> (default), each bar is plotted
as the angle of the corresponding matrix element</p></li>
</ul>
</dd>
<dt><strong>color_limits</strong><span class="classifier">list/array with two float numbers, optional</span></dt><dd><p>The limits of colorbar [min, max]</p>
</dd>
<dt><strong>color_style</strong><span class="classifier">string, default=”real”</span></dt><dd><p>Determines how colors are assigned to each square:</p>
<ul class="simple">
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;real&quot;</span></code> (default), each color is chosen
according to the real part of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;img&quot;</span></code>, each color is chosen according to
the imaginary part of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;abs&quot;</span></code>, each color is chosen according to
the absolute value of the corresponding matrix element.</p></li>
<li><p>If set to <code class="docutils literal notranslate"><span class="pre">&quot;phase&quot;</span></code>, each color is chosen according to
the angle of the corresponding matrix element.</p></li>
</ul>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>show colorbar</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary containing extra options for the plot.
The names (keys) and values of the options are
described below:</p>
<dl class="simple">
<dt>‘zticks’<span class="classifier">list of numbers, optional</span></dt><dd><p>A list of z-axis tick locations.</p>
</dd>
<dt>‘bars_spacing’<span class="classifier">float, default=0.1</span></dt><dd><p>spacing between bars.</p>
</dd>
<dt>‘bars_alpha’<span class="classifier">float, default=1.</span></dt><dd><p>transparency of bars, should be in range 0 - 1</p>
</dd>
<dt>‘bars_lw’<span class="classifier">float, default=0.5</span></dt><dd><p>linewidth of bars’ edges.</p>
</dd>
<dt>‘bars_edgecolor’<span class="classifier">color, default=’k’</span></dt><dd><p>The colors of the bars’ edges.
Examples: ‘k’, (0.1, 0.2, 0.5) or ‘#0f0f0f80’.</p>
</dd>
<dt>‘shade’<span class="classifier">bool, default=True</span></dt><dd><p>Whether to shade the dark sides of the bars (True) or not (False).
The shading is relative to plot’s source of light.</p>
</dd>
<dt>‘azim’<span class="classifier">float, default=-35</span></dt><dd><p>The azimuthal viewing angle.</p>
</dd>
<dt>‘elev’<span class="classifier">float, default=35</span></dt><dd><p>The elevation viewing angle.</p>
</dd>
<dt>‘stick’<span class="classifier">bool, default=False</span></dt><dd><p>Changes xlim and ylim in such a way that bars next to
XZ and YZ planes will stick to those planes.
This option has no effect if <code class="docutils literal notranslate"><span class="pre">ax</span></code> is passed as a parameter.</p>
</dd>
<dt>‘cbar_pad’<span class="classifier">float, default=0.04</span></dt><dd><p>The fraction of the original axes between the colorbar
and the new image axes.
(i.e. the padding between the 3D figure and the colorbar).</p>
</dd>
<dt>‘cbar_to_z’<span class="classifier">bool, default=False</span></dt><dd><p>Whether to set the color of maximum and minimum z-values to the
maximum and minimum colors in the colorbar (True) or not (False).</p>
</dd>
<dt>‘threshold’: float, optional</dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Input argument is not valid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_qubism">
<span class="sig-name descname"><span class="pre">anim_qubism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pairs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_qubism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_qubism" title="Permalink to this definition"></a></dt>
<dd><p>Animation of Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.  Allows to see entanglement between first
2k particles and the rest.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>colorblind_safe does not apply because of its unique colormap</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>kets</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Pure states for animation.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ or ‘dark’, default=’light’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>how</strong><span class="classifier">‘pairs’, ‘pairs_skewed’ or ‘before_after’, default=’pairs’</span></dt><dd><p>Type of Qubism plotting.  Options:</p>
<ul class="simple">
<li><p>‘pairs’ - typical coordinates,</p></li>
<li><p>‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,</p></li>
<li><p>‘before_after’ - related to Schmidt plot (see also: plot_schmidt).</p></li>
</ul>
</dd>
<dt><strong>grid_iteration</strong><span class="classifier">int, default=1</span></dt><dd><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</dd>
<dt><strong>legend_iteration</strong><span class="classifier">int or ‘grid_iteration’ or ‘all’, default=0</span></dt><dd><p>Show labels for first <code class="docutils literal notranslate"><span class="pre">2*legend_iteration</span></code> particles.  Option
‘grid_iteration’ sets the same number of particles as for
grid_iteration.  Option ‘all’ makes label for all particles.  Typically
it should be 0, 1, 2 or perhaps 3.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See also <a class="reference internal" href="#rdc59b0ffadd7-1" id="id15">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdc59b0ffadd7-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">1</a><span class="fn-bracket">]</span></span>
<p>J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein
and G. Sierra, <em>Qubism: self-similar visualization of many-body
wavefunctions</em>, <a class="reference external" href="https://dx.doi.org/10.1088/1367-2630/14/5/053028">New J. Phys. 14 053028</a>, arXiv:1112.3560
(2012), open access.</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_schmidt">
<span class="sig-name descname"><span class="pre">anim_schmidt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'light'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(3,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_schmidt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_schmidt" title="Permalink to this definition"></a></dt>
<dd><p>Animation of Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=’before_after’ for a similar plot.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>colorblind_safe does not apply because of its unique colormap</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ket</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Pure states for animation.</p>
</dd>
<dt><strong>theme</strong><span class="classifier">‘light’ or ‘dark’, default=’light’</span></dt><dd><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>splitting</strong><span class="classifier">int, optional</span></dt><dd><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</dd>
<dt><strong>labels_iteration</strong><span class="classifier">int or pair of ints, default=(3,2)</span></dt><dd><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_sphereplot">
<span class="sig-name descname"><span class="pre">anim_sphereplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_sphereplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_sphereplot" title="Permalink to this definition"></a></dt>
<dd><p>animation of a matrices of values on a sphere</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">list of array instances</span></dt><dd><p>Data set to be plotted</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>Angle with respect to z-axis. Its range is between 0 and pi</p>
</dd>
<dt><strong>phi</strong><span class="classifier">float</span></dt><dd><p>Angle in x-y plane. Its range is between 0 and 2*pi</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_spin_distribution">
<span class="sig-name descname"><span class="pre">anim_spin_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">THETA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PHI</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_spin_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_spin_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Animation of a spin distribution (given as meshgrid data).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ps</strong><span class="classifier">list of matrices</span></dt><dd><p>Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the theta coordinate. Its range is between 0 and pi</p>
</dd>
<dt><strong>PHI</strong><span class="classifier">matrix</span></dt><dd><p>Meshgrid matrix for the phi coordinate. Its range is between 0 and 2*pi</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}, default=’2d’</strong></dt><dd><p>Specify whether the spin distribution function is to be plotted as a 2D
projection where the surface of the unit sphere is mapped on
the unit disk (‘2d’) or surface plot (‘3d’).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance, optional</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib figure instance, optional</span></dt><dd><p>The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axis instance, optional</span></dt><dd><p>The axis context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_wigner">
<span class="sig-name descname"><span class="pre">anim_wigner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clenshaw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_wigner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_wigner" title="Permalink to this definition"></a></dt>
<dd><p>Animation of the Wigner function for a density matrix (or ket)
that describes an oscillator mode.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rhos</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code> or list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>xvec</strong><span class="classifier">array_like, optional</span></dt><dd><p>x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong><span class="classifier">array_like, optional</span></dt><dd><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the ‘fft’ method.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’},</span></dt><dd><p>default=’clenshaw’
The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {‘2d’, ‘3d’}, default=’2d’</strong></dt><dd><p>Specify whether the Wigner function is to be plotted as a
contour graph (‘2d’) or surface plot (‘3d’).</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib cmap instance, optional</span></dt><dd><p>The colormap.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.animation.anim_wigner_sphere">
<span class="sig-name descname"><span class="pre">anim_wigner_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wigners</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/animation.html#anim_wigner_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.animation.anim_wigner_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Animate a coloured Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wigners</strong><span class="classifier">list of transformations</span></dt><dd><p>The wigner transformation at <cite>steps</cite> different theta and phi.</p>
</dd>
<dt><strong>reflections</strong><span class="classifier">bool, default=False</span></dt><dd><p>If the reflections of the sphere should be plotted as well.</p>
</dd>
<dt><strong>cmap</strong><span class="classifier">a matplotlib colormap instance, optional</span></dt><dd><p>Color map to use when plotting.</p>
</dd>
<dt><strong>colorbar</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether (True) or not (False) a colorbar should be attached.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">a matplotlib Figure instance, optional</span></dt><dd><p>The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">a matplotlib axes instance, optional</span></dt><dd><p>The ax context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ani</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and the animation instance
used to produce the figure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Special thanks to Russell P Rundle for writing this function.</p>
</dd></dl>

<span class="target" id="module-qutip.matplotlib_utilities"></span><p>This module contains utility functions that enhance Matplotlib
in one way or another.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.matplotlib_utilities.complex_phase_cmap">
<span class="sig-name descname"><span class="pre">complex_phase_cmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/matplotlib_utilities.html#complex_phase_cmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.matplotlib_utilities.complex_phase_cmap" title="Permalink to this definition"></a></dt>
<dd><p>Create a cyclic colormap for representing the phase of complex variables</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>cmap</dt><dd><p>A matplotlib linear segmented colormap.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.matplotlib_utilities.wigner_cmap">
<span class="sig-name descname"><span class="pre">wigner_cmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#09224F'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mid_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#FFFFFF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#530017'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#FF97D4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/matplotlib_utilities.html#wigner_cmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.matplotlib_utilities.wigner_cmap" title="Permalink to this definition"></a></dt>
<dd><p>A custom colormap that emphasizes negative values by creating a
nonlinear colormap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>W</strong><span class="classifier">array</span></dt><dd><p>Wigner function array, or any array.</p>
</dd>
<dt><strong>levels</strong><span class="classifier">int</span></dt><dd><p>Number of color levels to create.</p>
</dd>
<dt><strong>shift</strong><span class="classifier">float</span></dt><dd><p>Shifts the value at which Wigner elements are emphasized.
This parameter should typically be negative and small (i.e -1e-5).</p>
</dd>
<dt><strong>max_color</strong><span class="classifier">str</span></dt><dd><p>String for color corresponding to maximum value of data.  Accepts
any string format compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>mid_color</strong><span class="classifier">str</span></dt><dd><p>Color corresponding to zero values.  Accepts any string format
compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>min_color</strong><span class="classifier">str</span></dt><dd><p>Color corresponding to minimum data values.  Accepts any string format
compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>neg_color</strong><span class="classifier">str</span></dt><dd><p>Color that starts highlighting negative values.  Accepts any string
format compatible with the Matplotlib.colors.ColorConverter.</p>
</dd>
<dt><strong>invert</strong><span class="classifier">bool</span></dt><dd><p>Invert the color scheme for negative values so that smaller negative
values have darker color.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Returns a Matplotlib colormap instance for use in plotting.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘shift’ parameter allows you to vary where the colormap begins
to highlight negative colors. This is beneficial in cases where there
are small negative Wigner elements due to numerical round-off and/or
truncation.</p>
</dd></dl>

</section>
<section id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.tomography.qpt">
<span class="sig-name descname"><span class="pre">qpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_basis_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = unstack_columns(U * stack_columns(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U</strong><span class="classifier">Qobj</span></dt><dd><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</dd>
<dt><strong>op_basis_list</strong><span class="classifier">list</span></dt><dd><p>A list of Qobj’s representing the basis states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>QPT chi matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.tomography.qpt_plot">
<span class="sig-name descname"><span class="pre">qpt_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbls_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition"></a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">list of figure axis instance</span></dt><dd><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.tomography.qpt_plot_combined">
<span class="sig-name descname"><span class="pre">qpt_plot_combined</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lbls_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition"></a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chi</strong><span class="classifier">array</span></dt><dd><p>Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong><span class="classifier">list</span></dt><dd><p>List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong><span class="classifier">string</span></dt><dd><p>Plot title.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">figure instance</span></dt><dd><p>User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">figure axis instance</span></dt><dd><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt><dd><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-qutip.solver.nonmarkov.transfertensor">
<span id="non-markovian-solvers"></span><span id="functions-non-markov"></span><h2>Non-Markovian Solvers<a class="headerlink" href="#module-qutip.solver.nonmarkov.transfertensor" title="Permalink to this heading"></a></h2>
<p>This module contains an implementation of the non-Markovian transfer tensor
method (TTM), introduced in [1].</p>
<p>[1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.nonmarkov.transfertensor.ttmsolve">
<span class="sig-name descname"><span class="pre">ttmsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynmaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_learning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nonmarkov/transfertensor.html#ttmsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nonmarkov.transfertensor.ttmsolve" title="Permalink to this definition"></a></dt>
<dd><p>Expand time-evolution using the Transfer Tensor Method <a class="reference internal" href="#r8d0a586bf652-1" id="id18">[1]</a>, based on a set
of precomputed dynamical maps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>dynmaps</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code>, callable</span></dt><dd><p>List of precomputed dynamical maps (superoperators) for the first times
of <code class="docutils literal notranslate"><span class="pre">times</span></code> or a callback function that returns the superoperator at a
given time.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></span></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong><span class="classifier">array_like</span></dt><dd><p>List of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to compute results.
Must be uniformily spaced.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>, callable, or list.</span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values or callable or list of callable.
Callable signature must be, <cite>f(t: float, state: Qobj)</cite>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">expect</span></code> for more detail of operator expectation.</p>
</dd>
<dt><strong>num_learning</strong><span class="classifier">int</span></dt><dd><p>Number of times used to construct the dynmaps operators when
<code class="docutils literal notranslate"><span class="pre">dynmaps</span></code> is a callable.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dictionary</span></dt><dd><p>Dictionary of options for the solver.</p>
<ul class="simple">
<li><p>store_final_state : bool
Whether or not to store the final state of the evolution in the
result class.</p></li>
<li><p>store_states : bool, None
Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p></li>
<li><p>normalize_output : bool
Normalize output state to hide ODE numerical errors.</p></li>
<li><p>threshold : float
Threshold for halting. Halts if  <span class="math notranslate nohighlight">\(||T_{n}-T_{n-1}||\)</span> is below
treshold.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>output: <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></dt><dd><p>An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code>.</p>
</dd>
</dl>
<div role="list" class="citation-list">
<div class="citation" id="r8d0a586bf652-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">1</a><span class="fn-bracket">]</span></span>
<p>Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)
..</p>
</div>
</div>
</dd>
</dl>
</dd></dl>

</section>
<section id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this heading"></a></h2>
<section id="functions-utilities">
<span id="id19"></span><h3>Utility Functions<a class="headerlink" href="#functions-utilities" title="Permalink to this heading"></a></h3>
<span class="target" id="module-qutip.utilities"></span><p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.utilities.clebsch">
<span class="sig-name descname"><span class="pre">clebsch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#clebsch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j1</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 1.</p>
</dd>
<dt><strong>j2</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 2.</p>
</dd>
<dt><strong>j3</strong><span class="classifier">float</span></dt><dd><p>Total angular momentum 3.</p>
</dd>
<dt><strong>m1</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 1.</p>
</dd>
<dt><strong>m2</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 2.</p>
</dd>
<dt><strong>m3</strong><span class="classifier">float</span></dt><dd><p>z-component of angular momentum 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cg_coeff</strong><span class="classifier">float</span></dt><dd><p>Requested Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.utilities.convert_unit">
<span class="sig-name descname"><span class="pre">convert_unit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'meV'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'GHz'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#convert_unit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition"></a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the old unit.</p>
</dd>
<dt><strong>orig</strong><span class="classifier">string</span></dt><dd><p>The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
<dt><strong>to</strong><span class="classifier">string</span></dt><dd><p>The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>value_new_unit</strong><span class="classifier">float / array</span></dt><dd><p>The energy in the new unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.utilities.n_thermal">
<span class="sig-name descname"><span class="pre">n_thermal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/utilities.html#n_thermal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency ‘w’, at the temperature described by
‘w_th’ where <span class="math notranslate nohighlight">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>w</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Frequency of the oscillator.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier"><em>float</em></span></dt><dd><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>n_avg</strong><span class="classifier"><em>float</em> or <em>array</em></span></dt><dd><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.fileio.file_data_read">
<span class="sig-name descname"><span class="pre">file_data_read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#file_data_read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition"></a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of file containing reqested data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Seperator used to store data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Data from selected file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.fileio.file_data_store">
<span class="sig-name descname"><span class="pre">file_data_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'complex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numformat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'decimal'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#file_data_store"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition"></a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of data file to be stored, including extension.</p>
</dd>
<dt><strong>data: array_like</strong></dt><dd><p>Data to be written to file.</p>
</dd>
<dt><strong>numtype</strong><span class="classifier">str {‘complex, ‘real’}</span></dt><dd><p>Type of numerical data.</p>
</dd>
<dt><strong>numformat</strong><span class="classifier">str {‘decimal’,’exp’}</span></dt><dd><p>Format for written data.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str</span></dt><dd><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.fileio.qload">
<span class="sig-name descname"><span class="pre">qload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#qload"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition"></a></dt>
<dd><p>Loads data file from file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of data file to be loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>qobject</strong><span class="classifier">instance / array_like</span></dt><dd><p>Object retrieved from requested file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.fileio.qsave">
<span class="sig-name descname"><span class="pre">qsave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qutip_data'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/fileio.html#qsave"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition"></a></dt>
<dd><p>Saves given data to file named ‘filename.qu’ in current directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">instance/array_like</span></dt><dd><p>Input Python object to be stored.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str or pathlib.Path</span></dt><dd><p>Name of output data file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip.solver.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.solver.parallel" title="Permalink to this heading"></a></h3>
<p>This module provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing or the loky parallel
execution library.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.parallel.parallel_map">
<span class="sig-name descname"><span class="pre">parallel_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_kw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/parallel.html#parallel_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.parallel.parallel_map" title="Permalink to this definition"></a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">func (optional)</span></dt><dd><p>If provided, it will be called with the output of each tasks instead of
storing a them in a list. Note that the order in which results are
passed to <code class="docutils literal notranslate"><span class="pre">reduce_func</span></code> is not defined. It should return None or a
number. When returning a number, it represent the estimation of the
number of task left. On a return &lt;= 0, the map will end early.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">string</span></dt><dd><p>Progress bar options’s string for showing progress.</p>
</dd>
<dt><strong>progress_bar_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Options for the progress bar.</p>
</dd>
<dt><strong>map_kw: dict (optional)</strong></dt><dd><p>Dictionary containing entry for:
- timeout: float, Maximum time (sec) for the whole map.
- job_timeout: float, Maximum time (sec) for each job in the map.
- num_cpus: int, Number of job to run at once.
- fail_fast: bool, Raise an error at the first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for
each value in <code class="docutils literal notranslate"><span class="pre">values</span></code>. If a <code class="docutils literal notranslate"><span class="pre">reduce_func</span></code> is provided, and empty
list will be returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.solver.parallel.serial_map">
<span class="sig-name descname"><span class="pre">serial_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_kw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/parallel.html#serial_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.parallel.serial_map" title="Permalink to this definition"></a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>This function work as a drop-in replacement of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel_map</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task</strong><span class="classifier">a Python function</span></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong><span class="classifier">array / list</span></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong><span class="classifier">list / dictionary</span></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">func (optional)</span></dt><dd><p>If provided, it will be called with the output of each tasks instead of
storing a them in a list. It should return None or a number.
When returning a number, it represent the estimation of the number of
task left. On a return &lt;= 0, the map will end early.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">string</span></dt><dd><p>Progress bar options’s string for showing progress.</p>
</dd>
<dt><strong>progress_bar_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Options for the progress bar.</p>
</dd>
<dt><strong>map_kw: dict (optional)</strong></dt><dd><p>Dictionary containing:
- timeout: float, Maximum time (sec) for the whole map.
- fail_fast: bool, Raise an error at the first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>. If a <code class="docutils literal notranslate"><span class="pre">reduce_func</span></code> is provided, and empty list
will be returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="semidefinite-programming">
<span id="functions-ipython"></span><h3>Semidefinite Programming<a class="headerlink" href="#semidefinite-programming" title="Permalink to this heading"></a></h3>
</section>
<section id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-semidefinite"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this heading"></a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.ipynbtools.parallel_map">
<span class="sig-name descname"><span class="pre">parallel_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_scheduling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition"></a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">task</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">values</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>task: a Python function</strong></dt><dd><p>The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values: array / list</strong></dt><dd><p>The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args: list / dictionary</strong></dt><dd><p>The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs: list / dictionary</strong></dt><dd><p>The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt><dd><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt><dd><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt><dd><p>Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt><dd><p>Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">list</span></dt><dd><p>The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.ipynbtools.version_table">
<span class="sig-name descname"><span class="pre">version_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition"></a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>version_table: string</dt><dd><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="qutip.about">
<span class="sig-name descname"><span class="pre">about</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/about.html#about"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.about" title="Permalink to this definition"></a></dt>
<dd><p>About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,
and MatPlotLib.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qutip.simdiag">
<span class="sig-name descname"><span class="pre">simdiag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-14</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/simdiag.html#simdiag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneous diagonalization of commuting Hermitian matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ops</strong><span class="classifier">list/array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of qobjs representing commuting Hermitian
operators.</p>
</dd>
<dt><strong>evals</strong><span class="classifier">bool [True]</span></dt><dd><p>Whether to return the eigenvalues for each ops and eigenvectors or just
the eigenvectors.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float [1e-14]</span></dt><dd><p>Tolerance for detecting degenerate eigenstates.</p>
</dd>
<dt><strong>safe_mode</strong><span class="classifier">bool [True]</span></dt><dd><p>Whether to check that all ops are Hermitian and commuting. If set to
<code class="docutils literal notranslate"><span class="pre">False</span></code> and operators are not commuting, the eigenvectors returned
will often be eigenvectors of only the first operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigs</strong><span class="classifier">tuple</span></dt><dd><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="classes.html" class="btn btn-neutral float-left" title="Classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../changelog.html" class="btn btn-neutral float-right" title="Change Log" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Sep 07, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>