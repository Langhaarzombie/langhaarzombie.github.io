


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Classes &mdash; QuTiP 4.7 Documentation</title>
  

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../static/site.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script src="../static/jquery.js"></script>
        <script src="../static/underscore.js"></script>
        <script src="../static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}})</script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Functions" href="functions.html" />
    <link rel="prev" title="API documentation" href="apidoc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qobj">Qobj</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qobjevo">QobjEvo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eseries">eseries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bloch-sphere">Bloch sphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributions">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cubic-spline">Cubic Spline</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-markovian-solvers">Non-Markovian Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solver-options-and-results">Solver Options and Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="#permutational-invariance">Permutational Invariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#one-dimensional-lattice">One-Dimensional Lattice</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-functions">Distribution functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum information processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-control">Optimal control</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<span id="id1"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="qobj">
<span id="classes-qobj"></span><h2>Qobj<a class="headerlink" href="#qobj" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.Qobj">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Qobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isherm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">superrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isunitary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing quantum objects, such as quantum operators
and states.</p>
<p>The Qobj class is the QuTiP representation of quantum operators and state
vectors. This class also implements math operations +,-,* between Qobj
instances (and / by a C-number), as well as a collection of common
operator/state operations.  The Qobj constructor optionally takes a
dimension <code class="docutils literal notranslate"><span class="pre">list</span></code> and/or shape <code class="docutils literal notranslate"><span class="pre">list</span></code> as arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inpt</strong><span class="classifier">array_like</span></dt><dd><p>Data for vector/matrix representation of the quantum object.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of object used for tensor products.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list</span></dt><dd><p>Shape of underlying data structure (matrix shape).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool</span></dt><dd><p>Flag specifying whether Qobj should get a copy of the
input data, or use the original.</p>
</dd>
<dt><strong>fast</strong><span class="classifier">bool</span></dt><dd><p>Flag for fast qobj creation when running ode solvers.
This parameter is used internally only.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Sparse matrix characterizing the quantum object.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>List of dimensions keeping track of the tensor structure.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list</span></dt><dd><p>Shape of the underlying <cite>data</cite> array.</p>
</dd>
<dt><strong>type</strong><span class="classifier">str</span></dt><dd><p>Type of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,
‘operator-bra’, or ‘super’.</p>
</dd>
<dt><strong>superrep</strong><span class="classifier">str</span></dt><dd><p>Representation used if <cite>type</cite> is ‘super’. One of ‘super’
(Liouville form) or ‘choi’ (Choi matrix with tr = dimension).</p>
</dd>
<dt><strong>isherm</strong><span class="classifier">bool</span></dt><dd><p>Indicates if quantum object represents Hermitian operator.</p>
</dd>
<dt><strong>isunitary</strong><span class="classifier">bool</span></dt><dd><p>Indictaes if quantum object represents unitary operator.</p>
</dd>
<dt><strong>iscp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
completely positive (CP).</p>
</dd>
<dt><strong>ishp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
hermicity preserving (HP).</p>
</dd>
<dt><strong>istp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
trace preserving (TP).</p>
</dd>
<dt><strong>iscptp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map that is completely
positive and trace preserving (CPTP).</p>
</dd>
<dt><strong>isket</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a ket.</p>
</dd>
<dt><strong>isbra</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a bra.</p>
</dd>
<dt><strong>isoper</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents an operator.</p>
</dd>
<dt><strong>issuper</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a superoperator.</p>
</dd>
<dt><strong>isoperket</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents an operator in column vector
form.</p>
</dd>
<dt><strong>isoperbra</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents an operator in row vector
form.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>copy()</strong></p></td>
<td><p>Create copy of Qobj</p></td>
</tr>
<tr class="row-even"><td><p><strong>conj()</strong></p></td>
<td><p>Conjugate of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>cosm()</strong></p></td>
<td><p>Cosine of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>dag()</strong></p></td>
<td><p>Adjoint (dagger) of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>dnorm()</strong></p></td>
<td><p>Diamond norm of quantum operator.</p></td>
</tr>
<tr class="row-even"><td><p><strong>dual_chan()</strong></p></td>
<td><p>Dual channel of quantum object representing a CP map.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenenergies (eigenvalues) of a quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenenergies and eigenstates of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>expm()</strong></p></td>
<td><p>Matrix exponential of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>full(order=’C’)</strong></p></td>
<td><p>Returns dense array of quantum object <cite>data</cite> attribute.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>groundstate(sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenvalue and eigenket for the groundstate of a quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>inv()</strong></p></td>
<td><p>Return a Qobj corresponding to the matrix inverse of the operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>matrix_element(bra, ket)</strong></p></td>
<td><p>Returns the matrix element of operator between <cite>bra</cite> and <cite>ket</cite> vectors.</p></td>
</tr>
<tr class="row-even"><td><p><strong>norm(norm=’tr’, sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns norm of a ket or an operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>permute(order)</strong></p></td>
<td><p>Returns composite qobj with indices reordered.</p></td>
</tr>
<tr class="row-even"><td><p><strong>proj()</strong></p></td>
<td><p>Computes the projector for a ket or bra vector.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>ptrace(sel)</strong></p></td>
<td><p>Returns quantum object for selected dimensions after performing partial trace.</p></td>
</tr>
<tr class="row-even"><td><p><strong>sinm()</strong></p></td>
<td><p>Sine of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>sqrtm()</strong></p></td>
<td><p>Matrix square root of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>tidyup(atol=1e-12)</strong></p></td>
<td><p>Removes small elements from quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>tr()</strong></p></td>
<td><p>Trace of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>trans()</strong></p></td>
<td><p>Transpose of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>transform(inpt, inverse=False)</strong></p></td>
<td><p>Performs a basis transformation defined by <cite>inpt</cite> matrix.</p></td>
</tr>
<tr class="row-even"><td><p><strong>trunc_neg(method=’clip’)</strong></p></td>
<td><p>Removes negative eigenvalues and returns a new Qobj that is a valid density operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>unit(norm=’tr’, sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns normalized quantum object.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="qutip.Qobj.check_herm">
<code class="sig-name descname"><span class="pre">check_herm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.check_herm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.check_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the quantum object is hermitian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>isherm</strong><span class="classifier">bool</span></dt><dd><p>Returns the new value of isherm property.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.check_isunitary">
<code class="sig-name descname"><span class="pre">check_isunitary</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.check_isunitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.check_isunitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether qobj is a unitary matrix</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.conj">
<code class="sig-name descname"><span class="pre">conj</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.conj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate operator of quantum object.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create identical copy</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.cosm">
<code class="sig-name descname"><span class="pre">cosm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.cosm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.cosm" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of a quantum operator.</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Matrix cosine of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.dag">
<code class="sig-name descname"><span class="pre">dag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint operator of quantum object.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.diag">
<code class="sig-name descname"><span class="pre">diag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal elements of quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diags</strong><span class="classifier">array</span></dt><dd><p>Returns array of <code class="docutils literal notranslate"><span class="pre">real</span></code> values if operators is Hermitian,
otherwise <code class="docutils literal notranslate"><span class="pre">complex</span></code> values are returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.dnorm">
<code class="sig-name descname"><span class="pre">dnorm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.dnorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.dnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the diamond norm, or the diamond distance to another
operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> or None</span></dt><dd><p>If B is not None, the diamond distance d(A, B) = dnorm(A - B)
between this operator and B is returned instead of the diamond
norm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">float</span></dt><dd><p>Either the diamond norm of this operator, or the diamond distance
from this operator to B.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.dual_chan">
<code class="sig-name descname"><span class="pre">dual_chan</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.dual_chan"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.dual_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Dual channel of quantum object representing a completely positive
map.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.eigenenergies">
<code class="sig-name descname"><span class="pre">eigenenergies</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.eigenenergies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.eigenenergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenenergies of a quantum object.</p>
<p>Eigenenergies (eigenvalues) are defined for operators or superoperators
only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong><span class="classifier">str</span></dt><dd><p>Sort eigenvalues ‘low’ to high, or ‘high’ to low.</p>
</dd>
<dt><strong>eigvals</strong><span class="classifier">int</span></dt><dd><p>Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0=machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array</span></dt><dd><p>Array of eigenvalues for operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.eigenstates">
<code class="sig-name descname"><span class="pre">eigenstates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_fix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.eigenstates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.eigenstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenstates and eigenenergies.</p>
<p>Eigenstates and eigenenergies are defined for operators and
superoperators only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong><span class="classifier">str</span></dt><dd><p>Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.</p>
</dd>
<dt><strong>eigvals</strong><span class="classifier">int</span></dt><dd><p>Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
<dt><strong>phase_fix</strong><span class="classifier">int, None</span></dt><dd><p>If not None, set the phase of each kets so that ket[phase_fix,0]
is real positive.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array</span></dt><dd><p>Array of eigenvalues for operator.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array</span></dt><dd><p>Array of quantum operators representing the oprator eigenkets.
Order of eigenkets is determined by order of eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.eliminate_states">
<code class="sig-name descname"><span class="pre">eliminate_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.eliminate_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.eliminate_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new quantum object with states in state_inds eliminated.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states_inds</strong><span class="classifier">list of integer</span></dt><dd><p>The states that should be removed.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">True / False</span></dt><dd><p>Weather or not the new Qobj instance should be normalized (default
is False). For Qobjs that represents density matrices or state
vectors normalized should probably be set to True, but for Qobjs
that represents operators in for example an Hamiltonian, normalize
should be False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>q</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A new instance of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> that contains only the states
corresponding to indices that are <strong>not</strong> in <cite>state_inds</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.evaluate">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">evaluate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a time-dependent quantum object in list format. For
example,</p>
<blockquote>
<div><p>qobj_list = [H0, [H1, func_t]]</p>
</div></blockquote>
<p>is evaluated to</p>
<blockquote>
<div><p>Qobj(t) = H0 + H1 * func_t(t, args)</p>
</div></blockquote>
<p>and</p>
<blockquote>
<div><p>qobj_list = [H0, [H1, ‘sin(w * t)’]]</p>
</div></blockquote>
<p>is evaluated to</p>
<blockquote>
<div><p>Qobj(t) = H0 + H1 * sin(args[‘w’] * t)</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj_list</strong><span class="classifier">list</span></dt><dd><p>A nested list of Qobj instances and corresponding time-dependent
coefficients.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the time-dependent Qobj instance.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary</span></dt><dd><p>A dictionary with parameter values required to evaluate the
time-dependent Qobj intance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A Qobj instance that represents the value of qobj_list at time t.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.expm">
<code class="sig-name descname"><span class="pre">expm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dense'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.expm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.expm" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix exponential of quantum operator.</p>
<p>Input operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str {‘dense’, ‘sparse’}</span></dt><dd><p>Use set method to use to calculate the matrix exponentiation. The
available choices includes ‘dense’ and ‘sparse’.  Since the
exponential of a matrix is nearly always dense, method=’dense’
is set as default.s</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Exponentiated quantum operator.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum operator is not square.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.extract_states">
<code class="sig-name descname"><span class="pre">extract_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.extract_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.extract_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Qobj with states in state_inds only.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states_inds</strong><span class="classifier">list of integer</span></dt><dd><p>The states that should be kept.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">True / False</span></dt><dd><p>Weather or not the new Qobj instance should be normalized (default
is False). For Qobjs that represents density matrices or state
vectors normalized should probably be set to True, but for Qobjs
that represents operators in for example an Hamiltonian, normalize
should be False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>q</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A new instance of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> that contains only the states
corresponding to the indices in <cite>state_inds</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.full"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense array from quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">str {‘C’, ‘F’}</span></dt><dd><p>Return array in C (default) or Fortran ordering.</p>
</dd>
<dt><strong>squeeze</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Squeeze output array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>Array of complex data from quantum objects <cite>data</cite> attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.groundstate">
<code class="sig-name descname"><span class="pre">groundstate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.groundstate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.groundstate" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground state Eigenvalue and Eigenvector.</p>
<p>Defined for quantum operators or superoperators only.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
<dt><strong>safe</strong><span class="classifier">bool (default=True)</span></dt><dd><p>Check for degenerate ground state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eigval</strong><span class="classifier">float</span></dt><dd><p>Eigenvalue for the ground state of quantum operator.</p>
</dd>
<dt><strong>eigvec</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Eigenket for the ground state of quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.inv">
<code class="sig-name descname"><span class="pre">inv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.inv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix inverse of a quantum operator</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Matrix inverse of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.matrix_element">
<code class="sig-name descname"><span class="pre">matrix_element</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ket</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.matrix_element"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.matrix_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a matrix element.</p>
<p>Gives the matrix element for the quantum object sandwiched between a
<cite>bra</cite> and <cite>ket</cite> vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>bra</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object of type ‘bra’ or ‘ket’</p>
</dd>
<dt><strong>ket</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object of type ‘ket’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>elem</strong><span class="classifier">complex</span></dt><dd><p>Complex valued matrix element.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is slightly more computationally efficient to use a ket
vector for the ‘bra’ input.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of a quantum object.</p>
<p>Default norm is L2-norm for kets and trace-norm for operators.
Other ket and operator norms may be specified using the <cite>norm</cite> and
argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,
or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max
‘max’.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse eigenvalue solver for trace norm.  Other norms are not
affected by this parameter.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance for sparse solver (if used) for trace norm. The sparse
solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used)
for trace norm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">float</span></dt><dd><p>The requested norm of the operator or state quantum object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.overlap">
<code class="sig-name descname"><span class="pre">overlap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap between two state vectors or two operators.</p>
<p>Gives the overlap (inner product) between the current bra or ket Qobj
and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap
when one of the Qobj is an operator/density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object for a state vector of type ‘ket’, ‘bra’ or density
matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>overlap</strong><span class="classifier">complex</span></dt><dd><p>Complex valued overlap.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Can only calculate overlap between a bra, ket and density matrix
quantum objects.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Since QuTiP mainly deals with ket vectors, the most efficient inner
product call is the ket-ket version that computes the product
&lt;self|other&gt; with both vectors expressed as kets.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.permute">
<code class="sig-name descname"><span class="pre">permute</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.permute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutes a composite quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">list/array</span></dt><dd><p>List specifying new tensor order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>P</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Permuted quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.proj">
<code class="sig-name descname"><span class="pre">proj</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Form the projector from a given ket or bra vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Input bra or ket vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>P</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Projection operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.ptrace">
<code class="sig-name descname"><span class="pre">ptrace</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.ptrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.ptrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial trace of the quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sel</strong><span class="classifier">int/list</span></dt><dd><p>An <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of components to keep after partial trace.
The order is unimportant; no transposition will be done and the
spaces will remain in the same order in the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object representing partial trace with selected components
remaining.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is identical to the <a class="reference internal" href="functions.html#qutip.qobj.ptrace" title="qutip.qobj.ptrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qobj.ptrace</span></code></a> function
that has been deprecated.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.purity">
<code class="sig-name descname"><span class="pre">purity</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.purity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.purity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate purity of a quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state_purity</strong><span class="classifier">float</span></dt><dd><p>Returns the purity of a quantum object.
For a pure state, the purity is 1.
For a mixed state of dimension <cite>d</cite>, 1/d&lt;=purity&lt;1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.sinm">
<code class="sig-name descname"><span class="pre">sinm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.sinm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.sinm" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine of a quantum operator.</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Matrix sine of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.sqrtm">
<code class="sig-name descname"><span class="pre">sqrtm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.sqrtm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.sqrtm" title="Permalink to this definition">¶</a></dt>
<dd><p>Sqrt of a quantum operator.</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse eigenvalue/vector solver.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse solver (0 = machine precision).</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations used by sparse solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Matrix square root of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.tidyup">
<code class="sig-name descname"><span class="pre">tidyup</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.tidyup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.tidyup" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes small elements from the quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance used by tidyup. Default is set
via qutip global settings parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Quantum object with small elements removed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.tr">
<code class="sig-name descname"><span class="pre">tr</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.tr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.tr" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace of a quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trace</strong><span class="classifier">float</span></dt><dd><p>Returns the trace of the quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.trans">
<code class="sig-name descname"><span class="pre">trans</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposed operator.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Transpose of input operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis transform defined by input array.</p>
<p>Input array can be a <code class="docutils literal notranslate"><span class="pre">matrix</span></code> defining the transformation,
or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets that defines the new basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inpt</strong><span class="classifier">array_like</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">matrix</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets defining the transformation.</p>
</dd>
<dt><strong>inverse</strong><span class="classifier">bool</span></dt><dd><p>Whether to return inverse transformation.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse matrices when possible. Can be slower.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Operator in new basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is still in development.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.trunc_neg">
<code class="sig-name descname"><span class="pre">trunc_neg</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clip'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.trunc_neg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.trunc_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncates negative eigenvalues and renormalizes.</p>
<p>Returns a new Qobj by removing the negative eigenvalues
of this instance, then renormalizing to obtain a valid density
operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Algorithm to use to remove negative eigenvalues. “clip”
simply discards negative eigenvalues, then renormalizes.
“sgs” uses the SGS algorithm (doi:10/bb76) to find the
positive operator that is nearest in the Shatten 2-norm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A valid density operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.Qobj.unit">
<code class="sig-name descname"><span class="pre">unit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobj.html#Qobj.unit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.Qobj.unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Operator or state normalized to unity.</p>
<p>Uses norm from Qobj.norm().</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>Do an in-place normalization</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>Requested norm for states / operators.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse eigensolver for trace norm. Does not affect other norms.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse eigensolver.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Number of maximum iterations performed by sparse eigensolver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Normalized quantum object if not in-place,
else None.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="qobjevo">
<span id="classes-qobjevo"></span><h2>QobjEvo<a class="headerlink" href="#qobjevo" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.QobjEvo">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">QobjEvo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q_object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing time-dependent quantum objects, such as quantum
operators and states.</p>
<p>Basic math operations are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code> : <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, scalars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*</span></code>: <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, C number</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/</span></code> : C number</p></li>
</ul>
<p>This object is constructed by passing a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>
instances, each of which <em>may</em> have an associated scalar time dependence.
The list is summed to produce the final result.  In other words, if an
instance of this class is <span class="math notranslate nohighlight">\(Q(t)\)</span>, then it is constructed from a set
of constant:obj:<cite>~qutip.Qobj</cite> <span class="math notranslate nohighlight">\(\{Q_k\}\)</span> and time-dependent scalars
<span class="math notranslate nohighlight">\(f_k(t)\)</span> by</p>
<div class="math notranslate nohighlight">
\[Q(t) = \sum_k f_k(t) Q_k\]</div>
<p>If a scalar <span class="math notranslate nohighlight">\(f_k(t)\)</span> is not passed with a given <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>,
then that term is assumed to be constant.  The next section contains more
detail on the allowed forms of the constants, and gives several examples
for how to build instances of this class.</p>
<p><strong>Time-dependence formats</strong></p>
<p>There are three major formats for specifying a time-dependent scalar:</p>
<ul class="simple">
<li><p>Python function</p></li>
<li><p>string</p></li>
<li><p>array</p></li>
</ul>
<p>For function format, the function signature must be
<code class="docutils literal notranslate"><span class="pre">f(t:</span> <span class="pre">float,</span> <span class="pre">args:</span> <span class="pre">dict)</span> <span class="pre">-&gt;</span> <span class="pre">complex</span></code>, for example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f1_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;w1&quot;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">f2_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;w2&quot;</span><span class="p">])</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">([</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">f1_t</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">f2_t</span><span class="p">]],</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w1&quot;</span><span class="p">:</span><span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;w2&quot;</span><span class="p">:</span><span class="mf">2.</span><span class="p">})</span>
</pre></div>
</div>
<p>For string-based coeffients, the string must be a compilable python code
resulting in a complex. The following symbols are defined:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pi</span>   <span class="n">exp</span>   <span class="n">log</span>   <span class="n">log10</span>
<span class="n">erf</span>  <span class="n">zerf</span>  <span class="n">norm</span>  <span class="n">proj</span>
<span class="n">real</span> <span class="n">imag</span> <span class="n">conj</span> <span class="nb">abs</span> <span class="n">arg</span>
<span class="n">sin</span>  <span class="n">sinh</span>  <span class="n">asin</span>  <span class="n">asinh</span>
<span class="n">cos</span>  <span class="n">cosh</span>  <span class="n">acos</span>  <span class="n">acosh</span>
<span class="n">tan</span>  <span class="n">tanh</span>  <span class="n">atan</span>  <span class="n">atanh</span>
<span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">special</span> <span class="k">as</span> <span class="n">spe</span>
</pre></div>
</div>
<p>A couple more simple examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">([</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;exp(-1j*w1*t)&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="s1">&#39;cos(w2*t)&#39;</span><span class="p">]],</span>
            <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w1&quot;</span><span class="p">:</span><span class="mf">1.</span><span class="p">,</span><span class="s2">&quot;w2&quot;</span><span class="p">:</span><span class="mf">2.</span><span class="p">})</span>
</pre></div>
</div>
<p>For numpy array format, the array must be an 1d of dtype <code class="docutils literal notranslate"><span class="pre">np.float64</span></code> or
<code class="docutils literal notranslate"><span class="pre">np.complex128</span></code>.  A list of times (<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>) at which the
coeffients must be given as <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.  The coeffients array must have the
same length as the tlist.  The times of the tlist do not need to be
equidistant, but must be sorted.  By default, a cubic spline interpolation
will be used for the coefficient at time t.  If the coefficients are to be
treated as step functions, use the arguments
<code class="docutils literal notranslate"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">{&quot;_step_func_coeff&quot;:</span> <span class="pre">True}</span></code>.  Examples of array-format usage are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">([</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">tlist</span><span class="p">)],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tlist</span><span class="p">)]],</span>
            <span class="n">tlist</span><span class="o">=</span><span class="n">tlist</span><span class="p">)</span>
</pre></div>
</div>
<p>Mixing time formats is allowed.  It is not possible to create a single
<code class="docutils literal notranslate"><span class="pre">QobjEvo</span></code> that contains different <code class="docutils literal notranslate"><span class="pre">tlist</span></code> values, however.</p>
<p><strong>Passing arguments</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">args</span></code> is a dict of (name: object). The name must be a valid Python
identifier string, and in general the object can be any type that is
supported by the code to be compiled in the string.</p>
<p>There are some “magic” names that can be specified, whose objects will be
overwritten when used within <a class="reference internal" href="functions.html#qutip.sesolve.sesolve" title="qutip.sesolve.sesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">sesolve</span></code></a>, <a class="reference internal" href="functions.html#qutip.mesolve.mesolve" title="qutip.mesolve.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a> and
<a class="reference internal" href="functions.html#qutip.mcsolve.mcsolve" title="qutip.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a>.  This allows access to the solvers’ internal states, and
they are updated at every call.  The initial values of these dictionary
elements is unimportant.  The magic names available are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;state&quot;</span></code>: the current state as a <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;state_vec&quot;</span></code>: the current state as a column-stacked 1D <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;state_mat&quot;</span></code>: the current state as a 2D <code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;expect_op_&lt;n&gt;&quot;</span></code>: the current expectation value of the element
<code class="docutils literal notranslate"><span class="pre">e_ops[n]</span></code>, which is an argument to the solvers.  Replace <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;</span></code> with
an integer literal, e.g. <code class="docutils literal notranslate"><span class="pre">&quot;expect_op_0&quot;</span></code>.  This will be either real- or
complex-valued, depending on whether the state and operator are both
Hermitian or not.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;collapse&quot;</span></code>: (<a class="reference internal" href="functions.html#qutip.mcsolve.mcsolve" title="qutip.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a> only) a list of the collapses that have
occurred during the evolution.  Each element of the list is a 2-tuple
<code class="docutils literal notranslate"><span class="pre">(time:</span> <span class="pre">float,</span> <span class="pre">which:</span> <span class="pre">int)</span></code>, where <code class="docutils literal notranslate"><span class="pre">time</span></code> is the time this collapse
happened, and <code class="docutils literal notranslate"><span class="pre">which</span></code> is an integer indexing the <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> argument to
<a class="reference internal" href="functions.html#qutip.mcsolve.mcsolve" title="qutip.mcsolve.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcsolve</span></code></a>.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Q_object</strong><span class="classifier">list, <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>The time-dependent description of the quantum object.  This is of the
same format as the first parameter to the general ODE solvers; in
general, it is a list of <code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">time_dependence]</span></code> pairs that are
summed to make the whole object.  The <code class="docutils literal notranslate"><span class="pre">time_dependence</span></code> can be any of
the formats discussed in the previous section.  If a particular term
has no time-dependence, then you should just give the <code class="docutils literal notranslate"><span class="pre">Qobj</span></code> instead
of the 2-element list.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Mapping of <code class="docutils literal notranslate"><span class="pre">{str:</span> <span class="pre">object}</span></code>, discussed in greater detail above.  The
strings can be any valid Python identifier, and the objects are of the
consumable types.  See the previous section for details on the “magic”
names used to access solver internals.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like, optional</span></dt><dd><p>List of the times any numpy-array coefficients describe.  This is used
only in at least one of the time dependences in <code class="docutils literal notranslate"><span class="pre">Q_object</span></code> is given
in Numpy-array format.  The times must be sorted, but need not be
equidistant.  Values inbetween will be interpolated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>cte</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Constant part of the QobjEvo.</p>
</dd>
<dt><strong>ops</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">EvoElement</span></code></span></dt><dd><p>Internal representation of the time-dependence structure of the
elements.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>The current value of the <code class="docutils literal notranslate"><span class="pre">args</span></code> dictionary passed into the
constructor.</p>
</dd>
<dt><strong>dynamics_args</strong><span class="classifier">list</span></dt><dd><p>Names of the dynamic arguments that the solvers will generate.  These
are the magic names that were found in the <code class="docutils literal notranslate"><span class="pre">args</span></code> parameter.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>List of times at which the numpy-array coefficients are applied.</p>
</dd>
<dt><strong>compiled</strong><span class="classifier">str</span></dt><dd><p>A string representing the properties of the low-level Cython class
backing this object (may be empty).</p>
</dd>
<dt><strong>compiled_qobjevo</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">CQobjCte</span></code> or <code class="docutils literal notranslate"><span class="pre">CQobjEvoTd</span></code></span></dt><dd><p>Cython version of the QobjEvo.</p>
</dd>
<dt><strong>coeff_get</strong><span class="classifier">callable</span></dt><dd><p>Object called to obtain a list of all the coefficients at a particular
time.</p>
</dd>
<dt><strong>coeff_files</strong><span class="classifier">list</span></dt><dd><p>Runtime created files to delete with the instance.</p>
</dd>
<dt><strong>dummy_cte</strong><span class="classifier">bool</span></dt><dd><p>Is self.cte an empty Qobj</p>
</dd>
<dt><strong>const</strong><span class="classifier">bool</span></dt><dd><p>Indicates if quantum object is constant</p>
</dd>
<dt><strong>type</strong><span class="classifier">{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}</span></dt><dd><p>Information about the type of coefficients used in the entire object.</p>
</dd>
<dt><strong>num_obj</strong><span class="classifier">int</span></dt><dd><p>Number of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> in the QobjEvo.</p>
</dd>
<dt><strong>use_cython</strong><span class="classifier">bool</span></dt><dd><p>Flag to compile string to Cython or Python</p>
</dd>
<dt><strong>safePickle</strong><span class="classifier">bool</span></dt><dd><p>Flag to not share pointers between thread.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.QobjEvo.apply">
<code class="sig-name descname"><span class="pre">apply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the linear function <code class="docutils literal notranslate"><span class="pre">function</span></code> to every <code class="docutils literal notranslate"><span class="pre">Qobj</span></code> included in
this time-dependent object, and return a new <code class="docutils literal notranslate"><span class="pre">QobjEvo</span></code> with the
result.</p>
<p>Any additional arguments or keyword arguments will be appended to every
function call.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.apply_decorator">
<code class="sig-name descname"><span class="pre">apply_decorator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">str_mod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_np</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.apply_decorator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.apply_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given function to every time-dependent coefficient in the
quantum object, and return a new object with the result.</p>
<p>Any additional arguments and keyword arguments will be appended to the
function calls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(time_dependence,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">time_dependence</span></code>.  Called
on each time-dependent coefficient to produce a new coefficient.
The additional arguments and keyword arguments are the ones given
to this function.</p>
</dd>
<dt><strong>str_mod</strong><span class="classifier">list</span></dt><dd><p>A 2-element list of strings, that will additionally wrap any string
time-dependences.  An existing time-dependence string <code class="docutils literal notranslate"><span class="pre">x</span></code> will
become <code class="docutils literal notranslate"><span class="pre">str_mod[0]</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">str_mod[1]</span></code>.</p>
</dd>
<dt><strong>inplace_np</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether this function should modify Numpy arrays inplace, or be
used like a regular decorator.  Some decorators create incorrect
arrays as some transformations <code class="docutils literal notranslate"><span class="pre">f'(t)</span> <span class="pre">=</span> <span class="pre">f(g(t))</span></code> create a
mismatch between the array and the associated time list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.arguments">
<code class="sig-name descname"><span class="pre">arguments</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.arguments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the scoped variables that were passed as <code class="docutils literal notranslate"><span class="pre">args</span></code> to new values.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.compile">
<code class="sig-name descname"><span class="pre">compile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matched</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.compile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an associated Cython object for faster usage.  This function is
called automatically by the solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>code</strong><span class="classifier">bool, default False</span></dt><dd><p>Return the code string generated by compilation of any strings.</p>
</dd>
<dt><strong>matched</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, the underlying sparse matrices used to represent each
element of the type will have their structures unified.  This may
include adding explicit zeros to sparse matrices, but can be faster
in some cases due to not having to deal with repeated structural
mismatches.</p>
</dd>
<dt><strong>dense</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether to swap to using dense matrices to back the data.</p>
</dd>
<dt><strong>omp</strong><span class="classifier">int, optional</span></dt><dd><p>The number of OpenMP threads to use when doing matrix
multiplications, if QuTiP was compiled with OpenMP.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>compiled_str</strong><span class="classifier">str</span></dt><dd><p>(Only if <cite>code</cite> was set to True).  The code-generated string of
compiled calling code.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.compress">
<code class="sig-name descname"><span class="pre">compress</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.compress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge together elements that share the same time-dependence, to reduce
the number of matrix multiplications and additions that need to be done
to evaluate this object.</p>
<p>Modifies the object inplace.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.conj">
<code class="sig-name descname"><span class="pre">conj</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.conj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix elementwise conjugation.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this object.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.dag">
<code class="sig-name descname"><span class="pre">dag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix conjugate-transpose (dagger).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.expect">
<code class="sig-name descname"><span class="pre">expect</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">herm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.expect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the expectation value of this operator on the given
(time-independent) state at a particular time.</p>
<p>This is more efficient than <code class="docutils literal notranslate"><span class="pre">expect(QobjEvo(t),</span> <span class="pre">state)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time to evaluate this operator at.</p>
</dd>
<dt><strong>state</strong><span class="classifier">Qobj or np.ndarray</span></dt><dd><p>The state to take the expectation value around.</p>
</dd>
<dt><strong>herm</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether this operator and the state are both Hermitian.  If True,
only the real part of the result will be returned.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="functions.html#module-qutip.expect" title="qutip.expect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expect</span></code></a></dt><dd><p>General-purpose expectation values.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.mul_mat">
<code class="sig-name descname"><span class="pre">mul_mat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.mul_mat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.mul_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply this object evaluated at time <cite>t</cite> by a matrix (from the
right).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time to evaluate this object at.</p>
</dd>
<dt><strong>mat</strong><span class="classifier">Qobj or np.ndarray</span></dt><dd><p>The matrix that is multiplied by this object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>mat: Qobj or np.ndarray</dt><dd><p>The matrix result in the same type as the input.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.mul_vec">
<code class="sig-name descname"><span class="pre">mul_vec</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.mul_vec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.mul_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply this object evaluated at time <cite>t</cite> by a vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time to evaluate this object at.</p>
</dd>
<dt><strong>vec</strong><span class="classifier">Qobj or np.ndarray</span></dt><dd><p>The state-vector to multiply this object by.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>vec: Qobj or np.ndarray</dt><dd><p>The vector result in the same type as the input.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.permute">
<code class="sig-name descname"><span class="pre">permute</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.permute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the tensor structure of the underlying matrices into a new
format.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#qutip.Qobj.permute" title="qutip.Qobj.permute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj.permute</span></code></a></dt><dd><p>the same operation on constant quantum objects.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.tidyup">
<code class="sig-name descname"><span class="pre">tidyup</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.tidyup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.tidyup" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes small elements from this quantum object inplace.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.to_list">
<code class="sig-name descname"><span class="pre">to_list</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.to_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this operator in the list-like form used to initialised it, like
can be passed to <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.QobjEvo.trans">
<code class="sig-name descname"><span class="pre">trans</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qobjevo.html#QobjEvo.trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QobjEvo.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix transpose.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="eseries">
<span id="classes-eseries"></span><h2>eseries<a class="headerlink" href="#eseries" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.eseries">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">eseries</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float64)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/eseries.html#eseries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.eseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representation of an exponential-series expansion of
time-dependent quantum objects.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 4.6.0: </span><a class="reference internal" href="#qutip.eseries" title="qutip.eseries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eseries</span></code></a> will be removed in QuTiP 5.
Please use <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> for general time-dependence.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ampl</strong><span class="classifier">ndarray</span></dt><dd><p>Array of amplitudes for exponential series.</p>
</dd>
<dt><strong>rates</strong><span class="classifier">ndarray</span></dt><dd><p>Array of rates for exponential series.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Dimensions of exponential series components</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list</span></dt><dd><p>Shape corresponding to exponential series components</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>value(tlist)</strong></p></td>
<td><p>Evaluate an exponential series at the times listed in tlist</p></td>
</tr>
<tr class="row-even"><td><p><strong>spec(wlist)</strong></p></td>
<td><p>Evaluate the spectrum of an exponential series at frequencies in wlist.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>tidyup()</strong></p></td>
<td><p>Returns a tidier version of the exponential series</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="qutip.eseries.spec">
<code class="sig-name descname"><span class="pre">spec</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/eseries.html#eseries.spec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.eseries.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spectrum of an exponential series at frequencies
in <code class="docutils literal notranslate"><span class="pre">wlist</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wlist</strong><span class="classifier">array_like</span></dt><dd><p>Array/list of frequenies.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>val_list</strong><span class="classifier">ndarray</span></dt><dd><p>Values of exponential series at frequencies in <code class="docutils literal notranslate"><span class="pre">wlist</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.eseries.tidyup">
<code class="sig-name descname"><span class="pre">tidyup</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/eseries.html#eseries.tidyup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.eseries.tidyup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tidier version of exponential series.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.eseries.value">
<code class="sig-name descname"><span class="pre">value</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/eseries.html#eseries.value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.eseries.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates an exponential series at the times listed in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist</strong><span class="classifier">ndarray</span></dt><dd><p>Times at which to evaluate exponential series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>val_list</strong><span class="classifier">ndarray</span></dt><dd><p>Values of exponential at times in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bloch-sphere">
<span id="classes-bloch"></span><h2>Bloch sphere<a class="headerlink" href="#bloch-sphere" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.bloch.Bloch">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Bloch</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for plotting data on the Bloch sphere.  Valid data can be either
points, vectors, or Qobj objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">matplotlib.axes.Axes</span></dt><dd><p>User supplied Matplotlib axes for Bloch sphere animation.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>User supplied Matplotlib Figure instance for plotting Bloch sphere.</p>
</dd>
<dt><strong>font_color</strong><span class="classifier">str, default ‘black’</span></dt><dd><p>Color of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>font_size</strong><span class="classifier">int, default 20</span></dt><dd><p>Size of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>frame_alpha</strong><span class="classifier">float, default 0.1</span></dt><dd><p>Sets transparency of Bloch sphere frame.</p>
</dd>
<dt><strong>frame_color</strong><span class="classifier">str, default ‘gray’</span></dt><dd><p>Color of sphere wireframe.</p>
</dd>
<dt><strong>frame_width</strong><span class="classifier">int, default 1</span></dt><dd><p>Width of wireframe.</p>
</dd>
<dt><strong>point_color</strong><span class="classifier">list, default [“b”, “r”, “g”, “#CC6600”]</span></dt><dd><p>List of colors for Bloch sphere point markers to cycle through, i.e.
by default, points 0 and 4 will both be blue (‘b’).</p>
</dd>
<dt><strong>point_marker</strong><span class="classifier">list, default [“o”, “s”, “d”, “^”]</span></dt><dd><p>List of point marker shapes to cycle through.</p>
</dd>
<dt><strong>point_size</strong><span class="classifier">list, default [25, 32, 35, 45]</span></dt><dd><p>List of point marker sizes. Note, not all point markers look the same
size when plotted!</p>
</dd>
<dt><strong>sphere_alpha</strong><span class="classifier">float, default 0.2</span></dt><dd><p>Transparency of Bloch sphere itself.</p>
</dd>
<dt><strong>sphere_color</strong><span class="classifier">str, default ‘#FFDDDD’</span></dt><dd><p>Color of Bloch sphere.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">list, default [7, 7]</span></dt><dd><p>Figure size of Bloch sphere plot.  Best to have both numbers the same;
otherwise you will have a Bloch sphere that looks like a football.</p>
</dd>
<dt><strong>vector_color</strong><span class="classifier">list, [“g”, “#CC6600”, “b”, “r”]</span></dt><dd><p>List of vector colors to cycle through.</p>
</dd>
<dt><strong>vector_width</strong><span class="classifier">int, default 5</span></dt><dd><p>Width of displayed vectors.</p>
</dd>
<dt><strong>vector_style</strong><span class="classifier">str, default ‘-|&gt;’</span></dt><dd><p>Vector arrowhead style (from matplotlib’s arrow style).</p>
</dd>
<dt><strong>vector_mutation</strong><span class="classifier">int, default 20</span></dt><dd><p>Width of vectors arrowhead.</p>
</dd>
<dt><strong>view</strong><span class="classifier">list, default [-60, 30]</span></dt><dd><p>Azimuthal and Elevation viewing angles.</p>
</dd>
<dt><strong>xlabel</strong><span class="classifier">list, default [“$x$”, “”]</span></dt><dd><p>List of strings corresponding to +x and -x axes labels, respectively.</p>
</dd>
<dt><strong>xlpos</strong><span class="classifier">list, default [1.1, -1.1]</span></dt><dd><p>Positions of +x and -x labels respectively.</p>
</dd>
<dt><strong>ylabel</strong><span class="classifier">list, default [“$y$”, “”]</span></dt><dd><p>List of strings corresponding to +y and -y axes labels, respectively.</p>
</dd>
<dt><strong>ylpos</strong><span class="classifier">list, default [1.2, -1.2]</span></dt><dd><p>Positions of +y and -y labels respectively.</p>
</dd>
<dt><strong>zlabel</strong><span class="classifier">list, default [‘$\left|0\right&gt;$’, ‘$\left|1\right&gt;$’]</span></dt><dd><p>List of strings corresponding to +z and -z axes labels, respectively.</p>
</dd>
<dt><strong>zlpos</strong><span class="classifier">list, default [1.2, -1.2]</span></dt><dd><p>Positions of +z and -z labels respectively.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.bloch.Bloch.add_annotation">
<code class="sig-name descname"><span class="pre">add_annotation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_or_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_annotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a text or LaTeX annotation to Bloch sphere, parametrized by a qubit
state or a vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state_or_vector</strong><span class="classifier">Qobj/array/list/tuple</span></dt><dd><p>Position for the annotaion.
Qobj of a qubit or a vector of 3 elements.</p>
</dd>
<dt><strong>text</strong><span class="classifier">str</span></dt><dd><p>Annotation text.
You can use LaTeX, but remember to use raw string
e.g. r”$langle x rangle$”
or escape backslashes
e.g. “$\langle x \rangle$”.</p>
</dd>
<dt><strong>kwargs :</strong></dt><dd><p>Options as for mplot3d.axes3d.text, including:
fontsize, color, horizontalalignment, verticalalignment.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.add_arc">
<code class="sig-name descname"><span class="pre">add_arc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_arc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_arc" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an arc between two points on a sphere. The arc is set to be
blue solid curve by default.</p>
<p>The start and end points must be on the same sphere (i.e. have the
same radius) but need not be on the unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">Qobj or array-like</span></dt><dd><p>Array with cartesian coordinates of the first point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>end</strong><span class="classifier">Qobj or array-like</span></dt><dd><p>Array with cartesian coordinates of the second point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>fmt</strong><span class="classifier">str, default: “b”</span></dt><dd><p>A matplotlib format string for rendering the arc.</p>
</dd>
<dt><strong>steps</strong><span class="classifier">int, default: None</span></dt><dd><p>The number of segments to use when rendering the arc. The default
uses 100 steps times the distance between the start and end points,
with a minimum of 2 steps.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters to pass to the matplotlib .plot function
when rendering this arc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.add_line">
<code class="sig-name descname"><span class="pre">add_line</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a line segment connecting two points on the bloch sphere.</p>
<p>The line segment is set to be a black solid line by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">Qobj or array-like</span></dt><dd><p>Array with cartesian coordinates of the first point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>end</strong><span class="classifier">Qobj or array-like</span></dt><dd><p>Array with cartesian coordinates of the second point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>fmt</strong><span class="classifier">str, default: “k”</span></dt><dd><p>A matplotlib format string for rendering the line.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters to pass to the matplotlib .plot function
when rendering this line.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.add_points">
<code class="sig-name descname"><span class="pre">add_points</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of data points to bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">array_like</span></dt><dd><p>Collection of data points.</p>
</dd>
<dt><strong>meth</strong><span class="classifier">{‘s’, ‘m’, ‘l’}</span></dt><dd><p>Type of points to plot, use ‘m’ for multicolored, ‘l’ for points
connected with a line.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
<dt><strong>.. note::</strong></dt><dd><p>When using <code class="docutils literal notranslate"><span class="pre">meth=l</span></code> in QuTiP 4.6, the line transparency defaulted
to <code class="docutils literal notranslate"><span class="pre">0.75</span></code> and there was no way to alter it.
When the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> parameter was added in QuTiP 4.7, the default
became <code class="docutils literal notranslate"><span class="pre">alpha=1.0</span></code> for values of <code class="docutils literal notranslate"><span class="pre">meth</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.add_states">
<code class="sig-name descname"><span class="pre">add_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a state vector Qobj to Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">Qobj</span></dt><dd><p>Input state vector.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{‘vector’, ‘point’}</span></dt><dd><p>Type of object to plot.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.add_vectors">
<code class="sig-name descname"><span class="pre">add_vectors</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of vectors to Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">array_like</span></dt><dd><p>Array with vectors of unit length or smaller.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.clear">
<code class="sig-name descname"><span class="pre">clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets Bloch sphere data sets to empty.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.make_sphere">
<code class="sig-name descname"><span class="pre">make_sphere</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.make_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.make_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Bloch sphere and data sets.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.render">
<code class="sig-name descname"><span class="pre">render</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.render"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the Bloch sphere and its data sets in on given figure and axes.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.save">
<code class="sig-name descname"><span class="pre">save</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'png'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.save"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves Bloch sphere to file of type <code class="docutils literal notranslate"><span class="pre">format</span></code> in directory <code class="docutils literal notranslate"><span class="pre">dirc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of saved image. Must include path and format as well.
i.e. ‘/Users/Paul/Desktop/bloch.png’
This overrides the ‘format’ and ‘dirc’ arguments.</p>
</dd>
<dt><strong>format</strong><span class="classifier">str</span></dt><dd><p>Format of output image.</p>
</dd>
<dt><strong>dirc</strong><span class="classifier">str</span></dt><dd><p>Directory for output images. Defaults to current working directory.</p>
</dd>
<dt><strong>dpin</strong><span class="classifier">int</span></dt><dd><p>Resolution in dots per inch.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>File containing plot of Bloch sphere.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.set_label_convention">
<code class="sig-name descname"><span class="pre">set_label_convention</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.set_label_convention"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.set_label_convention" title="Permalink to this definition">¶</a></dt>
<dd><p>Set x, y and z labels according to one of conventions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>convention</strong><span class="classifier">string</span></dt><dd><p>One of the following:</p>
<ul class="simple">
<li><p>“original”</p></li>
<li><p>“xyz”</p></li>
<li><p>“sx sy sz”</p></li>
<li><p>“01”</p></li>
<li><p>“polarization jones”</p></li>
<li><p>“polarization jones letters”
see also: <a class="reference external" href="https://en.wikipedia.org/wiki/Jones_calculus">https://en.wikipedia.org/wiki/Jones_calculus</a></p></li>
<li><p>“polarization stokes”
see also: <a class="reference external" href="https://en.wikipedia.org/wiki/Stokes_parameters">https://en.wikipedia.org/wiki/Stokes_parameters</a></p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch.Bloch.show">
<code class="sig-name descname"><span class="pre">show</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.show"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Bloch sphere and corresponding data sets.</p>
<p class="rubric">Notes</p>
<p>When using inline plotting in Jupyter notebooks, any figure created
in a notebook cell is displayed after the cell executes. Thus if you
create a figure yourself and use it create a Bloch sphere with
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">Bloch(...,</span> <span class="pre">fig=fig)</span></code> and then call <code class="docutils literal notranslate"><span class="pre">b.show()</span></code> in the same
cell, then the figure will be displayed twice. If you do create your
own figure, the simplest solution to this is to not call <code class="docutils literal notranslate"><span class="pre">.show()</span></code>
in the cell you create the figure in.</p>
</dd></dl>

<dl class="py attribute">
<dt id="qutip.bloch.Bloch.vector_mutation">
<code class="sig-name descname"><span class="pre">vector_mutation</span></code><a class="headerlink" href="#qutip.bloch.Bloch.vector_mutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the width of the vectors arrowhead</p>
</dd></dl>

<dl class="py attribute">
<dt id="qutip.bloch.Bloch.vector_style">
<code class="sig-name descname"><span class="pre">vector_style</span></code><a class="headerlink" href="#qutip.bloch.Bloch.vector_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Style of Bloch vectors, default = ‘-|&gt;’ (or ‘simple’)</p>
</dd></dl>

<dl class="py attribute">
<dt id="qutip.bloch.Bloch.vector_width">
<code class="sig-name descname"><span class="pre">vector_width</span></code><a class="headerlink" href="#qutip.bloch.Bloch.vector_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Width of Bloch vectors, default = 5</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.bloch3d.Bloch3d">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Bloch3d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for plotting data on a 3D Bloch sphere using mayavi.
Valid data can be either points, vectors, or qobj objects
corresponding to state vectors or density matrices. for
a two-state system (or subsystem).</p>
<p class="rubric">Notes</p>
<p>The use of mayavi for 3D rendering of the Bloch sphere comes with
a few limitations: I) You can not embed a Bloch3d figure into a
matplotlib window. II) The use of LaTex is not supported by the
mayavi rendering engine. Therefore all labels must be defined using
standard text. Of course you can post-process the generated figures
later to add LaTeX using other software if needed.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>fig</strong><span class="classifier">instance {None}</span></dt><dd><p>User supplied Matplotlib Figure instance for plotting Bloch sphere.</p>
</dd>
<dt><strong>font_color</strong><span class="classifier">str {‘black’}</span></dt><dd><p>Color of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>font_scale</strong><span class="classifier">float {0.08}</span></dt><dd><p>Scale for font used for Bloch sphere labels.</p>
</dd>
<dt><strong>frame</strong><span class="classifier">bool {True}</span></dt><dd><p>Draw frame for Bloch sphere</p>
</dd>
<dt><strong>frame_alpha</strong><span class="classifier">float {0.05}</span></dt><dd><p>Sets transparency of Bloch sphere frame.</p>
</dd>
<dt><strong>frame_color</strong><span class="classifier">str {‘gray’}</span></dt><dd><p>Color of sphere wireframe.</p>
</dd>
<dt><strong>frame_num</strong><span class="classifier">int {8}</span></dt><dd><p>Number of frame elements to draw.</p>
</dd>
<dt><strong>frame_radius</strong><span class="classifier">floats {0.005}</span></dt><dd><p>Width of wireframe.</p>
</dd>
<dt><strong>point_color</strong><span class="classifier">list {[‘r’, ‘g’, ‘b’, ‘y’]}</span></dt><dd><p>List of colors for Bloch sphere point markers to cycle through.
i.e. By default, points 0 and 4 will both be blue (‘r’).</p>
</dd>
<dt><strong>point_mode</strong><span class="classifier">string {‘sphere’,’cone’,’cube’,’cylinder’,’point’}</span></dt><dd><p>Point marker shapes.</p>
</dd>
<dt><strong>point_size</strong><span class="classifier">float {0.075}</span></dt><dd><p>Size of points on Bloch sphere.</p>
</dd>
<dt><strong>sphere_alpha</strong><span class="classifier">float {0.1}</span></dt><dd><p>Transparency of Bloch sphere itself.</p>
</dd>
<dt><strong>sphere_color</strong><span class="classifier">str {‘#808080’}</span></dt><dd><p>Color of Bloch sphere.</p>
</dd>
<dt><strong>size</strong><span class="classifier">list {[500,500]}</span></dt><dd><p>Size of Bloch sphere plot in pixels. Best to have both numbers the same
otherwise you will have a Bloch sphere that looks like a football.</p>
</dd>
<dt><strong>vector_color</strong><span class="classifier">list {[‘r’, ‘g’, ‘b’, ‘y’]}</span></dt><dd><p>List of vector colors to cycle through.</p>
</dd>
<dt><strong>vector_width</strong><span class="classifier">int {3}</span></dt><dd><p>Width of displayed vectors.</p>
</dd>
<dt><strong>view</strong><span class="classifier">list {[45,65]}</span></dt><dd><p>Azimuthal and Elevation viewing angles.</p>
</dd>
<dt><strong>xlabel</strong><span class="classifier">list {<code class="docutils literal notranslate"><span class="pre">['|x&gt;',</span> <span class="pre">'']</span></code>}</span></dt><dd><p>List of strings corresponding to +x and -x axes labels, respectively.</p>
</dd>
<dt><strong>xlpos</strong><span class="classifier">list {[1.07,-1.07]}</span></dt><dd><p>Positions of +x and -x labels respectively.</p>
</dd>
<dt><strong>ylabel</strong><span class="classifier">list {<code class="docutils literal notranslate"><span class="pre">['|y&gt;',</span> <span class="pre">'']</span></code>}</span></dt><dd><p>List of strings corresponding to +y and -y axes labels, respectively.</p>
</dd>
<dt><strong>ylpos</strong><span class="classifier">list {[1.07,-1.07]}</span></dt><dd><p>Positions of +y and -y labels respectively.</p>
</dd>
<dt><strong>zlabel</strong><span class="classifier">list {<code class="docutils literal notranslate"><span class="pre">['|0&gt;',</span> <span class="pre">'|1&gt;']</span></code>}</span></dt><dd><p>List of strings corresponding to +z and -z axes labels, respectively.</p>
</dd>
<dt><strong>zlpos</strong><span class="classifier">list {[1.07,-1.07]}</span></dt><dd><p>Positions of +z and -z labels respectively.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.add_points">
<code class="sig-name descname"><span class="pre">add_points</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.add_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.add_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of data points to bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">array/list</span></dt><dd><p>Collection of data points.</p>
</dd>
<dt><strong>meth</strong><span class="classifier">str {‘s’,’m’}</span></dt><dd><p>Type of points to plot, use ‘m’ for multicolored.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.add_states">
<code class="sig-name descname"><span class="pre">add_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.add_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.add_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a state vector Qobj to Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">qobj</span></dt><dd><p>Input state vector.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str {‘vector’,’point’}</span></dt><dd><p>Type of object to plot.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.add_vectors">
<code class="sig-name descname"><span class="pre">add_vectors</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.add_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.add_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of vectors to Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">array/list</span></dt><dd><p>Array with vectors of unit length or smaller.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.clear">
<code class="sig-name descname"><span class="pre">clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the Bloch sphere data sets to empty.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.make_sphere">
<code class="sig-name descname"><span class="pre">make_sphere</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.make_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.make_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Bloch sphere and data sets.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.plot_points">
<code class="sig-name descname"><span class="pre">plot_points</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.plot_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.plot_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots points on the Bloch sphere.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.plot_vectors">
<code class="sig-name descname"><span class="pre">plot_vectors</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.plot_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.plot_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots vectors on the Bloch sphere.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.save">
<code class="sig-name descname"><span class="pre">save</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'png'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.save"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves Bloch sphere to file of type <code class="docutils literal notranslate"><span class="pre">format</span></code> in directory <code class="docutils literal notranslate"><span class="pre">dirc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of saved image. Must include path and format as well.
i.e. ‘/Users/Paul/Desktop/bloch.png’
This overrides the ‘format’ and ‘dirc’ arguments.</p>
</dd>
<dt><strong>format</strong><span class="classifier">str</span></dt><dd><p>Format of output image. Default is ‘png’.</p>
</dd>
<dt><strong>dirc</strong><span class="classifier">str</span></dt><dd><p>Directory for output images. Defaults to current working directory.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>File containing plot of Bloch sphere.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.bloch3d.Bloch3d.show">
<code class="sig-name descname"><span class="pre">show</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch3d.html#Bloch3d.show"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch3d.Bloch3d.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the Bloch sphere and corresponding data sets.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.QFunc">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">QFunc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1024</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#QFunc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Class-based method of calculating the Husimi-Q function of many different
quantum states at fixed phase-space points <code class="docutils literal notranslate"><span class="pre">0.5*g*</span> <span class="pre">(xvec</span> <span class="pre">+</span> <span class="pre">i*yvec)</span></code>.
This class has slightly higher first-usage costs than <a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a>, but
subsequent operations will be several times faster. However, it can require
quite a lot of memory. Call the created object as a function to retrieve
the Husimi-Q function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xvec, yvec</strong><span class="classifier">array_like</span></dt><dd><p>x- and y-coordinates at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float, default sqrt(2)</span></dt><dd><p>Scaling factor for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">iy)</span></code>.  The value of <cite>g</cite> is
related to the value of <cite>hbar</cite> in the commutation relation
<span class="math notranslate nohighlight">\([x,\,y] = i\hbar\)</span> via <span class="math notranslate nohighlight">\(\hbar=2/g^2\)</span>, so the default
corresponds to <span class="math notranslate nohighlight">\(\hbar=1\)</span>.</p>
</dd>
<dt><strong>memory</strong><span class="classifier">real, default 1024</span></dt><dd><p>Size in MB that may be used internally as workspace.  This class will
raise <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code> if subsequently passed a state of sufficiently
large dimension that this bound would be exceeded.  In those cases, use
<a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a> with <code class="docutils literal notranslate"><span class="pre">precompute_memory=None</span></code> instead to force using
the slower, more memory-efficient algorithm.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a></dt><dd><p>a single function version, which will involve computing several quantities multiple times in order to use less memory.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initialise the class for a square set of coordinates, with some states we
want to investigate.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">rand_dm</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qfunc</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">QFunc</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">xvec</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can calculate the Husimi-Q function over each of the states more
efficiently with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">husimiq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qfunc</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="cubic-spline">
<h2>Cubic Spline<a class="headerlink" href="#cubic-spline" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.interpolate.Cubic_Spline">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Cubic_Spline</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/interpolate.html#Cubic_Spline"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.interpolate.Cubic_Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates coefficients for a cubic spline
interpolation of a given data set.</p>
<p>This function assumes that the data is sampled
uniformly over a given interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>Lower bound of the interval.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>Upper bound of the interval.</p>
</dd>
<dt><strong>y</strong><span class="classifier">ndarray</span></dt><dd><p>Function values at interval points.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Second-order derivative at a. Default is 0.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float</span></dt><dd><p>Second-order derivative at b. Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This object can be called like a normal function with a
single or array of input points at which to evaluate
the interplating function.</p>
<p>Habermann &amp; Kindermann, “Multidimensional Spline Interpolation:
Theory and Applications”, Comput Econ 30, 153 (2007).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">float</span></dt><dd><p>Lower bound of the interval.</p>
</dd>
<dt><strong>b</strong><span class="classifier">float</span></dt><dd><p>Upper bound of the interval.</p>
</dd>
<dt><strong>coeffs</strong><span class="classifier">ndarray</span></dt><dd><p>Array of coeffcients defining cubic spline.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="non-markovian-solvers">
<span id="classes-non-markov"></span><h2>Non-Markovian Solvers<a class="headerlink" href="#non-markovian-solvers" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.nonmarkov.heom.HEOMSolver">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HEOMSolver</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HEOMSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>HEOM solver that supports multiple baths.</p>
<p>The baths must be all either bosonic or fermionic baths.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_sys</strong><span class="classifier">QObj, QobjEvo or a list</span></dt><dd><p>The system Hamiltonian or Liouvillian specified as either a
<a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, or a list of elements
that may be converted to a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>.</p>
</dd>
<dt><strong>bath</strong><span class="classifier">Bath or list of Bath</span></dt><dd><p>A <a class="reference internal" href="#qutip.nonmarkov.heom.Bath" title="qutip.nonmarkov.heom.Bath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bath</span></code></a> containing the exponents of the expansion of the
bath correlation funcion and their associated coefficients
and coupling operators, or a list of baths.</p>
<p>If multiple baths are given, they must all be either fermionic
or bosonic baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the heirarchy (i.e. the maximum number of bath
exponent “excitations” to retain).</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options. If set to None the default options will be
used.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">None, True or <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProgressBar</span></code></span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the solver. If True, an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextProgressBar</span></code> is used instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>ados</strong><span class="classifier"><a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOs" title="qutip.nonmarkov.heom.HierarchyADOs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HierarchyADOs</span></code></a></span></dt><dd><p>The description of the hierarchy constructed from the given bath
and maximum depth.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.HEOMSolver.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ado_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ado_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HEOMSolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for the time evolution of the system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho0</strong><span class="classifier">Qobj or HierarchyADOsState or numpy.array</span></dt><dd><p>Initial state (<a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> density matrix) of the system
if <code class="docutils literal notranslate"><span class="pre">ado_init</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">ado_init</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">rho0</span></code> should be an
instance of <a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOsState" title="qutip.nonmarkov.heom.HierarchyADOsState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a> or a numpy array
giving the initial state of all ADOs. Usually
the state of the ADOs would be determine from a previous call
to <code class="docutils literal notranslate"><span class="pre">.run(...,</span> <span class="pre">ado_return=True)</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">solver.run(...,</span> <span class="pre">ado_return=True)</span></code> could be followed
by <code class="docutils literal notranslate"><span class="pre">solver.run(result.ado_states[-1],</span> <span class="pre">tlist,</span> <span class="pre">ado_init=True)</span></code>.</p>
<p>If a numpy array is passed its shape must be
<code class="docutils literal notranslate"><span class="pre">(number_of_ados,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> where <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> is the system shape
(i.e. shape of the system density matrix) and the ADOs must be
in the same order as in <code class="docutils literal notranslate"><span class="pre">.ados.labels</span></code>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list</span></dt><dd><p>An ordered list of times at which to return the value of the state.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">Qobj / callable / list / dict / None, optional</span></dt><dd><p>A list or dictionary of operators as <cite>Qobj</cite> and/or callable
functions (they can be mixed) or a single operator or callable
function. For an operator <code class="docutils literal notranslate"><span class="pre">op</span></code>, the result will be computed
using <code class="docutils literal notranslate"><span class="pre">(state</span> <span class="pre">*</span> <span class="pre">op).tr()</span></code> and the state at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>. For
callable functions, <code class="docutils literal notranslate"><span class="pre">f</span></code>, the result is computed using
<code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">ado_state)</span></code>. The values are stored in <code class="docutils literal notranslate"><span class="pre">expect</span></code> on
(see the return section below).</p>
</dd>
<dt><strong>ado_init: bool, default False</strong></dt><dd><p>Indicates if initial condition is just the system state, or a
numpy array including all ADOs.</p>
</dd>
<dt><strong>ado_return: bool, default True</strong></dt><dd><p>Whether to also return as output the full state of all ADOs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>The results of the simulation run, with the following attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">times</span></code>: the times <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e. the <code class="docutils literal notranslate"><span class="pre">tlist</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">states</span></code>: the system state at each time <code class="docutils literal notranslate"><span class="pre">t</span></code> (only available
if <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> was <code class="docutils literal notranslate"><span class="pre">None</span></code> or if the solver option
<code class="docutils literal notranslate"><span class="pre">store_states</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ado_states</span></code>: the full ADO state at each time (only available
if <code class="docutils literal notranslate"><span class="pre">ado_return</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>). Each element is an
instance of <a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOsState" title="qutip.nonmarkov.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a>.            .
The state of a particular ADO may be extracted from
<code class="docutils literal notranslate"><span class="pre">result.ado_states[i]</span></code> by calling <a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOsState.extract" title="qutip.nonmarkov.heom.HierarchyADOsState.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expect</span></code>: the value of each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> at time <code class="docutils literal notranslate"><span class="pre">t</span></code> (only
available if <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were given). If <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> was passed
as a dictionary, then <code class="docutils literal notranslate"><span class="pre">expect</span></code> will be a dictionary with
the same keys as <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> and values giving the list of
outcomes for the corresponding key.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.heom.HEOMSolver.steady_state">
<code class="sig-name descname"><span class="pre">steady_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_mkl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mkl_max_iter_refine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mkl_weighted_matching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HEOMSolver.steady_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver.steady_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the steady state of the system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>use_mkl</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use mkl or not. If mkl is not installed or if
this is false, use the scipy splu solver instead.</p>
</dd>
<dt><strong>mkl_max_iter_refine</strong><span class="classifier">int</span></dt><dd><p>Specifies the the maximum number of iterative refinement steps that
the MKL PARDISO solver performs.</p>
<p>For a complete description, see iparm(8) in
<a class="reference external" href="http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm">http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm</a>.</p>
</dd>
<dt><strong>mkl_weighted_matching</strong><span class="classifier">bool</span></dt><dd><p>MKL PARDISO can use a maximum weighted matching algorithm to
permute large elements close the diagonal. This strategy adds an
additional level of reliability to the factorization methods.</p>
<p>For a complete description, see iparm(13) in
<a class="reference external" href="http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm">http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>steady_state</strong><span class="classifier">Qobj</span></dt><dd><p>The steady state density matrix of the system.</p>
</dd>
<dt><strong>steady_ados</strong><span class="classifier"><a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOsState" title="qutip.nonmarkov.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a></span></dt><dd><p>The steady state of the full ADO hierarchy. A particular ADO may be
extracted from the full state by calling <a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOsState.extract" title="qutip.nonmarkov.heom.HierarchyADOsState.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.HSolverDL">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HSolverDL</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_strength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cut_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HSolverDL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HSolverDL" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for creating an <a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> that is backwards
compatible with the <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> provided in <code class="docutils literal notranslate"><span class="pre">qutip.nonmarkov.heom</span></code>
in QuTiP 4.6 and below.</p>
<p>See <a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> and <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> for more
descriptions of the underlying solver and bath construction.</p>
<p>An exact copy of the QuTiP 4.6 HSolverDL is provided in
<code class="docutils literal notranslate"><span class="pre">qutip.nonmarkov.dlheom_solver</span></code> for cases where the functionality of
the older solver is required. The older solver will be completely
removed in QuTiP 5.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the version of <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> in QuTiP 4.6, this solver
supports supplying a time-dependent or Liouvillian <code class="docutils literal notranslate"><span class="pre">H_sys</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For compatibility with <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> in QuTiP 4.6 and below, the
parameter <code class="docutils literal notranslate"><span class="pre">N_exp</span></code> specifying the number of exponents to keep in
the expansion of the bath correlation function is one more than
the equivalent <code class="docutils literal notranslate"><span class="pre">Nk</span></code> used in the <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>. I.e.,
<code class="docutils literal notranslate"><span class="pre">Nk</span> <span class="pre">=</span> <span class="pre">N_exp</span> <span class="pre">-</span> <span class="pre">1</span></code>. The <code class="docutils literal notranslate"><span class="pre">Nk</span></code> parameter in the
<a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> does not count the zeroeth exponent in
order to better match common usage in the literature.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stats</span></code> and <code class="docutils literal notranslate"><span class="pre">renorm</span></code> arguments accepted in QuTiP 4.6 and below
are no longer supported.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>H_sys</strong><span class="classifier">Qobj or QobjEvo or list</span></dt><dd><p>The system Hamiltonian or Liouvillian. See <a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> for
a complete description.</p>
</dd>
<dt><strong>coup_op</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.
See parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code> in <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath" title="qutip.nonmarkov.heom.BosonicBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">BosonicBath</span></code></a> for a complete description.</p>
</dd>
<dt><strong>coup_strength</strong><span class="classifier">float</span></dt><dd><p>Coupling strength. Referred to as <code class="docutils literal notranslate"><span class="pre">lam</span></code> in <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>temperature</strong><span class="classifier">float</span></dt><dd><p>Bath temperature. Referred to as <code class="docutils literal notranslate"><span class="pre">T</span></code> in <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>N_cut</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy. See <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> in
<a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> for a full description.</p>
</dd>
<dt><strong>N_exp</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions. The equivalent <code class="docutils literal notranslate"><span class="pre">Nk</span></code> in <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> is one
less than <code class="docutils literal notranslate"><span class="pre">N_exp</span></code> (see note above).</p>
</dd>
<dt><strong>cut_freq</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency. Referred to as <code class="docutils literal notranslate"><span class="pre">gamma</span></code> in
<a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>bnd_cut_approx</strong><span class="classifier">bool</span></dt><dd><p>Use boundary cut off approximation. If true, the Matsubara
terminator is added to the system Liouvillian (and H_sys is
promoted to a Liouvillian if it was a Hamiltonian).</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options.
If set to None the default options will be used.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier">None, True or <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProgressBar</span></code></span></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the solver. If True, an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextProgressBar</span></code> is used instead.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="qutip.nonmarkov.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.BathExponent">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">BathExponent</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_bar_k_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#BathExponent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.BathExponent" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a single exponent (naively, an excitation mode) within the
decomposition of the correlation functions of a bath.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>type</strong><span class="classifier">{“R”, “I”, “RI”, “+”, “-“} or BathExponent.ExponentType</span></dt><dd><p>The type of bath exponent.</p>
<p>“R” and “I” are bosonic bath exponents that appear in the real and
imaginary parts of the correlation expansion.</p>
<p>“RI” is combined bosonic bath exponent that appears in both the real
and imaginary parts of the correlation expansion. The combined exponent
has a single <code class="docutils literal notranslate"><span class="pre">vk</span></code>. The <code class="docutils literal notranslate"><span class="pre">ck</span></code> is the coefficient in the real
expansion and <code class="docutils literal notranslate"><span class="pre">ck2</span></code> is the coefficient in the imaginary expansion.</p>
<p>“+” and “-” are fermionic bath exponents. These fermionic bath
exponents must specify <code class="docutils literal notranslate"><span class="pre">sigma_bar_k_offset</span></code> which specifies
the amount to add to <code class="docutils literal notranslate"><span class="pre">k</span></code> (the exponent index within the bath of this
exponent) to determine the <code class="docutils literal notranslate"><span class="pre">k</span></code> of the corresponding exponent with
the opposite sign (i.e. “-” or “+”).</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int or None</span></dt><dd><p>The dimension (i.e. maximum number of excitations for this exponent).
Usually <code class="docutils literal notranslate"><span class="pre">2</span></code> for fermionic exponents or <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e. unlimited) for
bosonic exponents.</p>
</dd>
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for this excitation mode.</p>
</dd>
<dt><strong>vk</strong><span class="classifier">complex</span></dt><dd><p>The frequency of the exponent of the excitation term.</p>
</dd>
<dt><strong>ck</strong><span class="classifier">complex</span></dt><dd><p>The coefficient of the excitation term.</p>
</dd>
<dt><strong>ck2</strong><span class="classifier">optional, complex</span></dt><dd><p>For exponents of type “RI” this is the coefficient of the term in the
imaginary expansion (and <code class="docutils literal notranslate"><span class="pre">ck</span></code> is the coefficient in the real
expansion).</p>
</dd>
<dt><strong>sigma_bar_k_offset</strong><span class="classifier">optional, int</span></dt><dd><p>For exponents of type “+” this gives the offset (within the list of
exponents within the bath) of the corresponding “-” bath exponent.
For exponents of type “-” it gives the offset of the corresponding
“+” exponent.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the exponent (often the name of the bath). It
defaults to None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>All of the parameters are available as attributes.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt id="qutip.nonmarkov.heom.BathExponent.types">
<code class="sig-name descname"><span class="pre">types</span></code><a class="headerlink" href="#qutip.nonmarkov.heom.BathExponent.types" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.nonmarkov.bofin_baths.ExponentType</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.Bath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Bath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#Bath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.Bath" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a list of bath expansion exponents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>All of the parameters are available as attributes.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.BosonicBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">BosonicBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_imag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_imag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#BosonicBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.BosonicBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a bosonic bath from the expansion
coefficients and frequencies for the real and imaginary parts of
the bath correlation function.</p>
<p>If the correlation functions <code class="docutils literal notranslate"><span class="pre">C(t)</span></code> is split into real and imaginary
parts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">C_real</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">C_imag</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C_real</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_real</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_real</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
<span class="n">C_imag</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_imag</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_imag</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Defines the coefficients <code class="docutils literal notranslate"><span class="pre">ck</span></code> and the frequencies <code class="docutils literal notranslate"><span class="pre">vk</span></code>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">ck</span></code> and <code class="docutils literal notranslate"><span class="pre">vk</span></code> may be complex, even through <code class="docutils literal notranslate"><span class="pre">C_real(t)</span></code>
and <code class="docutils literal notranslate"><span class="pre">C_imag(t)</span></code> (i.e. the sum) is real.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for the bath.</p>
</dd>
<dt><strong>ck_real</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the real part of the
correlation function. The corresponding frequencies are passed as
vk_real.</p>
</dd>
<dt><strong>vk_real</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the real part of
the correlation function. The corresponding ceofficients are passed as
ck_real.</p>
</dd>
<dt><strong>ck_imag</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms in the imaginary part of the
correlation function. The corresponding frequencies are passed as
vk_imag.</p>
</dd>
<dt><strong>vk_imag</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the imaginary
part of the correlation function. The corresponding ceofficients are
passed as ck_imag.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="qutip.nonmarkov.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.BosonicBath.combine">
<em class="property"><span class="pre">classmethod</span> </em><code class="sig-name descname"><span class="pre">combine</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#BosonicBath.combine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Group bosonic exponents with the same frequency and return a
single exponent for each frequency present.</p>
<p>Exponents with the same frequency are only combined if they share the
same coupling operator <code class="docutils literal notranslate"><span class="pre">.Q</span></code>.</p>
<p>Note that combined exponents take their tag from the first
exponent in the group being combined (i.e. the one that occurs first
in the given exponents list).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The list of exponents to combine.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, default 1e-5</span></dt><dd><p>The relative tolerance to use to when comparing frequencies and
coupling operators.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float, default 1e-7</span></dt><dd><p>The absolute tolerance to use to when comparing frequencies and
coupling operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of BathExponent</dt><dd><p>The new reduced list of exponents.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.DrudeLorentzBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DrudeLorentzBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#DrudeLorentzBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a Drude-Lorentz bosonic bath from the
bath parameters (see parameters below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="qutip.nonmarkov.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.DrudeLorentzBath.terminator">
<code class="sig-name descname"><span class="pre">terminator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#DrudeLorentzBath.terminator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.DrudeLorentzBath.terminator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Matsubara terminator for the bath and the calculated
approximation discrepancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>delta: float</dt><dd><p>The approximation discrepancy. That is, the difference between the
true correlation function of the Drude-Lorentz bath and the sum of
the <code class="docutils literal notranslate"><span class="pre">Nk</span></code> exponential terms is approximately <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">delta</span> <span class="pre">*</span>
<span class="pre">dirac(t)</span></code>, where <code class="docutils literal notranslate"><span class="pre">dirac(t)</span></code> denotes the Dirac delta function.</p>
</dd>
<dt><strong>terminator</strong><span class="classifier">Qobj</span></dt><dd><p>The Matsubara terminator – i.e. a liouvillian term representing
the contribution to the system-bath dynamics of all exponential
expansion terms beyond <code class="docutils literal notranslate"><span class="pre">Nk</span></code>. It should be used by adding it to
the system liouvillian (i.e. <code class="docutils literal notranslate"><span class="pre">liouvillian(H_sys)</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.DrudeLorentzPadeBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DrudeLorentzPadeBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#DrudeLorentzPadeBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.DrudeLorentzPadeBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a Padé expansion for a Drude-Lorentz
bosonic bath from the bath parameters (see parameters below).</p>
<p>A Padé approximant is a sum-over-poles expansion (
see <a class="reference external" href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">https://en.wikipedia.org/wiki/Pad%C3%A9_approximant</a>).</p>
<p>The application of the Padé method to spectrum decompoisitions is described
in “Padé spectrum decompositions of quantum distribution functions and
optimal hierarchical equations of motion construction for quantum open
systems” [1].</p>
<p>The implementation here follows the approach in the paper.</p>
<p>[1] J. Chem. Phys. 134, 244106 (2011); <a class="reference external" href="https://doi.org/10.1063/1.3602466">https://doi.org/10.1063/1.3602466</a></p>
<p>This is an alternative to the <a class="reference internal" href="#qutip.nonmarkov.heom.DrudeLorentzBath" title="qutip.nonmarkov.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> which constructs
a simpler exponential expansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of Padé exponentials terms used to approximate the bath
correlation functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="qutip.nonmarkov.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.DrudeLorentzPadeBath.terminator">
<code class="sig-name descname"><span class="pre">terminator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#DrudeLorentzPadeBath.terminator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.DrudeLorentzPadeBath.terminator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Padé terminator for the bath and the calculated
approximation discrepancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>delta: float</dt><dd><p>The approximation discrepancy. That is, the difference between the
true correlation function of the Drude-Lorentz bath and the sum of
the <code class="docutils literal notranslate"><span class="pre">Nk</span></code> exponential terms is approximately <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">delta</span> <span class="pre">*</span>
<span class="pre">dirac(t)</span></code>, where <code class="docutils literal notranslate"><span class="pre">dirac(t)</span></code> denotes the Dirac delta function.</p>
</dd>
<dt><strong>terminator</strong><span class="classifier">Qobj</span></dt><dd><p>The Padé terminator – i.e. a liouvillian term representing
the contribution to the system-bath dynamics of all exponential
expansion terms beyond <code class="docutils literal notranslate"><span class="pre">Nk</span></code>. It should be used by adding it to
the system liouvillian (i.e. <code class="docutils literal notranslate"><span class="pre">liouvillian(H_sys)</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.UnderDampedBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">UnderDampedBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#UnderDampedBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.UnderDampedBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing an under-damped bosonic bath from the
bath parameters (see parameters below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>w0</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density resonance frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.nonmarkov.heom.BosonicBath.combine" title="qutip.nonmarkov.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.FermionicBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">FermionicBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_plus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_plus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_minus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_minus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#FermionicBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.FermionicBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a fermionic bath from the expansion
coefficients and frequencies for the <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> modes of
the bath correlation function.</p>
<p>There must be the same number of <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> modes and their
coefficients must be specified in the same order so that <code class="docutils literal notranslate"><span class="pre">ck_plus[i],</span>
<span class="pre">vk_plus[i]</span></code> are the plus coefficient and frequency corresponding
to the minus mode <code class="docutils literal notranslate"><span class="pre">ck_minus[i],</span> <span class="pre">vk_minus[i]</span></code>.</p>
<p>In the fermionic case the order in which excitations are created or
destroyed is important, resulting in two different correlation functions
labelled <code class="docutils literal notranslate"><span class="pre">C_plus(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">C_plus(t)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C_plus</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_plus</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_plus</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
<span class="n">C_minus</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_minus</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_minus</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>where the expansions above define the coeffiients <code class="docutils literal notranslate"><span class="pre">ck</span></code> and the
frequencies <code class="docutils literal notranslate"><span class="pre">vk</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for the bath.</p>
</dd>
<dt><strong>ck_plus</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">+</span></code> part of the
correlation function. The corresponding frequencies are passed as
vk_plus.</p>
</dd>
<dt><strong>vk_plus</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">+</span></code> part
of the correlation function. The corresponding ceofficients are passed
as ck_plus.</p>
</dd>
<dt><strong>ck_minus</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">-</span></code> part of the
correlation function. The corresponding frequencies are passed as
vk_minus.</p>
</dd>
<dt><strong>vk_minus</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">-</span></code> part
of the correlation function. The corresponding ceofficients are passed
as ck_minus.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.LorentzianBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">LorentzianBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#LorentzianBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.LorentzianBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a Lorentzian fermionic bath from the
bath parameters (see parameters below).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This Matsubara expansion used in this bath converges very slowly
and <code class="docutils literal notranslate"><span class="pre">Nk</span> <span class="pre">&gt;</span> <span class="pre">20</span></code> may be required to get good convergence. The
Padé expansion used by <a class="reference internal" href="#qutip.nonmarkov.heom.LorentzianPadeBath" title="qutip.nonmarkov.heom.LorentzianPadeBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">LorentzianPadeBath</span></code></a> converges much
more quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>The coupling strength between the system and the bath.</p>
</dd>
<dt><strong>w</strong><span class="classifier">float</span></dt><dd><p>The width of the environment.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>The chemical potential of the bath.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.LorentzianPadeBath">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">LorentzianPadeBath</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_baths.html#LorentzianPadeBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.LorentzianPadeBath" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper class for constructing a Padé expansion for Lorentzian fermionic
bath from the bath parameters (see parameters below).</p>
<p>A Padé approximant is a sum-over-poles expansion (
see <a class="reference external" href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">https://en.wikipedia.org/wiki/Pad%C3%A9_approximant</a>).</p>
<p>The application of the Padé method to spectrum decompoisitions is described
in “Padé spectrum decompositions of quantum distribution functions and
optimal hierarchical equations of motion construction for quantum open
systems” [1].</p>
<p>The implementation here follows the approach in the paper.</p>
<p>[1] J. Chem. Phys. 134, 244106 (2011); <a class="reference external" href="https://doi.org/10.1063/1.3602466">https://doi.org/10.1063/1.3602466</a></p>
<p>This is an alternative to the <a class="reference internal" href="#qutip.nonmarkov.heom.LorentzianBath" title="qutip.nonmarkov.heom.LorentzianBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">LorentzianBath</span></code></a> which constructs
a simpler exponential expansion that converges much more slowly in
this particular case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>The coupling strength between the system and the bath.</p>
</dd>
<dt><strong>w</strong><span class="classifier">float</span></dt><dd><p>The width of the environment.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>The chemical potential of the bath.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.HierarchyADOs">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HierarchyADOs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs" title="Permalink to this definition">¶</a></dt>
<dd><p>A description of ADOs (auxilliary density operators) with the
hierarchical equations of motion.</p>
<p>The list of ADOs is constructed from a list of bath exponents
(corresponding to one or more baths). Each ADO is referred to by a label
that lists the number of “excitations” of each bath exponent. The
level of a label within the hierarchy is the sum of the “excitations”
within the label.</p>
<p>For example the label <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0)</span></code> represents the density matrix
of the system being solved and is the only 0th level label.</p>
<p>The labels with a single 1, i.e. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">...</span> <span class="pre">0)</span></code>,
etc. are the 1st level labels.</p>
<p>The second level labels all have either two 1s or a single 2, and so on
for the third and higher levels of the hierarchy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath or
baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy (i.e. the maximum sum of
“excitations” in the hierarchy ADO labels or maximum ADO level).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath or
baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy (i.e. the maximum sum of
“excitations” in the hierarchy ADO labels).</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of int</span></dt><dd><p>The dimensions of each exponent within the bath(s).</p>
</dd>
<dt><strong>vk</strong><span class="classifier">list of complex</span></dt><dd><p>The frequency of each exponent within the bath(s).</p>
</dd>
<dt><strong>ck</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficient of each exponent within the bath(s).</p>
</dd>
<dt><strong>ck2: list of complex</strong></dt><dd><p>For exponents of type “RI”, the coefficient of the exponent within
the imaginary expansion. For other exponent types, the entry is None.</p>
</dd>
<dt><strong>sigma_bar_k_offset: list of int</strong></dt><dd><p>For exponents of type “+” or “-” the offset within the list of modes
of the corresponding “-” or “+” exponent. For other exponent types,
the entry is None.</p>
</dd>
<dt><strong>labels: list of tuples</strong></dt><dd><p>A list of the ADO labels within the hierarchy.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOs.exps">
<code class="sig-name descname"><span class="pre">exps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs.exps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs.exps" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an ADO label into a tuple of exponents, with one exponent
for each “excitation” within the label.</p>
<p>The number of exponents returned is always equal to the level of the
label within the hierarchy (i.e. the sum of the indices within the
label).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to convert to a list of exponents.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple of BathExponent</dt><dd><p>A tuple of BathExponents.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((1,</span> <span class="pre">0,</span> <span class="pre">0))</span></code> would return <code class="docutils literal notranslate"><span class="pre">[ados.exponents[0]]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((2,</span> <span class="pre">0,</span> <span class="pre">0))</span></code> would return
<code class="docutils literal notranslate"><span class="pre">[ados.exponents[0],</span> <span class="pre">ados.exponents[0]]</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((1,</span> <span class="pre">2,</span> <span class="pre">1))</span></code> would return
<code class="docutils literal notranslate"><span class="pre">[ados.exponents[0],</span> <span class="pre">ados.exponents[1],</span> <span class="pre">ados.exponents[1],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">ados.exponents[2]]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOs.filter">
<code class="sig-name descname"><span class="pre">filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs.filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of ADO labels for ADOs whose “excitations”
match the given patterns.</p>
<p>Each of the filter parameters (tags, dims, types) may be either
unspecified (None) or a list. Unspecified parameters are excluded
from the filtering.</p>
<p>All specified filter parameters must be lists of the same length.
Each position in the lists describes a particular excitation and
any exponent that matches the filters may supply that excitation.
The level of all labels returned is thus equal to the length of
the filter parameter lists.</p>
<p>Within a filter parameter list, items that are None represent
wildcards and match any value of that exponent attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int</span></dt><dd><p>The hierarchy depth to return ADOs from.</p>
</dd>
<dt><strong>tags</strong><span class="classifier">list of object or None</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.tag</span></code> attribute of
exponents.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of int</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.dim</span></code> attribute of
exponents.</p>
</dd>
<dt><strong>types</strong><span class="classifier">list of BathExponent types or list of str</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.type</span></code> attribute
of exponents. Types may be supplied by name (e.g. “R”, “I”, “+”)
instead of by the actual type (e.g. <code class="docutils literal notranslate"><span class="pre">BathExponent.types.R</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of tuple</dt><dd><p>The ADO label for each ADO whose exponent excitations
(i.e. label) match the given filters or level.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOs.idx">
<code class="sig-name descname"><span class="pre">idx</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs.idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs.idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the ADO label within the list of labels,
i.e. within <code class="docutils literal notranslate"><span class="pre">self.labels</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The label to look up.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>The index of the label within the list of ADO labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOs.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ADO label with one more excitation in the k’th exponent
dimension or <code class="docutils literal notranslate"><span class="pre">None</span></code> if adding the excitation would exceed the
dimension or maximum depth of the hierarchy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to add an excitation to.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The exponent to add the excitation to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple or None</dt><dd><p>The next label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOs.prev">
<code class="sig-name descname"><span class="pre">prev</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOs.prev"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOs.prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ADO label with one fewer excitation in the k’th
exponent dimension or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the label has no exciations in the
k’th exponent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to remove the excitation from.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The exponent to remove the excitation from.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple or None</dt><dd><p>The previous label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.heom.HierarchyADOsState">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HierarchyADOsState</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ados</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ado_state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOsState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOsState" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides convenient access to the full hierarchy ADO state at a particular
point in time, <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The current state of the system (i.e. the 0th component of the
hierarchy).</p>
</dd>
<dt><strong>ados</strong><span class="classifier"><a class="reference internal" href="#qutip.nonmarkov.heom.HierarchyADOs" title="qutip.nonmarkov.heom.HierarchyADOs"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOs</span></code></a></span></dt><dd><p>The description of the hierarchy.</p>
</dd>
<dt><strong>ado_state</strong><span class="classifier">numpy.array</span></dt><dd><p>The full state of the hierarchy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>The system state.</p>
</dd>
<dt><strong>In addition, all of the attributes of the hierarchy description,</strong></dt><dd></dd>
<dt><strong>i.e. ``HierarchyADOs``, are provided directly on this class for</strong></dt><dd></dd>
<dt><strong>convenience. E.g. one can access ``.labels``, or ``.exponents`` or</strong></dt><dd></dd>
<dt><strong>call ``.idx(label)`` directly.</strong></dt><dd></dd>
<dt><strong>See :class:`HierarchyADOs` for a full list of the available attributes</strong></dt><dd></dd>
<dt><strong>and methods.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.heom.HierarchyADOsState.extract">
<code class="sig-name descname"><span class="pre">extract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_or_label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/bofin_solvers.html#HierarchyADOsState.extract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HierarchyADOsState.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a Qobj representing specified ADO from a full representation of
the ADO states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int or label</span></dt><dd><p>The index of the ADO to extract. If an ADO label, e.g.
<code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">...)</span></code> is supplied instead, then the ADO
is extracted by label instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj</dt><dd><p>A <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> representing the state of the specified ADO.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.dlheom_solver.HSolverDL">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HSolverDL</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_strength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">planck</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boltzmann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cut_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HSolverDL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HSolverDL" title="Permalink to this definition">¶</a></dt>
<dd><p>HEOM solver based on the Drude-Lorentz model for spectral density.
Drude-Lorentz bath the correlation functions can be exactly analytically
expressed as an infinite sum of exponentials which depend on the
temperature, these are called the Matsubara terms or Matsubara frequencies</p>
<p>For practical computation purposes an approximation must be used based
on a small number of Matsubara terms (typically &lt; 4).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cut_freq</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>renorm</strong><span class="classifier">bool</span></dt><dd><p>Apply renormalisation to coupling terms
Can be useful if using SI units for planck and boltzmann</p>
</dd>
<dt><strong>bnd_cut_approx</strong><span class="classifier">bool</span></dt><dd><p>Use boundary cut off approximation
Can be</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HSolverDL.configure">
<code class="sig-name descname"><span class="pre">configure</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_strength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">planck</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boltzmann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cut_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HSolverDL.configure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HSolverDL.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls configure from <a class="reference internal" href="#qutip.nonmarkov.dlheom_solver.HEOMSolver" title="qutip.nonmarkov.dlheom_solver.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> and sets any attributes
that are specific to this subclass</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HSolverDL.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HSolverDL.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HSolverDL.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any attributes to default values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HSolverDL.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HSolverDL.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HSolverDL.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to solve for an open quantum system using the
HEOM model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rho0</strong><span class="classifier">Qobj</span></dt><dd><p>Initial state (density matrix) of the system.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list</span></dt><dd><p>Time over which system evolves.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt><dd><p>Object storing all results from the simulation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.dlheom_solver.HEOMSolver">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HEOMSolver</span></code><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HEOMSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HEOMSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>This is superclass for all solvers that use the HEOM method for
calculating the dynamics evolution. There are many references for this.
A good introduction, and perhaps closest to the notation used here is:
DOI:10.1103/PhysRevLett.104.250401
A more canonical reference, with full derivation is:
DOI: 10.1103/PhysRevA.41.6676
The method can compute open system dynamics without using any Markovian
or rotating wave approximation (RWA) for systems where the bath
correlations can be approximated to a sum of complex eponentials.
The method builds a matrix of linked differential equations, which are
then solved used the same ODE solvers as other qutip solvers (e.g. mesolve)</p>
<p>This class should be treated as abstract. Currently the only subclass
implemented is that for the Drude-Lorentz spectral density. This covers
the majority of the work that has been done using this model, and there
are some performance advantages to assuming this model where it is
appropriate.</p>
<p>There are opportunities to develop a more general spectral density code.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>H_sys</strong><span class="classifier">Qobj</span></dt><dd><p>System Hamiltonian</p>
</dd>
<dt><strong>coup_op</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>coup_strength</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>temperature</strong><span class="classifier">float</span></dt><dd><p>Bath temperature, in units corresponding to planck</p>
</dd>
<dt><strong>N_cut</strong><span class="classifier">int</span></dt><dd><p>Cutoff parameter for the bath</p>
</dd>
<dt><strong>N_exp</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions</p>
</dd>
<dt><strong>planck</strong><span class="classifier">float</span></dt><dd><p>reduced Planck constant</p>
</dd>
<dt><strong>boltzmann</strong><span class="classifier">float</span></dt><dd><p>Boltzmann’s constant</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options.
If set to None the default options will be used</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
<dt><strong>stats</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Stats" title="qutip.solver.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Stats</span></code></a></span></dt><dd><p>optional container for holding performance statitics
If None is set, then statistics are not collected
There may be an overhead in collecting statistics</p>
</dd>
<dt><strong>exp_coeff</strong><span class="classifier">list of complex</span></dt><dd><p>Coefficients for the exponential series terms</p>
</dd>
<dt><strong>exp_freq</strong><span class="classifier">list of complex</span></dt><dd><p>Frequencies for the exponential series terms</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HEOMSolver.configure">
<code class="sig-name descname"><span class="pre">configure</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_strength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">planck</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boltzmann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cut_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HEOMSolver.configure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HEOMSolver.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the solver using the passed parameters
The parameters are described in the class attributes, unless there
is some specific behaviour</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options.
If set to None the default options will be used</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt><dd><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.
If set to None, then the default progress bar will be used
Set to False for no progress bar</p>
</dd>
<dt><strong>stats: :class:`qutip.solver.Stats`</strong></dt><dd><p>Optional instance of solver.Stats, or a subclass thereof, for
storing performance statistics for the solver
If set to True, then the default Stats for this class will be used
Set to False for no stats</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HEOMSolver.create_new_stats">
<code class="sig-name descname"><span class="pre">create_new_stats</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HEOMSolver.create_new_stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HEOMSolver.create_new_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new stats object suitable for use with this solver
Note: this solver expects the stats object to have sections</p>
<ul class="simple">
<li><p>config</p></li>
<li><p>integrate</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.dlheom_solver.HEOMSolver.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/dlheom_solver.html#HEOMSolver.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.dlheom_solver.HEOMSolver.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">MemoryCascade</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops_markov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'propagator'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/memorycascade.html#MemoryCascade"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for running memory cascade simulations of open quantum systems
with time-delayed coherent feedback.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>H_S</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System Hamiltonian (can also be a Liouvillian)</p>
</dd>
<dt><strong>L1</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System operators coupling into the feedback loop. Can be a single
operator or a list of operators.</p>
</dd>
<dt><strong>L2</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>System operators coupling out of the feedback loop. Can be a single
operator or a list of operators. L2 must have the same length as L1.</p>
</dd>
<dt><strong>S_matrix: *array*</strong></dt><dd><p>S matrix describing which operators in L1 are coupled to which
operators in L2 by the feedback channel. Defaults to an n by n identity
matrix where n is the number of elements in L1/L2.</p>
</dd>
<dt><strong>c_ops_markov</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Decay operators describing conventional Markovian decay channels.
Can be a single operator or a list of operators.</p>
</dd>
<dt><strong>integrator</strong><span class="classifier">str {‘propagator’, ‘mesolve’}</span></dt><dd><p>Integrator method to use. Defaults to ‘propagator’ which tends to be
faster for long times (i.e., large Hilbert space).</p>
</dd>
<dt><strong>parallel</strong><span class="classifier">bool</span></dt><dd><p>Run integrator in parallel if True. Only implemented for ‘propagator’
as the integrator method.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr">
<code class="sig-name descname"><span class="pre">outfieldcorr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.outfieldcorr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute output field expectation value
&lt;O_n(tn)…O_2(t2)O_1(t1)&gt; for times t1,t2,… and
O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>blist</strong><span class="classifier">array_like</span></dt><dd><p>List of integers specifying the field operators:
0: I (nothing)
1: b_out
2: b_out^dagger
3: b_loop
4: b_loop^dagger</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of corresponding times t1,..,tn at which to evaluate the field
operators</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>time-delay</p>
</dd>
<dt><strong>c1</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>system collapse operator that couples to the in-loop field in
question (only needs to be specified if self.L1 has more than one
element)</p>
</dd>
<dt><strong>c2</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>system collapse operator that couples to the output field in
question (only needs to be specified if self.L2 has more than one
element)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>: complex</dt><dd><p>expectation value of field correlation function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator">
<code class="sig-name descname"><span class="pre">outfieldpropagator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notrace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.outfieldpropagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute propagator for computing output field expectation values
&lt;O_n(tn)…O_2(t2)O_1(t1)&gt; for times t1,t2,… and
O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>blist</strong><span class="classifier">array_like</span></dt><dd><p>List of integers specifying the field operators:
0: I (nothing)
1: b_out
2: b_out^dagger
3: b_loop
4: b_loop^dagger</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array_like</span></dt><dd><p>list of corresponding times t1,..,tn at which to evaluate the field
operators</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>time-delay</p>
</dd>
<dt><strong>c1</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>system collapse operator that couples to the in-loop field in
question (only needs to be specified if self.L1 has more than one
element)</p>
</dd>
<dt><strong>c2</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>system collapse operator that couples to the output field in
question (only needs to be specified if self.L2 has more than one
element)</p>
</dd>
<dt><strong>notrace</strong><span class="classifier">bool {False}</span></dt><dd><p>If this optional is set to True, a propagator is returned for a
cascade of k systems, where <span class="math notranslate nohighlight">\((k-1) tau &lt; t &lt; k tau\)</span>.
If set to False (default), a generalized partial trace is performed
and a propagator for a single system is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>: <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></dt><dd><p>time-propagator for computing field correlation function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.propagator">
<code class="sig-name descname"><span class="pre">propagator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">notrace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute propagator for time t and time-delay tau</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>t</strong><span class="classifier"><em>float</em></span></dt><dd><p>current time</p>
</dd>
<dt><strong>tau</strong><span class="classifier"><em>float</em></span></dt><dd><p>time-delay</p>
</dd>
<dt><strong>notrace</strong><span class="classifier"><em>bool</em> {False}</span></dt><dd><p>If this optional is set to True, a propagator is returned for a
cascade of k systems, where <span class="math notranslate nohighlight">\((k-1) tau &lt; t &lt; k tau\)</span>.
If set to False (default), a generalized partial trace is performed
and a propagator for a single system is returned.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>: :class:`qutip.Qobj`</strong></dt><dd><p>time-propagator for reduced system dynamics</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.rhot">
<code class="sig-name descname"><span class="pre">rhot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.rhot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.rhot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the reduced system density matrix <span class="math notranslate nohighlight">\(\rho(t)\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho0</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>initial density matrix or state vector (ket)</p>
</dd>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>current time</p>
</dd>
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>time-delay</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>: <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></dt><dd><p>density matrix at time <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.nonmarkov.transfertensor.TTMSolverOptions">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">TTMSolverOptions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynmaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learningtimes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thres</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/nonmarkov/transfertensor.html#TTMSolverOptions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.TTMSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for the Transfer Tensor Method solver.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>dynmaps</strong><span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</dd>
<dt><strong>times</strong><span class="classifier">array_like</span></dt><dd><p>List of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to calculate <span class="math notranslate nohighlight">\(\rho(t_n)\)</span></p>
</dd>
<dt><strong>learningtimes</strong><span class="classifier">array_like</span></dt><dd><p>List of times <span class="math notranslate nohighlight">\(t_k\)</span> to use as learning times if argument
<cite>dynmaps</cite> is a callback function.</p>
</dd>
<dt><strong>thres</strong><span class="classifier">float</span></dt><dd><p>Threshold for halting. Halts if  <span class="math notranslate nohighlight">\(||T_{n}-T_{n-1}||\)</span> is below
treshold.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="solver-options-and-results">
<span id="classes-odeoptions"></span><h2>Solver Options and Results<a class="headerlink" href="#solver-options-and-results" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.solver.ExpectOps">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">ExpectOps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">super_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#ExpectOps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.ExpectOps" title="Permalink to this definition">¶</a></dt>
<dd><p>Contain and compute expectation values</p>
</dd></dl>

<dl class="py class">
<dt id="qutip.solver.Options">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Options</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'adams'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_expect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tidy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cpus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_t_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs_reuse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs_filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gui</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs_with_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_final_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steady_state_average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_openmp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">openmp_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Options"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Options" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for evolution solvers such as <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> and
<a class="reference internal" href="functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a>. Options can be specified either as arguments to the
constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>or by changing the class attributes after creation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>
<span class="n">opts</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Returns options class to be used as options in evolution solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atol</strong><span class="classifier">float {1e-8}</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float {1e-6}</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str {‘adams’,’bdf’}</span></dt><dd><p>Integration method.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int {12}</span></dt><dd><p>Order of integrator (&lt;=12 ‘adams’, &lt;=5 ‘bdf’)</p>
</dd>
<dt><strong>nsteps</strong><span class="classifier">int {2500}</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt><strong>first_step</strong><span class="classifier">float {0}</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt><strong>min_step</strong><span class="classifier">float {0}</span></dt><dd><p>Minimum step size (0 = automatic).</p>
</dd>
<dt><strong>max_step</strong><span class="classifier">float {0}</span></dt><dd><p>Maximum step size (0 = automatic)</p>
</dd>
<dt><strong>tidy</strong><span class="classifier">bool {True,False}</span></dt><dd><p>Tidyup Hamiltonian and initial state by removing small terms.</p>
</dd>
<dt><strong>num_cpus</strong><span class="classifier">int</span></dt><dd><p>Number of cpus used by mcsolver (default = # of cpus).</p>
</dd>
<dt><strong>norm_tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used when finding wavefunction norm in mcsolve.</p>
</dd>
<dt><strong>norm_steps</strong><span class="classifier">int</span></dt><dd><p>Max. number of steps used to find wavefunction norm to within norm_tol
in mcsolve.</p>
</dd>
<dt><strong>average_states</strong><span class="classifier">bool {False}</span></dt><dd><p>Average states values over trajectories in stochastic solvers.</p>
</dd>
<dt><strong>average_expect</strong><span class="classifier">bool {True}</span></dt><dd><p>Average expectation values over trajectories for stochastic solvers.</p>
</dd>
<dt><strong>mc_corr_eps</strong><span class="classifier">float {1e-10}</span></dt><dd><p>Arbitrarily small value for eliminating any divide-by-zero errors in
correlation calculations when using mcsolve.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int {500}</span></dt><dd><p>Number of trajectories in stochastic solvers.</p>
</dd>
<dt><strong>openmp_threads</strong><span class="classifier">int</span></dt><dd><p>Number of OPENMP threads to use. Default is number of cpu cores.</p>
</dd>
<dt><strong>rhs_reuse</strong><span class="classifier">bool {False,True}</span></dt><dd><p>Reuse Hamiltonian data.</p>
</dd>
<dt><strong>rhs_with_state</strong><span class="classifier">bool {False,True}</span></dt><dd><p>Whether or not to include the state in the Hamiltonian function
callback signature.</p>
</dd>
<dt><strong>rhs_filename</strong><span class="classifier">str</span></dt><dd><p>Name for compiled Cython file.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">ndarray</span></dt><dd><p>Array containing random number seeds for mcsolver.</p>
</dd>
<dt><strong>store_final_state</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt><strong>store_states</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Whether or not to store the state vectors or density matrices in the
result class, even if expectation values operators are given. If no
expectation are provided, then states are stored by default and this
option has no effect.</p>
</dd>
<dt><strong>use_openmp</strong><span class="classifier">bool {True, False}</span></dt><dd><p>Use OPENMP for sparse matrix vector multiplication. Default
None means auto check.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.solver.Result">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Result</span></code><a class="reference internal" href="../modules/qutip/solver.html#Result"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Result" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for storing simulation results from any of the dynamics solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]</p>
</dd>
<dt><strong>times</strong><span class="classifier">list/array</span></dt><dd><p>Times at which simulation data was collected.</p>
</dd>
<dt><strong>expect</strong><span class="classifier">list/array</span></dt><dd><p>Expectation values (if requested) for simulation.</p>
</dd>
<dt><strong>states</strong><span class="classifier">array</span></dt><dd><p>State of the simulation (density matrix or ket) evaluated at <code class="docutils literal notranslate"><span class="pre">times</span></code>.</p>
</dd>
<dt><strong>num_expect</strong><span class="classifier">int</span></dt><dd><p>Number of expectation value operators in simulation.</p>
</dd>
<dt><strong>num_collapse</strong><span class="classifier">int</span></dt><dd><p>Number of collapse operators in simualation.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int/list</span></dt><dd><p>Number of trajectories (for stochastic solvers). A list indicates
that averaging of expectation values was done over a subset of total
number of trajectories.</p>
</dd>
<dt><strong>col_times</strong><span class="classifier">list</span></dt><dd><p>Times at which state collpase occurred. Only for Monte Carlo solver.</p>
</dd>
<dt><strong>col_which</strong><span class="classifier">list</span></dt><dd><p>Which collapse operator was responsible for each collapse in
<code class="docutils literal notranslate"><span class="pre">col_times</span></code>. Only for Monte Carlo solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.solver.SolverConfiguration">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">SolverConfiguration</span></code><a class="reference internal" href="../modules/qutip/solver.html#SolverConfiguration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.SolverConfiguration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="qutip.solver.Stats">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Stats</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">section_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Statistical information on the solver performance
Statistics can be grouped into sections.
If no section names are given in the the contructor, then all statistics
will be added to one section ‘main’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>section_names</strong><span class="classifier">list</span></dt><dd><p>list of keys that will be used as keys for the sections
These keys will also be used as names for the sections
The text in the output can be overidden by setting the header property
of the section
If no names are given then one section called ‘main’ is created</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sections</strong><span class="classifier">OrderedDict of _StatsSection</span></dt><dd><p>These are the sections that are created automatically on instantiation
or added using add_section</p>
</dd>
<dt><strong>header</strong><span class="classifier">string</span></dt><dd><p>Some text that will be used as the heading in the report
By default there is None</p>
</dd>
<dt><strong>total_time</strong><span class="classifier">float</span></dt><dd><p>Time in seconds for the solver to complete processing
Can be None, meaning that total timing percentages will be reported</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.solver.Stats.add_count">
<code class="sig-name descname"><span class="pre">add_count</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.add_count"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.add_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to count. If key does not already exist in section then
it is created with this value.
If key already exists it is increased by the give value
value is expected to be an integer</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>key for the section.counts dictionary
reusing a key will result in numerical addition of value</p>
</dd>
<dt><strong>value</strong><span class="classifier">int</span></dt><dd><p>Initial value of the count, or added to an existing count</p>
</dd>
<dt><strong>section</strong><span class="classifier">string or <code class="xref py py-class docutils literal notranslate"><span class="pre">_StatsSection</span></code></span></dt><dd><p>Section which to add the count to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.add_message">
<code class="sig-name descname"><span class="pre">add_message</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">';'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.add_message"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.add_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to message. If key does not already exist in section then
it is created with this value.
If key already exists the value is added to the message
The value will be converted to a string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>key for the section.messages dictionary
reusing a key will result in concatenation of value</p>
</dd>
<dt><strong>value</strong><span class="classifier">int</span></dt><dd><p>Initial value of the message, or added to an existing message</p>
</dd>
<dt><strong>sep</strong><span class="classifier">string</span></dt><dd><p>Message will be prefixed with this string when concatenating</p>
</dd>
<dt><strong>section: string or `class`</strong><span class="classifier">_StatsSection</span></dt><dd><p>Section which to add the message to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.add_section">
<code class="sig-name descname"><span class="pre">add_section</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.add_section"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.add_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another section with the given name</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>will be used as key for sections dict
will also be the header for the section</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>section</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">_StatsSection</span></code></span></dt><dd><p>The new section</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.add_timing">
<code class="sig-name descname"><span class="pre">add_timing</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.add_timing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.add_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to timing. If key does not already exist in section then
it is created with this value.
If key already exists it is increased by the give value
value is expected to be a float, and given in seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">string</span></dt><dd><p>key for the section.timings dictionary
reusing a key will result in numerical addition of value</p>
</dd>
<dt><strong>value</strong><span class="classifier">int</span></dt><dd><p>Initial value of the timing, or added to an existing timing</p>
</dd>
<dt><strong>section: string or `class`</strong><span class="classifier">_StatsSection</span></dt><dd><p>Section which to add the timing to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.clear">
<code class="sig-name descname"><span class="pre">clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear counts, timings and messages from all sections</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.report">
<code class="sig-name descname"><span class="pre">report</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">output=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.report"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the counts, timings and messages from the sections.
Sections are reported in the order that the names were supplied
in the constructor.
The counts, timings and messages are reported in the order that they
are added to the sections
The output can be written to anything that supports a write method,
e.g. a file or the console (default)
The output is intended to in markdown format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output</strong><span class="classifier">stream</span></dt><dd><p>file or console stream - anything that support write - where
the output will be written</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.solver.Stats.set_total_time">
<code class="sig-name descname"><span class="pre">set_total_time</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver.html#Stats.set_total_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.Stats.set_total_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the total time for the complete solve or for a specific section
value is expected to be a float, and given in seconds</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>value</strong><span class="classifier">float</span></dt><dd><p>Time in seconds to complete the solver section</p>
</dd>
<dt><strong>section</strong><span class="classifier">string or <cite>class</cite></span></dt><dd><p>Section which to set the total_time for
If None given, the total_time for complete solve is set</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.stochastic.StochasticSolverOptions">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">StochasticSolverOptions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">me</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_all_expect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_measurement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dW_factors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'homodyne'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsubsteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noiseDepth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/stochastic.html#StochasticSolverOptions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.stochastic.StochasticSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for stochastic solvers such as
<a class="reference internal" href="functions.html#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.ssesolve</span></code></a>, <a class="reference internal" href="functions.html#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.smesolve</span></code></a>, etc.</p>
<p>The stochastic solvers <a class="reference internal" href="functions.html#qutip.stochastic.general_stochastic" title="qutip.stochastic.general_stochastic"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.general_stochastic</span></code></a>,
<a class="reference internal" href="functions.html#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.ssesolve</span></code></a>, <a class="reference internal" href="functions.html#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.smesolve</span></code></a>,
<a class="reference internal" href="functions.html#qutip.stochastic.photocurrent_sesolve" title="qutip.stochastic.photocurrent_sesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_sesolve</span></code></a> and
<a class="reference internal" href="functions.html#qutip.stochastic.photocurrent_mesolve" title="qutip.stochastic.photocurrent_mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_mesolve</span></code></a>
all take the same keyword arguments as
the constructor of these class, and internally they use these arguments to
construct an instance of this class, so it is rarely needed to explicitly
create an instance of this class.</p>
<p>Within the attribute list, a <code class="docutils literal notranslate"><span class="pre">time_dependent_object</span></code> is either</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>: a constant term</p></li>
<li><p>2-element list of <code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">time_dependence]</span></code>: a time-dependent term
where the <code class="docutils literal notranslate"><span class="pre">Qobj</span></code> will be multiplied by the time-dependent scalar.</p></li>
</ul>
<p>For more details on all allowed time-dependent objects, see the
documentation for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier">time_dependent_object or list of time_dependent_object</span></dt><dd><p>System Hamiltonian in standard time-dependent list format.  This is the
same as the argument that (e.g.) <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">mesolve</span></code></a> takes.
If this is a list of elements, they are summed.</p>
</dd>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Initial state vector (ket) or density matrix.</p>
</dd>
<dt><strong>times</strong><span class="classifier">array_like of float</span></dt><dd><p>List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of time_dependent_object</span></dt><dd><p>List of deterministic collapse operators.  Each element of the list is
a separate operator; unlike the Hamiltonian, there is no implicit
summation over the terms.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of time_dependent_object</span></dt><dd><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the equation of motion according to how the d1 and d2 functions
are defined.  Each element of the list is a separate operator, like
<code class="docutils literal notranslate"><span class="pre">c_ops</span></code>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>Single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>m_ops</strong><span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>List of operators representing the measurement operators. The expected
format is a nested list with one measurement operator for each
stochastic increament, for each stochastic collapse operator.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of parameters for time dependent systems.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance of the solver for implicit methods.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectors.</p>
</dd>
<dt><strong>nsubsteps</strong><span class="classifier">int</span></dt><dd><p>Number of sub steps between each time-spep given in <cite>times</cite>.</p>
</dd>
<dt><strong>dW_factors</strong><span class="classifier">array</span></dt><dd><p>Array of length len(sc_ops), containing scaling factors for each
measurement operator in m_ops.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">string</span></dt><dd><p>Name of the solver method to use for solving the stochastic
equations. Valid values are:</p>
<ul class="simple">
<li><p>order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’</p></li>
<li><p>order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’</p></li>
<li><p>order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’</p></li>
<li><p>order 2 algorithms: ‘taylor2.0’</p></li>
</ul>
<p>See the documentation of <a class="reference internal" href="functions.html#qutip.stochastic.stochastic_solvers" title="qutip.stochastic.stochastic_solvers"><code class="xref py py-func docutils literal notranslate"><span class="pre">stochastic_solvers</span></code></a>
for a description of the solvers.  Implicit methods can adjust
tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}</p>
</dd>
<dt><strong>method</strong><span class="classifier">string (‘homodyne’, ‘heterodyne’)</span></dt><dd><p>The name of the type of measurement process that give rise to the
stochastic equation to solve.</p>
</dd>
<dt><strong>store_all_expect</strong><span class="classifier">bool (default False)</span></dt><dd><p>Whether or not to store the e_ops expect values for all paths.</p>
</dd>
<dt><strong>store_measurement</strong><span class="classifier">bool (default False)</span></dt><dd><p>Whether or not to store the measurement results in the
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> instance returned by the solver.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">int, or 1D array of int, or 4D array of float</span></dt><dd><ul class="simple">
<li><p>int : seed of the noise</p></li>
<li><p>1D array : length = ntraj, seeds for each trajectories.</p></li>
<li><p>4D array : <code class="docutils literal notranslate"><span class="pre">(ntraj,</span> <span class="pre">len(times),</span> <span class="pre">nsubsteps,</span> <span class="pre">len(sc_ops)*[1|2])</span></code>.
Vector for the noise, the len of the last dimensions is doubled for
solvers of order 1.5. This corresponds to results.noise.</p></li>
</ul>
</dd>
<dt><strong>noiseDepth</strong><span class="classifier">int</span></dt><dd><p>Number of terms kept of the truncated series used to create the
noise used by taylor2.0 solver.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>(default True for (photo)ssesolve, False for (photo)smesolve)
Whether or not to normalize the wave function during the evolution.
Normalizing density matrices introduce numerical errors.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>Generic solver options. Only options.average_states and
options.store_states are used.</p>
</dd>
<dt><strong>map_func: function</strong></dt><dd><p>A map function or managing the calls to single-trajactory solvers.</p>
</dd>
<dt><strong>map_kwargs: dictionary</strong></dt><dd><p>Optional keyword arguments to the map_func function function.</p>
</dd>
<dt><strong>progress_bar</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.ui.BaseProgressBar</span></code></span></dt><dd><p>Optional progress bar class instance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="permutational-invariance">
<span id="classes-piqs"></span><h2>Permutational Invariance<a class="headerlink" href="#permutational-invariance" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.piqs.Dicke">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Dicke</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke" title="Permalink to this definition">¶</a></dt>
<dd><p>The Dicke class which builds the Lindbladian and Liouvillian matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>hamiltonian</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A Hamiltonian in the Dicke basis.</p>
<p>The matrix dimensions are (nds, nds),
with nds being the number of Dicke states.
The Hamiltonian can be built with the operators
given by the <cite>jspin</cite> functions.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">piqs</span> <span class="kn">import</span> <span class="n">Dicke</span><span class="p">,</span> <span class="n">jspin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jx</span><span class="p">,</span> <span class="n">jy</span><span class="p">,</span> <span class="n">jz</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jp</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jm</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensemble</span> <span class="o">=</span> <span class="n">Dicke</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">emission</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">liouvillian</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>hamiltonian</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>A Hamiltonian in the Dicke basis.</p>
<p>The matrix dimensions are (nds, nds),
with nds being the number of Dicke states.
The Hamiltonian can be built with the operators given
by the <cite>jspin</cite> function in the “dicke” basis.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>nds: int</strong></dt><dd><p>The number of Dicke states.</p>
</dd>
<dt><strong>dshape: tuple</strong></dt><dd><p>The shape of the Hilbert space in the Dicke or uncoupled basis.
default: (nds, nds).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.piqs.Dicke.c_ops">
<code class="sig-name descname"><span class="pre">c_ops</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke.c_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke.c_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Build collapse operators in the full Hilbert space 2^N.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>c_ops_list: list</dt><dd><p>The list with the collapse operators in the 2^N Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Dicke.coefficient_matrix">
<code class="sig-name descname"><span class="pre">coefficient_matrix</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke.coefficient_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke.coefficient_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Build coefficient matrix for ODE for a diagonal problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>M: ndarray</dt><dd><p>The matrix M of the coefficients for the ODE dp/dt = Mp.
p is the vector of the diagonal matrix elements
of the density matrix rho in the Dicke basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Dicke.lindbladian">
<code class="sig-name descname"><span class="pre">lindbladian</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke.lindbladian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke.lindbladian" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the Lindbladian superoperator of the dissipative dynamics.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>lindbladian</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The Lindbladian matrix as a <cite>qutip.Qobj</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Dicke.liouvillian">
<code class="sig-name descname"><span class="pre">liouvillian</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke.liouvillian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the total Liouvillian using the Dicke basis.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>liouv</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>The Liouvillian matrix for the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Dicke.pisolve">
<code class="sig-name descname"><span class="pre">pisolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Dicke.pisolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Dicke.pisolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for diagonal Hamiltonians and initial states faster.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>initial_state</strong><span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt><dd><p>An initial state specified as a density matrix of
<cite>qutip.Qbj</cite> type.</p>
</dd>
<dt><strong>tlist: ndarray</strong></dt><dd><p>A 1D numpy array of list of timesteps to integrate</p>
</dd>
<dt><strong>options</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt><dd><p>The options for the solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: list</dt><dd><p>A dictionary of the type <cite>qutip.solver.Result</cite> which holds the
results of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.piqs.Pim">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Pim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim" title="Permalink to this definition">¶</a></dt>
<dd><p>The Permutation Invariant Matrix class.</p>
<p>Initialize the class with the parameters for generating a Permutation
Invariant matrix which evolves a given diagonal initial state <cite>p</cite> as:</p>
<blockquote>
<div><p>dp/dt = Mp</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>M: dict</strong></dt><dd><p>A nested dictionary of the structure {row: {col: val}} which holds
non zero elements of the matrix M</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.piqs.Pim.calculate_j_m">
<code class="sig-name descname"><span class="pre">calculate_j_m</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.calculate_j_m"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.calculate_j_m" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of j and m for the particular Dicke space element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col: int</strong></dt><dd><p>The row and column from the Dicke space matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>j, m: float</dt><dd><p>The j and m values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.calculate_k">
<code class="sig-name descname"><span class="pre">calculate_k</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.calculate_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.calculate_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Get k value from the current row and column element in the Dicke space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col: int</strong></dt><dd><p>The row and column from the Dicke space matrix.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>k: int</strong></dt><dd><p>The row index for the matrix M for given Dicke space
element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.coefficient_matrix">
<code class="sig-name descname"><span class="pre">coefficient_matrix</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.coefficient_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.coefficient_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the matrix M governing the dynamics for diagonal cases.</p>
<p>If the initial density matrix and the Hamiltonian is diagonal, the
evolution of the system is given by the simple ODE: dp/dt = Mp.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.isdicke">
<code class="sig-name descname"><span class="pre">isdicke</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.isdicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.isdicke" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an element in a matrix is a valid element in the Dicke space.
Dicke row: j value index. Dicke column: m value index.
The function returns True if the element exists in the Dicke space and
False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col</strong><span class="classifier">int</span></dt><dd><p>Index of the element in Dicke space which needs to be checked</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.solve">
<code class="sig-name descname"><span class="pre">solve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the ODE for the evolution of diagonal states and Hamiltonians.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau1">
<code class="sig-name descname"><span class="pre">tau1</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m, m).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau2">
<code class="sig-name descname"><span class="pre">tau2</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau3">
<code class="sig-name descname"><span class="pre">tau3</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau3" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau4">
<code class="sig-name descname"><span class="pre">tau4</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau4"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau4" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau5">
<code class="sig-name descname"><span class="pre">tau5</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m, m).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau6">
<code class="sig-name descname"><span class="pre">tau6</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau6"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau6" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m, m).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau7">
<code class="sig-name descname"><span class="pre">tau7</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau7"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau7" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau8">
<code class="sig-name descname"><span class="pre">tau8</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau8"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau8" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau9">
<code class="sig-name descname"><span class="pre">tau9</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau9"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau9" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.piqs.Pim.tau_valid">
<code class="sig-name descname"><span class="pre">tau_valid</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs.html#Pim.tau_valid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.Pim.tau_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the Tau functions which are valid for this value of (dicke_row,
dicke_col) given the number of TLS. This calculates the valid tau
values and reurns a dictionary specifying the tau function name and
the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col</strong><span class="classifier">int</span></dt><dd><p>Index of the element in Dicke space which needs to be checked.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>taus: dict</dt><dd><p>A dictionary of key, val as {tau: value} consisting of the valid
taus for this row and column of the Dicke space element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="one-dimensional-lattice">
<span id="classes-distributions"></span><h2>One-Dimensional Lattice<a class="headerlink" href="#one-dimensional-lattice" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.lattice.Lattice1d">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Lattice1d</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'periodic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_num_site</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_site_dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hamiltonian_of_cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inter_hop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing a 1d crystal.</p>
<p>The Lattice1d class can be defined with any specific unit cells and a
specified number of unit cells in the crystal. It can return dispersion
relationship, position operators, Hamiltonian in the position represention
etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_cell</strong><span class="classifier">int</span></dt><dd><p>The number of cells in the crystal.</p>
</dd>
<dt><strong>boundary</strong><span class="classifier">str</span></dt><dd><p>Specification of the type of boundary the crystal is defined with.</p>
</dd>
<dt><strong>cell_num_site</strong><span class="classifier">int</span></dt><dd><p>The number of sites in the unit cell.</p>
</dd>
<dt><strong>cell_site_dof</strong><span class="classifier">list of int/ int</span></dt><dd><p>The tensor structure  of the degrees of freedom at each site of a unit
cell.</p>
</dd>
<dt><strong>Hamiltonian_of_cell</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>The Hamiltonian of the unit cell.</p>
</dd>
<dt><strong>inter_hop</strong><span class="classifier">qutip.Qobj / list of Qobj</span></dt><dd><p>The coupling between the unit cell at i and at (i+unit vector)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>num_cell</strong><span class="classifier">int</span></dt><dd><p>The number of unit cells in the crystal.</p>
</dd>
<dt><strong>cell_num_site</strong><span class="classifier">int</span></dt><dd><p>The nuber of sites in a unit cell.</p>
</dd>
<dt><strong>length_for_site</strong><span class="classifier">int</span></dt><dd><p>The length of the dimension per site of a unit cell.</p>
</dd>
<dt><strong>cell_tensor_config</strong><span class="classifier">list of int</span></dt><dd><p>The tensor structure of the cell in the form
[cell_num_site,cell_site_dof[:][0] ]</p>
</dd>
<dt><strong>lattice_tensor_config</strong><span class="classifier">list of int</span></dt><dd><p>The tensor structure of the crystal in the
form [num_cell,cell_num_site,cell_site_dof[:][0]]</p>
</dd>
<dt><strong>length_of_unit_cell</strong><span class="classifier">int</span></dt><dd><p>The length of the dimension for a unit cell.</p>
</dd>
<dt><strong>period_bnd_cond_x</strong><span class="classifier">int</span></dt><dd><p>1 indicates “periodic” and 0 indicates “hardwall” boundary condition</p>
</dd>
<dt><strong>inter_vec_list</strong><span class="classifier">list of list</span></dt><dd><p>The list of list of coefficients of inter unitcell vectors’ components
along Cartesian uit vectors.</p>
</dd>
<dt><strong>lattice_vectors_list</strong><span class="classifier">list of list</span></dt><dd><p>The list of list of coefficients of lattice basis vectors’ components
along Cartesian unit vectors.</p>
</dd>
<dt><strong>H_intra</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>The Qobj storing the Hamiltonian of the unnit cell.</p>
</dd>
<dt><strong>H_inter_list</strong><span class="classifier">list of Qobj/ qutip.Qobj</span></dt><dd><p>The list of coupling terms between unit cells of the lattice.</p>
</dd>
<dt><strong>is_real</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the Hamiltonian is real or not.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.lattice.Lattice1d.Hamiltonian">
<code class="sig-name descname"><span class="pre">Hamiltonian</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.Hamiltonian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.Hamiltonian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lattice Hamiltonian for the instance of Lattice1d.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Qobj(Hamil)</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>oper type Quantum object representing the lattice Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.basis">
<code class="sig-name descname"><span class="pre">basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">site</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof_ind</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a single particle wavefunction ket with the particle localized
at a specified dof at a specified site of a specified cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> (<em>int</em>) – The cell at which the particle is to be localized.</p></li>
<li><p><strong>site</strong> (<em>int</em>) – The site of the cell at which the particle is to be localized.</p></li>
<li><p><strong>dof_ind</strong> (<em>int/ list of int</em>) – The index of the degrees of freedom with which the sigle particle
is to be localized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vec_i</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>ket type Quantum object representing the localized particle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.bloch_wave_functions">
<code class="sig-name descname"><span class="pre">bloch_wave_functions</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.bloch_wave_functions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.bloch_wave_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns eigenvectors ($psi_n(k)$) of the Hamiltonian in a
numpy.ndarray for translationally symmetric lattices with periodic
boundary condition.</p>
<div class="math notranslate nohighlight">
\begin{eqnarray}
|\psi_n(k) \rangle = |k \rangle \otimes | u_{n}(k) \rangle   \\
| u_{n}(k) \rangle = a_n(k)|a\rangle  + b_n(k)|b\rangle \\
\end{eqnarray}</div><p>Please see section 1.2 of Asbóth, J. K., Oroszlány, L., &amp; Pályi, A.
(2016). A short course on topological insulators. Lecture notes in
physics, 919 for a review.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>eigenstates</strong><span class="classifier">ordered np.array</span></dt><dd><p>eigenstates[j][0] is the jth eigenvalue.
eigenstates[j][1] is the corresponding eigenvector.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.bulk_Hamiltonians">
<code class="sig-name descname"><span class="pre">bulk_Hamiltonians</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.bulk_Hamiltonians"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.bulk_Hamiltonians" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bulk momentum space Hamiltonian ($H(k)$) for the lattice at
the good quantum numbers of k in a numpy ndarray of Qobj’s.</p>
<p>Please see section 1.2 of Asbóth, J. K., Oroszlány, L., &amp; Pályi, A.
(2016). A short course on topological insulators. Lecture notes in
physics, 919 for a review.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>knxa</strong><span class="classifier">np.array</span></dt><dd><p>knxA[j][0] is the jth good Quantum number k.</p>
</dd>
<dt><strong>qH_ks</strong><span class="classifier">np.ndarray of Qobj’s</span></dt><dd><p>qH_ks[j] is the Oobj of type oper that holds a bulk Hamiltonian
for a good quantum number k.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.cell_periodic_parts">
<code class="sig-name descname"><span class="pre">cell_periodic_parts</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.cell_periodic_parts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.cell_periodic_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic
part($u_n(k)$) of the Bloch wavefunctios in a numpy.ndarray for
translationally symmetric lattices with periodic boundary condition.</p>
<div class="math notranslate nohighlight">
\begin{eqnarray}
|\psi_n(k) \rangle = |k \rangle \otimes | u_{n}(k) \rangle   \\
| u_{n}(k) \rangle = a_n(k)|a\rangle  + b_n(k)|b\rangle \\
\end{eqnarray}</div><p>Please see section 1.2 of Asbóth, J. K., Oroszlány, L., &amp; Pályi, A.
(2016). A short course on topological insulators. Lecture notes in
physics, 919 for a review.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>knxa</strong><span class="classifier">np.array</span></dt><dd><p>knxA[j][0] is the jth good Quantum number k.</p>
</dd>
<dt><strong>vec_kns</strong><span class="classifier">np.ndarray of Qobj’s</span></dt><dd><p>vec_kns[j] is the Oobj of type ket that holds an eigenvector of the
bulk Hamiltonian of the lattice.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.display_lattice">
<code class="sig-name descname"><span class="pre">display_lattice</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.display_lattice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.display_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a graphic portraying the lattice symbolically with a unit cell
marked in it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inter_T</strong><span class="classifier">Qobj</span></dt><dd><p>The coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the
coupling between the two boundary sites of the two unit cells i and
i+1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.display_unit_cell">
<code class="sig-name descname"><span class="pre">display_unit_cell</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_on</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.display_unit_cell"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.display_unit_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a graphic displaying the unit cell features with labels on if
defined by user. Also returns a dict of Qobj’s corresponding to the
labeled elements on the display.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Hcell</strong><span class="classifier">dict</span></dt><dd><p>Hcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the
graphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.distribute_operator">
<code class="sig-name descname"><span class="pre">distribute_operator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.distribute_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.distribute_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that returns an operator matrix that applies op to all the
cells in the 1d lattice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>op</strong> (<a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><em>qutip.Qobj</em></a>) – Qobj representing the operator to be applied at all cells.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op_H</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>Quantum object representing the operator with op applied at all
cells.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.get_dispersion">
<code class="sig-name descname"><span class="pre">get_dispersion</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">knpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.get_dispersion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.get_dispersion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dispersion relationship for the lattice with the specified
number of unit cells with a k array and a band energy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>knxa</strong><span class="classifier">np.array</span></dt><dd><p>knxA[j][0] is the jth good Quantum number k.</p>
</dd>
<dt><strong>val_kns</strong><span class="classifier">np.array</span></dt><dd><p>val_kns[j][:] is the array of band energies of the jth band good at
all the good Quantum numbers of k.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.k">
<code class="sig-name descname"><span class="pre">k</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.k" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the crystal momentum operator. All degrees of freedom has the
cell number at their correspondig entry in the position operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Qobj(ks)</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>The crystal momentum operator in units of 1/a. L is the number
of unit cells, a is the length of a unit cell which is always taken
to be 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.operator_at_cells">
<code class="sig-name descname"><span class="pre">operator_at_cells</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.operator_at_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.operator_at_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that returns an operator matrix that applies op to specific
cells specified in the cells list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>Qobj representing the operator to be applied at certain cells.</p>
</dd>
<dt><strong>cells: list of int</strong></dt><dd><p>The cells at which the operator op is to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Qobj(op_H)</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing the operator with op applied at
the specified cells.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.operator_between_cells">
<code class="sig-name descname"><span class="pre">operator_between_cells</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cell</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.operator_between_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.operator_between_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that returns an operator matrix that applies op to specific
cells specified in the cells list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>Qobj representing the operator to be put between cells row_cell
and col_cell.</p>
</dd>
<dt><strong>row_cell: int</strong></dt><dd><p>The row index for cell for the operator op to be applied.</p>
</dd>
<dt><strong>col_cell: int</strong></dt><dd><p>The column index for cell for the operator op to be applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oper_bet_cell</strong><span class="classifier">Qobj</span></dt><dd><p>Quantum object representing the operator with op applied between
the specified cells.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.plot_dispersion">
<code class="sig-name descname"><span class="pre">plot_dispersion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.plot_dispersion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.plot_dispersion" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the dispersion relationship for the lattice with the specified
number of unit cells. The dispersion of the infinte crystal is also
plotted if num_cell is smaller than MAXc.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.winding_number">
<code class="sig-name descname"><span class="pre">winding_number</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.winding_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.winding_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the winding number for a lattice that has chiral symmetry and
also plots the trajectory of (dx,dy)(dx,dy are the coefficients of
sigmax and sigmay in the Hamiltonian respectively) on a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>winding_number</strong><span class="classifier">int or str</span></dt><dd><p>knxA[j][0] is the jth good Quantum number k.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.lattice.Lattice1d.x">
<code class="sig-name descname"><span class="pre">x</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/lattice.html#Lattice1d.x"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.lattice.Lattice1d.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position operator. All degrees of freedom has the cell
number at their correspondig entry in the position operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Qobj(xs)</strong><span class="classifier">qutip.Qobj</span></dt><dd><p>The position operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="distribution-functions">
<h2>Distribution functions<a class="headerlink" href="#distribution-functions" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.distributions.Distribution">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representation spatial distribution functions.</p>
<p>The Distribution class can be used to prepresent spatial distribution
functions of arbitray dimension (although only 1D and 2D distributions
are used so far).</p>
<p>It is indented as a base class for specific distribution function, and
provide implementation of basic functions that are shared among all
Distribution functions, such as visualization, calculating marginal
distributions, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Data for the distribution. The dimensions must match the lengths of
the coordinate arrays in xvecs.</p>
</dd>
<dt><strong>xvecs</strong><span class="classifier">list</span></dt><dd><p>List of arrays that spans the space for each coordinate.</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list</span></dt><dd><p>List of labels for each coordinate.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.distributions.Distribution.marginal">
<code class="sig-name descname"><span class="pre">marginal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.marginal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.marginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the marginal distribution function along the dimension
<cite>dim</cite>. Return a new Distribution instance describing this reduced-
dimensionality distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension (coordinate index) along which to obtain the
marginal distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">Distributions</span></dt><dd><p>A new instances of Distribution that describes the marginal
distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.distributions.Distribution.project">
<code class="sig-name descname"><span class="pre">project</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the projection (max value) distribution function along the
dimension <cite>dim</cite>. Return a new Distribution instance describing this
reduced-dimensionality distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension (coordinate index) along which to obtain the
projected distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">Distributions</span></dt><dd><p>A new instances of Distribution that describes the projection.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.distributions.Distribution.visualize">
<code class="sig-name descname"><span class="pre">visualize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'colormap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.visualize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the data of the distribution in 1D or 2D, depending
on the dimensionality of the underlaying distribution.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>fig<span class="classifier">matplotlib Figure instance</span></dt><dd><p>If given, use this figure instance for the visualization,</p>
</dd>
<dt>ax<span class="classifier">matplotlib Axes instance</span></dt><dd><p>If given, render the visualization using this axis instance.</p>
</dd>
<dt>figsize<span class="classifier">tuple</span></dt><dd><p>Size of the new Figure instance, if one needs to be created.</p>
</dd>
<dt>colorbar: Bool</dt><dd><p>Whether or not the colorbar (in 2D visualization) should be used.</p>
</dd>
<dt>cmap: matplotlib colormap instance</dt><dd><p>If given, use this colormap for 2D visualizations.</p>
</dd>
<dt>style<span class="classifier">string</span></dt><dd><p>Type of visualization: ‘colormap’ (default) or ‘surface’.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of matplotlib figure and axes instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.distributions.WignerDistribution">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">WignerDistribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[-</span> <span class="pre">5,</span> <span class="pre">5],</span> <span class="pre">[-</span> <span class="pre">5,</span> <span class="pre">5]]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#WignerDistribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.WignerDistribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="qutip.distributions.QDistribution">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">QDistribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[-</span> <span class="pre">5,</span> <span class="pre">5],</span> <span class="pre">[-</span> <span class="pre">5,</span> <span class="pre">5]]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#QDistribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.QDistribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">TwoModeQuadratureCorrelation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[-</span> <span class="pre">5,</span> <span class="pre">5],</span> <span class="pre">[-</span> <span class="pre">5,</span> <span class="pre">5]]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#TwoModeQuadratureCorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode wavefunction or density matrix</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update_psi">
<code class="sig-name descname"><span class="pre">update_psi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update_psi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_psi" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode wavefunction</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update_rho">
<code class="sig-name descname"><span class="pre">update_rho</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update_rho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode density matrix</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.distributions.HarmonicOscillatorWaveFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HarmonicOscillatorWaveFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[-</span> <span class="pre">5,</span> <span class="pre">5]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#HarmonicOscillatorWaveFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorWaveFunction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="qutip.distributions.HarmonicOscillatorWaveFunction.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#HarmonicOscillatorWaveFunction.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorWaveFunction.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the wavefunction for the given state of an harmonic
oscillator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.distributions.HarmonicOscillatorProbabilityFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">HarmonicOscillatorProbabilityFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[-</span> <span class="pre">5,</span> <span class="pre">5]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#HarmonicOscillatorProbabilityFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorProbabilityFunction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="qutip.distributions.HarmonicOscillatorProbabilityFunction.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#HarmonicOscillatorProbabilityFunction.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorProbabilityFunction.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the probability function for the given state of an harmonic
oscillator (as density matrix)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quantum-information-processing">
<span id="classes-qip"></span><h2>Quantum information processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.qip.Gate">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Gate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#Gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.Gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a quantum gate, with its required parameters, and target
and control qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Gate name.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list or int</span></dt><dd><p>Gate targets.</p>
</dd>
<dt><strong>controls</strong><span class="classifier">list or int</span></dt><dd><p>Gate controls.</p>
</dd>
<dt><strong>arg_value</strong><span class="classifier">float</span></dt><dd><p>Argument value(phi).</p>
</dd>
<dt><strong>arg_label</strong><span class="classifier">string</span></dt><dd><p>Label for gate representation.</p>
</dd>
<dt><strong>classical_controls</strong><span class="classifier">int or list of int, optional</span></dt><dd><p>indices of classical bits to control gate on.</p>
</dd>
<dt><strong>control_value</strong><span class="classifier">int, optional</span></dt><dd><p>value of classical bits to control on, the classical controls are
interpreted as an integer with lowest bit being the first one.
If not specified, then the value is interpreted to be
2 ** len(classical_controls) - 1 (i.e. all classical controls are 1).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.qip.circuit.Measurement">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Measurement</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_store</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#Measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.Measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a quantum measurement, with its required parameters,
and target qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Measurement name.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">list or int</span></dt><dd><p>Gate targets.</p>
</dd>
<dt><strong>classical_store</strong><span class="classifier">int</span></dt><dd><p>Result of the measurment is stored in this
classical register of the circuit.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.circuit.Measurement.measurement_comp_basis">
<code class="sig-name descname"><span class="pre">measurement_comp_basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#Measurement.measurement_comp_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.Measurement.measurement_comp_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Measures a particular qubit (determined by the target)
whose ket vector/ density matrix is specified in the
computational basis and returns collapsed_states and probabilities
(retains full dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket or oper</span></dt><dd><p>state to be measured on specified by
ket vector or density matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapsed_states</strong><span class="classifier">List of Qobjs</span></dt><dd><p>the collapsed state obtained after measuring the qubits
and obtaining the qubit specified by the target in the
state specified by the index.</p>
</dd>
<dt><strong>probabilities</strong><span class="classifier">List of floats</span></dt><dd><p>the probability of measuring a state in a the state
specified by the index.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.circuit.QubitCircuit">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">QubitCircuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_gates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a quantum program/algorithm, maintaining a sequence
of gates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int</span></dt><dd><p>Number of qubits in the system.</p>
</dd>
<dt><strong>user_gates</strong><span class="classifier">dict</span></dt><dd><p>Define a dictionary of the custom gates. See examples for detail.</p>
</dd>
<dt><strong>input_states</strong><span class="classifier">list</span></dt><dd><p>A list of string such as <cite>0</cite>,’+’, “A”, “Y”. Only used for latex.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>A list of integer for the dimension of each composite system.
e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system
will be the default option.</p>
</dd>
<dt><strong>num_cbits</strong><span class="classifier">int</span></dt><dd><p>Number of classical bits in the system.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">user_gate</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="n">j</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubit_circuit</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">user_gates</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;T&quot;</span><span class="p">:</span><span class="n">user_gate</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qubit_circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.add_1q_gate">
<code class="sig-name descname"><span class="pre">add_1q_gate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_controls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.add_1q_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_1q_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a single qubit gate with specified parameters on a variable
number of qubits in the circuit. By default, it applies the given gate
to all the qubits in the register.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Gate name.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Starting location of qubits.</p>
</dd>
<dt><strong>end</strong><span class="classifier">int</span></dt><dd><p>Last qubit for the gate.</p>
</dd>
<dt><strong>qubits</strong><span class="classifier">list</span></dt><dd><p>Specific qubits for applying gates.</p>
</dd>
<dt><strong>arg_value</strong><span class="classifier">float</span></dt><dd><p>Argument value(phi).</p>
</dd>
<dt><strong>arg_label</strong><span class="classifier">string</span></dt><dd><p>Label for gate representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.add_circuit">
<code class="sig-name descname"><span class="pre">add_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_user_gates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.add_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a block of a qubit circuit to the main circuit.
Globalphase gates are not added.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>qc</strong><span class="classifier"><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></span></dt><dd><p>The circuit block to be added to the main circuit.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>The qubit on which the first gate is applied.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.add_gate">
<code class="sig-name descname"><span class="pre">add_gate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_controls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.add_gate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a gate with specified parameters to the circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gate: string or :class:`.Gate`</strong></dt><dd><p>Gate name. If gate is an instance of <a class="reference internal" href="#qutip.qip.Gate" title="qutip.qip.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>, parameters are
unpacked and added.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>Gate targets.</p>
</dd>
<dt><strong>controls: list</strong></dt><dd><p>Gate controls.</p>
</dd>
<dt><strong>arg_value: float</strong></dt><dd><p>Argument value(phi).</p>
</dd>
<dt><strong>arg_label: string</strong></dt><dd><p>Label for gate representation.</p>
</dd>
<dt><strong>index</strong><span class="classifier">list</span></dt><dd><p>Positions to add the gate. Each index in the supplied list refers
to a position in the original list of gates.</p>
</dd>
<dt><strong>classical_controls</strong><span class="classifier">int or list of int, optional</span></dt><dd><p>indices of classical bits to control gate on.</p>
</dd>
<dt><strong>control_value</strong><span class="classifier">int, optional</span></dt><dd><p>value of classical bits to control on, the classical controls are
interpreted as an integer with lowest bit being the first one.
If not specified, then the value is interpreted to be
2 ** len(classical_controls) - 1
(i.e. all classical controls are 1).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.add_measurement">
<code class="sig-name descname"><span class="pre">add_measurement</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measurement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_store</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.add_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a measurement with specified parameters to the circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measurement: string</strong></dt><dd><p>Measurement name. If name is an instance of <cite>Measuremnent</cite>,
parameters are unpacked and added.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>Gate targets</p>
</dd>
<dt><strong>index</strong><span class="classifier">list</span></dt><dd><p>Positions to add the gate.</p>
</dd>
<dt><strong>classical_store</strong><span class="classifier">int</span></dt><dd><p>Classical register where result of measurement is stored.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.add_state">
<code class="sig-name descname"><span class="pre">add_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'input'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.add_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an input or ouput state to the circuit. By default all the input
and output states will be initialized to <cite>None</cite>. A particular state can
be added by specifying the state and the qubit where it has to be added
along with the type as input or output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state: str</strong></dt><dd><p>The state that has to be added. It can be any string such as <cite>0</cite>,
‘+’, “A”, “Y”</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>A list of qubit positions where the given state has to be added.</p>
</dd>
<dt><strong>state_type: str</strong></dt><dd><p>One of either “input” or “output”. This specifies whether the state
to be added is an input or output.
default: “input”</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.adjacent_gates">
<code class="sig-name descname"><span class="pre">adjacent_gates</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.adjacent_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve two qubit gates with non-adjacent control/s or
target/s in terms of gates with adjacent interactions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>qubit_circuit: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>Return <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> of the gates
for the qubit circuit with the resolved non-adjacent gates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.propagators">
<code class="sig-name descname"><span class="pre">propagators</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expand</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.propagators"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.propagators" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagator matrix calculator for N qubits returning the individual
steps as unitary matrices operating from left to right.
:returns: <strong>U_list</strong> – Return list of unitary matrices for the qubit circuit.
:rtype: list</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.propagators_no_expand">
<code class="sig-name descname"><span class="pre">propagators_no_expand</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.propagators_no_expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.propagators_no_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagator matrix calculator for N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>U_list</strong><span class="classifier">list</span></dt><dd><p>Return list of unitary matrices for the qubit circuit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.remove_gate_or_measurement">
<code class="sig-name descname"><span class="pre">remove_gate_or_measurement</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'first'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.remove_gate_or_measurement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.remove_gate_or_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a gate from a specific index or between two indexes or the
first, last or all instances of a particular gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>Location of gate or measurement to be removed.</p>
</dd>
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Gate or Measurement name to be removed.</p>
</dd>
<dt><strong>remove</strong><span class="classifier">string</span></dt><dd><p>If first or all gates/measurements are to be removed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.resolve_gates">
<code class="sig-name descname"><span class="pre">resolve_gates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['CNOT',</span> <span class="pre">'RX',</span> <span class="pre">'RY',</span> <span class="pre">'RZ']</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.resolve_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.resolve_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitary matrix calculator for N qubits returning the individual
steps as unitary matrices operating from left to right in the specified
basis.
Calls ‘_resolve_to_universal’ for each gate, this function maps
each ‘GATENAME’ with its corresponding ‘_gate_basis_2q’
Subsequently calls _resolve_2q_basis for each basis, this function maps
each ‘2QGATENAME’ with its corresponding ‘_basis_’</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">list.</span></dt><dd><p>Basis of the resolved circuit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>qc</strong><span class="classifier"><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></span></dt><dd><p>Return <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> of resolved gates
for the qubit circuit in the desired basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.reverse_circuit">
<code class="sig-name descname"><span class="pre">reverse_circuit</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.reverse_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.reverse_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse an entire circuit of unitary gates.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>qubit_circuit</strong><span class="classifier"><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></span></dt><dd><p>Return <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> of resolved gates for the
qubit circuit in the reverse order.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_unitary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the result of one instance of circuit run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket or oper</span></dt><dd><p>state vector or density matrix input.</p>
</dd>
<dt><strong>cbits</strong><span class="classifier">List of ints, optional</span></dt><dd><p>initialization of the classical bits.</p>
</dd>
<dt><strong>U_list: list of Qobj, optional</strong></dt><dd><p>list of predefined unitaries corresponding to circuit.</p>
</dd>
<dt><strong>measure_results</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>optional specification of each measurement result to enable
post-selection. If specified, the measurement results are
set to the tuple of bits (sequentially) instead of being
chosen at random.</p>
</dd>
<dt><strong>precompute_unitary: Boolean, optional</strong></dt><dd><p>Specify if computation is done by pre-computing and aggregating
gate unitaries. Possibly a faster method in the case of
large number of repeat runs with different state inputs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>final_state</strong><span class="classifier">Qobj</span></dt><dd><p>output state of the circuit run.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.QubitCircuit.run_statistics">
<code class="sig-name descname"><span class="pre">run_statistics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_unitary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#QubitCircuit.run_statistics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.run_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all the possible outputs of a circuit
(varied by measurement gates).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket or oper</span></dt><dd><p>state vector or density matrix input.</p>
</dd>
<dt><strong>cbits</strong><span class="classifier">List of ints, optional</span></dt><dd><p>initialization of the classical bits.</p>
</dd>
<dt><strong>U_list: list of Qobj, optional</strong></dt><dd><p>list of predefined unitaries corresponding to circuit.</p>
</dd>
<dt><strong>measure_results</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>optional specification of each measurement result to enable
post-selection. If specified, the measurement results are
set to the tuple of bits (sequentially) instead of being
chosen at random.</p>
</dd>
<dt><strong>precompute_unitary: Boolean, optional</strong></dt><dd><p>Specify if computation is done by pre-computing and aggregating
gate unitaries. Possibly a faster method in the case of
large number of repeat runs with different state inputs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: CircuitResult</dt><dd><p>Return a CircuitResult object containing
output states and and their probabilities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.circuit.CircuitResult">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">CircuitResult</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">final_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitResult" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="qutip.qip.circuit.CircuitResult.get_cbits">
<code class="sig-name descname"><span class="pre">get_cbits</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitResult.get_cbits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitResult.get_cbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of classical bit outputs corresponding to the results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index: int</strong></dt><dd><p>Indicates i-th output, probability pair to be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cbits: list of int or list of list of int</dt><dd><p>list of classical bit outputs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.CircuitResult.get_final_states">
<code class="sig-name descname"><span class="pre">get_final_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitResult.get_final_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitResult.get_final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of output states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index: int</strong></dt><dd><p>Indicates i-th state to be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>final_states: Qobj or list of Qobj.</dt><dd><p>List of output kets or density matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.CircuitResult.get_probabilities">
<code class="sig-name descname"><span class="pre">get_probabilities</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitResult.get_probabilities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitResult.get_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of probabilities corresponding to the output states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index: int</strong></dt><dd><p>Indicates i-th probability to be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>probabilities: float or list of float</dt><dd><p>Probabilities associated with each output state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.circuit.CircuitSimulator">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">CircuitSimulator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'state_vector_simulator'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute_unitary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitSimulator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitSimulator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="qutip.qip.circuit.CircuitSimulator.initialize">
<code class="sig-name descname"><span class="pre">initialize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitSimulator.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitSimulator.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset Simulator state variables to start a new run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state: ket or oper</strong></dt><dd><p>ket or density matrix</p>
</dd>
<dt><strong>cbits: list of int, optional</strong></dt><dd><p>initial value of classical bits</p>
</dd>
<dt><strong>U_list: list of Qobj, optional</strong></dt><dd><p>list of predefined unitaries corresponding to circuit.</p>
</dd>
<dt><strong>measure_results</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>optional specification of each measurement result to enable
post-selection. If specified, the measurement results are
set to the tuple of bits (sequentially) instead of being
chosen at random.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.CircuitSimulator.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitSimulator.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitSimulator.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the result of one instance of circuit run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket or oper</span></dt><dd><p>state vector or density matrix input.</p>
</dd>
<dt><strong>cbits</strong><span class="classifier">List of ints, optional</span></dt><dd><p>initialization of the classical bits.</p>
</dd>
<dt><strong>measure_results</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>optional specification of each measurement result to enable
post-selection. If specified, the measurement results are
set to the tuple of bits (sequentially) instead of being
chosen at random.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: CircuitResult</dt><dd><p>Return a CircuitResult object containing
output state and probability.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.CircuitSimulator.run_statistics">
<code class="sig-name descname"><span class="pre">run_statistics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cbits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitSimulator.run_statistics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitSimulator.run_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all the possible outputs of a circuit
(varied by measurement gates).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket</span></dt><dd><p>state to be observed on specified by density matrix.</p>
</dd>
<dt><strong>cbits</strong><span class="classifier">List of ints, optional</span></dt><dd><p>initialization of the classical bits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>result: CircuitResult</dt><dd><p>Return a CircuitResult object containing
output states and and their probabilities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.circuit.CircuitSimulator.step">
<code class="sig-name descname"><span class="pre">step</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/circuit.html#CircuitSimulator.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.circuit.CircuitSimulator.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return state after one step of circuit evolution
(gate or measurement).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">ket or oper</span></dt><dd><p>state after one evolution step.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.Processor">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Processor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'step_func'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor" title="Permalink to this definition">¶</a></dt>
<dd><p>A simulator of a quantum device based on the QuTiP solver
<a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>.  It is defined by the available driving Hamiltonian
and the decoherence time for each component systems.  The processor can
simulate the evolution under the given control pulses. Noisy evolution is
supported by <a class="reference internal" href="#qutip.qip.noise.Noise" title="qutip.qip.noise.Noise"><code class="xref py py-class docutils literal notranslate"><span class="pre">Noise</span></code></a> and can be added to the processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of component systems.</p>
</dd>
<dt><strong>t1: list or float, optional</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>t2: list of float, optional</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of each component system.
Default value is a
qubit system of <code class="docutils literal notranslate"><span class="pre">dim=[2,2,2,...,2]</span></code></p>
</dd>
<dt><strong>spline_kind: str, optional</strong></dt><dd><p>Type of the coefficient interpolation. Default is “step_func”
Note that they have different requirement for the length of <code class="docutils literal notranslate"><span class="pre">coeff</span></code>.</p>
<ul class="simple">
<li><p>“step_func”:
The coefficient will be treated as a step function.  E.g.
<code class="docutils literal notranslate"><span class="pre">tlist=[0,1,2]</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff=[3,2]</span></code>, means that the coefficient is
3 in t=[0,1) and 2 in t=[2,3). It requires
<code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)-1</span></code> or <code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)</span></code>, but in the
second case the last element of <cite>coeff</cite> has no effect.</p></li>
<li><p>“cubic”: Use cubic interpolation for the coefficient. It requires
<code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of component systems.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>A list of control pulses of this device</p>
</dd>
<dt><strong>t1: float or list</strong></dt><dd><p>Characterize the decoherence of amplitude damping of
each qubit.</p>
</dd>
<dt><strong>t2: float or list</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit.</p>
</dd>
<dt><strong>noise: :class:`.Noise`, optional</strong></dt><dd><p>A list of noise objects. They will be processed when creating the
noisy <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> from the processor or run the simulation.</p>
</dd>
<dt><strong>drift: :class:`qutip.qip.pulse.Drift`</strong></dt><dd><p>A <cite>Drift</cite> object representing the drift Hamiltonians.</p>
</dd>
<dt><strong>dims: list</strong></dt><dd><p>The dimension of each component system.
Default value is a
qubit system of <code class="docutils literal notranslate"><span class="pre">dim=[2,2,2,...,2]</span></code></p>
</dd>
<dt><strong>spline_kind: str</strong></dt><dd><p>Type of the coefficient interpolation.
See parameters of <a class="reference internal" href="#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Processor</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.Processor.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.add_control"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.add_drift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.add_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.add_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.Processor.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.Processor.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.eliminate_auxillary_modes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.get_full_coeffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.get_full_tlist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.get_noisy_pulses"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.get_operators_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.get_qobjevo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate an <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> to its
corresponding Hamiltonians. (Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.plot_pulses"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.read_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.remove_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.run_analytically"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mesolve'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.run_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.</p>
<p>If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.
Noise will be neglected in this option.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: bool</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>solver: str</strong></dt><dd><p>“mesolve” or “mcsolve”</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.save_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.Processor.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/processor.html#Processor.set_all_tlist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.Processor.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.OptPulseProcessor">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptPulseProcessor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/optpulseprocessor.html#OptPulseProcessor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>A processor, which takes the Hamiltonian available
as dynamic generators, calls the
<cite>qutip.control.optimize_pulse_unitary</cite> function
to find an optimized pulse sequence for the desired quantum circuit.
The processor can simulate the evolution under the given
control pulses using <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a>.
(For attributes documentation, please
refer to the parent class <a class="reference internal" href="#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Processor</span></code></a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of component systems.</p>
</dd>
<dt><strong>drift: `:class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian. The size must match the whole quantum system.</p>
</dd>
<dt><strong>t1: list or float</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>t2: list of float</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>dims: list</strong></dt><dd><p>The dimension of each component system.
Default value is a
qubit system of <code class="docutils literal notranslate"><span class="pre">dim=[2,2,2,...,2]</span></code></p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_fid_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_gates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setting_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/optpulseprocessor.html#OptPulseProcessor.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the pulses realizing a given
<a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> using
<cite>qutip.control.optimize_pulse_unitary</cite>. Further parameter for
for <cite>qutip.control.optimize_pulse_unitary</cite> needs to be given as
keyword arguments. By default, it first merge all the gates
into one unitary and then find the control pulses for it.
It can be turned off and one can set different parameters
for different gates. See examples for details.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>qc: :class:`.QubitCircuit` or list of Qobj</strong></dt><dd><p>The quantum circuit to be translated.</p>
</dd>
<dt><strong>min_fid_err: float, optional</strong></dt><dd><p>The minimal fidelity tolerance, if the fidelity error of any
gate decomposition is higher, a warning will be given.
Default is infinite.</p>
</dd>
<dt><strong>merge_gates: boolean, optimal</strong></dt><dd><p>If True, merge all gate/Qobj into one Qobj and then
find the optimal pulses for this unitary matrix. If False,
find the optimal pulses for each gate/Qobj.</p>
</dd>
<dt><strong>setting_args: dict, optional</strong></dt><dd><p>Only considered if merge_gates is False.
It is a dictionary containing keyword arguments
for different gates.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">setting_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;SNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
                <span class="s2">&quot;SWAP&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                <span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
</pre></div>
</div>
</dd>
<dt><strong>verbose: boolean, optional</strong></dt><dd><p>If true, the information for each decomposed gate
will be shown. Default is False.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>keyword arguments for <cite>qutip.control.optimize_pulse_unitary</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">len(tlist)</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">coeffs.shape[1]</span></code> since tlist gives the beginning
and the end of the pulses.</p>
<p class="rubric">Examples</p>
<p>Same parameter for all the gates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SNOT&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">num_tslots</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">evo_time</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">processor</span> <span class="o">=</span> <span class="n">OptPulseProcessor</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drift</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">(),</span>
                              <span class="n">ctrls</span><span class="o">=</span><span class="p">[</span><span class="n">sigmax</span><span class="p">()])</span>
<span class="c1"># num_tslots and evo_time are two keyword arguments</span>
<span class="n">tlist</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">load_circuit</span><span class="p">(</span>
    <span class="n">qc</span><span class="p">,</span> <span class="n">num_tslots</span><span class="o">=</span><span class="n">num_tslots</span><span class="p">,</span> <span class="n">evo_time</span><span class="o">=</span><span class="n">evo_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Different parameters for different gates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SNOT&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SWAP&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="n">controls</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">processor</span> <span class="o">=</span> <span class="n">OptPulseProcessor</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">drift</span><span class="o">=</span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmaz</span><span class="p">()]</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">cyclic_permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmay</span><span class="p">(),</span> <span class="n">cyclic_permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmay</span><span class="p">(),</span> <span class="n">sigmay</span><span class="p">()]))</span>
<span class="n">setting_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;SNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
                <span class="s2">&quot;SWAP&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
                <span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
<span class="n">tlist</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">load_circuit</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span>
                                       <span class="n">setting_args</span><span class="o">=</span><span class="n">setting_args</span><span class="p">,</span>
                                       <span class="n">merge_gates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mesolve'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.</p>
<p>If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.
Noise will be neglected in this option.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: bool</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>solver: str</strong></dt><dd><p>“mesolve” or “mcsolve”</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.OptPulseProcessor.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.OptPulseProcessor.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.ModelProcessor">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">ModelProcessor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for a circuit processor simulating a physical device,
e.g cavityQED, spinchain.
The available Hamiltonian of the system is predefined.
The processor can simulate the evolution under the given
control pulses either numerically or analytically.
It cannot be used alone, please refer to the sub-classes.
(Only additional attributes are documented here, for others please
refer to the parent class <a class="reference internal" href="#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Processor</span></code></a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of component systems.</p>
</dd>
<dt><strong>correct_global_phase: boolean, optional</strong></dt><dd><p>If true, the analytical solution will track the global phase. It
has no effect on the numerical solution.</p>
</dd>
<dt><strong>t1: list or float</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>t2: list of float</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params: dict</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters
in the physical realization, such as laser frequency, detuning etc.</p>
</dd>
<dt><strong>correct_global_phase: float</strong></dt><dd><p>Save the global phase, the analytical solution
will track the global phase.
It has no effect on the numerical solution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.ModelProcessor.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.ModelProcessor.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_ops_and_u">
<code class="sig-name descname"><span class="pre">get_ops_and_u</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor.get_ops_and_u"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>ctrls: list</dt><dd><p>The list of Hamiltonians</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The transposed pulse matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate an <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> to its
corresponding Hamiltonians. (Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.pulse_matrix">
<code class="sig-name descname"><span class="pre">pulse_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor.pulse_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>t, u, labels:</dt><dd><p>Returns the total time and label for every operation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor.run_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.
If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: boolean</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>A quantum circuit. If given, it first calls the <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>
and then calculate the evolution.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.ModelProcessor.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.set_up_params">
<code class="sig-name descname"><span class="pre">set_up_params</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor.set_up_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor.set_up_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the parameters in the attribute <cite>params</cite> and check the validity.
(Defined in subclasses)</p>
<p class="rubric">Notes</p>
<p>All parameters will be multiplied by 2*pi for simplicity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.ModelProcessor.to_array">
<code class="sig-name descname"><span class="pre">to_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/modelprocessor.html#ModelProcessor.to_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.ModelProcessor.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a parameter to an array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.SpinChain">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">SpinChain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_global_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxsy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>The processor based on the physical implementation of
a spin chain qubits system.
The available Hamiltonian of the system is predefined.
The processor can simulate the evolution under the given
control pulses either numerically or analytically.
It is a base class and should not be used directly, please
refer the the subclasses <a class="reference internal" href="#qutip.qip.device.LinearSpinChain" title="qutip.qip.device.LinearSpinChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.LinearSpinChain</span></code></a> and
<a class="reference internal" href="#qutip.qip.device.CircularSpinChain" title="qutip.qip.device.CircularSpinChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.CircularSpinChain</span></code></a>.
(Only additional attributes are documented here, for others please
refer to the parent class <a class="reference internal" href="#qutip.qip.device.ModelProcessor" title="qutip.qip.device.ModelProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelProcessor</span></code></a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>correct_global_phase: float</strong></dt><dd><p>Save the global phase, the analytical solution
will track the global phase.
It has no effect on the numerical solution.</p>
</dd>
<dt><strong>sx: int or list</strong></dt><dd><p>The delta for each of the qubits in the system.</p>
</dd>
<dt><strong>sz: int or list</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>sxsy: int or list</strong></dt><dd><p>The interaction strength for each of the qubit pair in the system.</p>
</dd>
<dt><strong>t1: list or float</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>t2: list of float</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sx: list</strong></dt><dd><p>The delta for each of the qubits in the system.</p>
</dd>
<dt><strong>sz: list</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>sxsy: list</strong></dt><dd><p>The interaction strength for each of the qubit pair in the system.</p>
</dd>
<dt><strong>sx_ops: list</strong></dt><dd><p>A list of sigmax Hamiltonians for each qubit.</p>
</dd>
<dt><strong>sz_ops: list</strong></dt><dd><p>A list of sigmaz Hamiltonians for each qubit.</p>
</dd>
<dt><strong>sxsy_ops: list</strong></dt><dd><p>A list of tensor(sigmax, sigmay)
interacting Hamiltonians for each qubit.</p>
</dd>
<dt><strong>sx_u: array_like</strong></dt><dd><p>Pulse matrix for sigmax Hamiltonians.</p>
</dd>
<dt><strong>sz_u: array_like</strong></dt><dd><p>Pulse matrix for sigmaz Hamiltonians.</p>
</dd>
<dt><strong>sxsy_u: array_like</strong></dt><dd><p>Pulse matrix for tensor(sigmax, sigmay) interacting Hamiltonians.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.SpinChain.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.adjacent_gates">
<code class="sig-name descname"><span class="pre">adjacent_gates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.adjacent_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve 2 qubit gates with non-adjacent control/s or target/s
in terms of gates with adjacent interactions for linear/circular spin
chain system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>The circular spin chain circuit to be resolved</p>
</dd>
<dt><strong>setup: Boolean</strong></dt><dd><p>Linear of Circular spin chain setup</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.SpinChain.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.SpinChain.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.eliminate_auxillary_modes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_ops_and_u">
<code class="sig-name descname"><span class="pre">get_ops_and_u</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>ctrls: list</dt><dd><p>The list of Hamiltonians</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The transposed pulse matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compiler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> in to the control
amplitude generating the corresponding evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
<dt><strong>setup: string</strong></dt><dd><p>“linear” or “circular” for two sub-classes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape (len(ctrls), len(tlist)). Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.optimize_circuit">
<code class="sig-name descname"><span class="pre">optimize_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.optimize_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>The circuit representation with elementary gates
that can be implemented in this model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.pulse_matrix">
<code class="sig-name descname"><span class="pre">pulse_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>t, u, labels:</dt><dd><p>Returns the total time and label for every operation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.
If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: boolean</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>A quantum circuit. If given, it first calls the <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>
and then calculate the evolution.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.set_up_ops">
<code class="sig-name descname"><span class="pre">set_up_ops</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.set_up_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.set_up_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Hamiltonians for the spinchain model and save them in the
attribute <cite>ctrls</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.set_up_params">
<code class="sig-name descname"><span class="pre">set_up_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#SpinChain.set_up_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.SpinChain.set_up_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the parameters in the attribute <cite>params</cite> and check the validity.
The keys of <cite>params</cite> including “sx”, “sz”, and “sxsy”, each
mapped to a list for parameters corresponding to each qubits.
For coupling strength “sxsy”, list element i is the interaction
between qubits i and i+1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sx: float or list</strong></dt><dd><p>The coefficient of sigmax in the model</p>
</dd>
<dt><strong>sz: flaot or list</strong></dt><dd><p>The coefficient of sigmaz in the model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The coefficient of sxsy is defined in the submethods.
All parameters will be multiplied by 2*pi for simplicity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.SpinChain.to_array">
<code class="sig-name descname"><span class="pre">to_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.SpinChain.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a parameter to an array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.LinearSpinChain">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">LinearSpinChain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxsy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>A processor based on the physical implementation of
a linear spin chain qubits system.
The available Hamiltonian of the system is predefined.
The processor can simulate the evolution under the given
control pulses either numerically or analytically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>correct_global_phase: float</strong></dt><dd><p>Save the global phase, the analytical solution
will track the global phase.
It has no effect on the numerical solution.</p>
</dd>
<dt><strong>sx: int or list</strong></dt><dd><p>The delta for each of the qubits in the system.</p>
</dd>
<dt><strong>sz: int or list</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>sxsy: int or list</strong></dt><dd><p>The interaction strength for each of the qubit pair in the system.</p>
</dd>
<dt><strong>t1: list or float, optional</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit.</p>
</dd>
<dt><strong>t2: list of float, optional</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.adjacent_gates">
<code class="sig-name descname"><span class="pre">adjacent_gates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain.adjacent_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve 2 qubit gates with non-adjacent control/s or target/s
in terms of gates with adjacent interactions for linear/circular spin
chain system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>The circular spin chain circuit to be resolved</p>
</dd>
<dt><strong>setup: Boolean</strong></dt><dd><p>Linear of Circular spin chain setup</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain.get_operators_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_ops_and_u">
<code class="sig-name descname"><span class="pre">get_ops_and_u</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>ctrls: list</dt><dd><p>The list of Hamiltonians</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The transposed pulse matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compiler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> in to the control
amplitude generating the corresponding evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
<dt><strong>setup: string</strong></dt><dd><p>“linear” or “circular” for two sub-classes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape (len(ctrls), len(tlist)). Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.optimize_circuit">
<code class="sig-name descname"><span class="pre">optimize_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>The circuit representation with elementary gates
that can be implemented in this model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.pulse_matrix">
<code class="sig-name descname"><span class="pre">pulse_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>t, u, labels:</dt><dd><p>Returns the total time and label for every operation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.
If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: boolean</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>A quantum circuit. If given, it first calls the <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>
and then calculate the evolution.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.set_up_ops">
<code class="sig-name descname"><span class="pre">set_up_ops</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain.set_up_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.set_up_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Hamiltonians for the spinchain model and save them in the
attribute <cite>ctrls</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.set_up_params">
<code class="sig-name descname"><span class="pre">set_up_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxsy</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#LinearSpinChain.set_up_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.set_up_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the parameters in the attribute <cite>params</cite> and check the validity.
The keys of <cite>params</cite> including “sx”, “sz”, and “sxsy”, each
mapped to a list for parameters corresponding to each qubits.
For coupling strength “sxsy”, list element i is the interaction
between qubits i and i+1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sx: float or list</strong></dt><dd><p>The coefficient of sigmax in the model</p>
</dd>
<dt><strong>sz: flaot or list</strong></dt><dd><p>The coefficient of sigmaz in the model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The coefficient of sxsy is defined in the submethods.
All parameters will be multiplied by 2*pi for simplicity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.LinearSpinChain.to_array">
<code class="sig-name descname"><span class="pre">to_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.LinearSpinChain.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a parameter to an array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.CircularSpinChain">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">CircularSpinChain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxsy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>A processor based on the physical implementation of
a circular spin chain qubits system.
The available Hamiltonian of the system is predefined.
The processor can simulate the evolution under the given
control pulses either numerically or analytically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>correct_global_phase: float</strong></dt><dd><p>Save the global phase, the analytical solution
will track the global phase.
It has no effect on the numerical solution.</p>
</dd>
<dt><strong>sx: int or list</strong></dt><dd><p>The delta for each of the qubits in the system.</p>
</dd>
<dt><strong>sz: int or list</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>sxsy: int or list</strong></dt><dd><p>The interaction strength for each of the qubit pair in the system.</p>
</dd>
<dt><strong>t1: list or float, optional</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit.</p>
</dd>
<dt><strong>t2: list of float, optional</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.adjacent_gates">
<code class="sig-name descname"><span class="pre">adjacent_gates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain.adjacent_gates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve 2 qubit gates with non-adjacent control/s or target/s
in terms of gates with adjacent interactions for linear/circular spin
chain system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>The circular spin chain circuit to be resolved</p>
</dd>
<dt><strong>setup: Boolean</strong></dt><dd><p>Linear of Circular spin chain setup</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.
(Defined in subclasses)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain.get_operators_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_ops_and_u">
<code class="sig-name descname"><span class="pre">get_ops_and_u</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>ctrls: list</dt><dd><p>The list of Hamiltonians</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The transposed pulse matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compiler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> in to the control
amplitude generating the corresponding evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
<dt><strong>setup: string</strong></dt><dd><p>“linear” or “circular” for two sub-classes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape (len(ctrls), len(tlist)). Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.optimize_circuit">
<code class="sig-name descname"><span class="pre">optimize_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>The circuit representation with elementary gates
that can be implemented in this model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.pulse_matrix">
<code class="sig-name descname"><span class="pre">pulse_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>t, u, labels:</dt><dd><p>Returns the total time and label for every operation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.
If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: boolean</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>A quantum circuit. If given, it first calls the <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>
and then calculate the evolution.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.set_up_ops">
<code class="sig-name descname"><span class="pre">set_up_ops</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain.set_up_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.set_up_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Hamiltonians for the spinchain model and save them in the
attribute <cite>ctrls</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.set_up_params">
<code class="sig-name descname"><span class="pre">set_up_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxsy</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/spinchain.html#CircularSpinChain.set_up_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.set_up_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the parameters in the attribute <cite>params</cite> and check the validity.
The keys of <cite>params</cite> including “sx”, “sz”, and “sxsy”, each
mapped to a list for parameters corresponding to each qubits.
For coupling strength “sxsy”, list element i is the interaction
between qubits i and i+1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sx: float or list</strong></dt><dd><p>The coefficient of sigmax in the model</p>
</dd>
<dt><strong>sz: flaot or list</strong></dt><dd><p>The coefficient of sigmaz in the model</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The coefficient of sxsy is defined in the submethods.
All parameters will be multiplied by 2*pi for simplicity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.CircularSpinChain.to_array">
<code class="sig-name descname"><span class="pre">to_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.CircularSpinChain.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a parameter to an array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.device.DispersiveCavityQED">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DispersiveCavityQED</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correct_global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltamax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED" title="Permalink to this definition">¶</a></dt>
<dd><p>The processor based on the physical implementation of
a dispersive cavity QED system.
The available Hamiltonian of the system is predefined.
For a given pulse amplitude matrix, the processor can
calculate the state evolution under the given control pulse,
either analytically or numerically.
(Only additional attributes are documented here, for others please
refer to the parent class <a class="reference internal" href="#qutip.qip.device.ModelProcessor" title="qutip.qip.device.ModelProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelProcessor</span></code></a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>correct_global_phase: float, optional</strong></dt><dd><p>Save the global phase, the analytical solution
will track the global phase.
It has no effect on the numerical solution.</p>
</dd>
<dt><strong>num_levels: int, optional</strong></dt><dd><p>The number of energy levels in the resonator.</p>
</dd>
<dt><strong>deltamax: int or list, optional</strong></dt><dd><p>The coefficients of sigma-x for each of the qubits in the system.</p>
</dd>
<dt><strong>epsmax: int or list, optional</strong></dt><dd><p>The coefficients of sigma-z for each of the qubits in the system.</p>
</dd>
<dt><strong>w0: int, optional</strong></dt><dd><p>The base frequency of the resonator.</p>
</dd>
<dt><strong>eps: int or list, optional</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>delta: int or list, optional</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>g: int or list, optional</strong></dt><dd><p>The interaction strength for each of the qubit with the resonator.</p>
</dd>
<dt><strong>t1: list or float</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
<dt><strong>t2: list of float</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit. A list of size <cite>N</cite> or a float for all qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sx_ops: list</strong></dt><dd><p>A list of sigmax Hamiltonians for each qubit.</p>
</dd>
<dt><strong>sz_ops: list</strong></dt><dd><p>A list of sigmaz Hamiltonians for each qubit.</p>
</dd>
<dt><strong>cavityqubit_ops: list</strong></dt><dd><p>A list of interacting Hamiltonians between cavity and each qubit.</p>
</dd>
<dt><strong>sx_u: array_like</strong></dt><dd><p>Pulse matrix for sigmax Hamiltonians.</p>
</dd>
<dt><strong>sz_u: array_like</strong></dt><dd><p>Pulse matrix for sigmaz Hamiltonians.</p>
</dd>
<dt><strong>g_u: array_like</strong></dt><dd><p>Pulse matrix for interacting Hamiltonians
between cavity and each qubit.</p>
</dd>
<dt><strong>wq: list of float</strong></dt><dd><p>The frequency of the qubits calculated from
eps and delta for each qubit.</p>
</dd>
<dt><strong>Delta: list of float</strong></dt><dd><p>The detuning with respect to w0 calculated
from wq and w0 for each qubit.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.add_control">
<code class="sig-name descname"><span class="pre">add_control</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a control Hamiltonian to the processor. It creates a new
<a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>
object for the device that is turned off
(<code class="docutils literal notranslate"><span class="pre">tlist</span> <span class="pre">=</span> <span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">coeff</span> <span class="pre">=</span> <span class="pre">None</span></code>). To activate the pulse, one
can set its <cite>tlist</cite> and <cite>coeff</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The Hamiltonian for the control pulse..</p>
</dd>
<dt><strong>targets: list, optional</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>cyclic_permutation: bool, optional</strong></dt><dd><p>If true, the Hamiltonian will be expanded for
all cyclic permutation of the target qubits.</p>
</dd>
<dt><strong>label: str, optional</strong></dt><dd><p>The label (name) of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.add_drift">
<code class="sig-name descname"><span class="pre">add_drift</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cyclic_permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.add_drift" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a drift Hamiltonians. The drift Hamiltonians are intrinsic
of the quantum system and cannot be controlled by external field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:`qutip.Qobj`</strong></dt><dd><p>The drift Hamiltonian.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>The indices of the target qubits
(or subquantum system of other dimensions).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.add_noise">
<code class="sig-name descname"><span class="pre">add_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a noise object to the processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise: :class:`.Noise`</strong></dt><dd><p>The noise object defined outside the processor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.add_pulse">
<code class="sig-name descname"><span class="pre">add_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pulse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.add_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new pulse to the device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pulse: :class:`.Pulse`</strong></dt><dd><p><cite>Pulse</cite> object to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.coeffs">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeffs</span></code><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the coefficients for all control pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ctrls</span></code><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of Hamiltonians of all pulses.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.eliminate_auxillary_modes">
<code class="sig-name descname"><span class="pre">eliminate_auxillary_modes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.eliminate_auxillary_modes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.eliminate_auxillary_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the auxillary modes like the cavity modes in cqed.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_full_coeffs">
<code class="sig-name descname"><span class="pre">get_full_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_full_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full coefficients in a 2d matrix form.
Each row corresponds to one pulse. If the <cite>tlist</cite> are
different for different pulses, the length of each row
will be same as the <cite>full_tlist</cite> (see method
<cite>get_full_tlist</cite>). Interpolation is used for
adding the missing coefficient according to <cite>spline_kind</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>coeffs: array-like 2d</dt><dd><p>The coefficients for all ideal pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the ideal pulses.
If different pulses have different time steps,
it will collect all the time steps in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_noisy_pulses">
<code class="sig-name descname"><span class="pre">get_noisy_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_noisy_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>It takes the pulses defined in the <cite>Processor</cite> and
adds noise according to <cite>Processor.noise</cite>. It does not modify the
pulses saved in <cite>Processor.pulses</cite> but returns a new list.
The length of the new list of noisy pulses might be longer
because of drift Hamiltonian and device noise. They will be
added to the end of the pulses list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>device_noise: bool, optional</strong></dt><dd><p>If true, include pulse independent noise such as single qubit
Relaxation. Default is False.</p>
</dd>
<dt><strong>drift: bool, optional</strong></dt><dd><p>If true, include drift Hamiltonians. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>A list of noisy pulses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_operators_labels">
<code class="sig-name descname"><span class="pre">get_operators_labels</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.get_operators_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_operators_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.
It is used in the method``plot_pulses``.
It is a 2-d nested list, in the plot,
a different color will be used for each sublist.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_ops_and_u">
<code class="sig-name descname"><span class="pre">get_ops_and_u</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels for each Hamiltonian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>ctrls: list</dt><dd><p>The list of Hamiltonians</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The transposed pulse matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.get_qobjevo">
<code class="sig-name descname"><span class="pre">get_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.get_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the evolution.
It calls the method <cite>get_noisy_pulses</cite> and create the <cite>QobjEvo</cite>
from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, optional</strong></dt><dd><p>Arguments for <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></p>
</dd>
<dt><strong>noisy: bool, optional</strong></dt><dd><p>If noise are included. Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobjevo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>The <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> representation of the unitary evolution.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of lindblad operators is also returned. if <code class="docutils literal notranslate"><span class="pre">noisy==Flase</span></code>,
it is always an empty list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.load_circuit">
<code class="sig-name descname"><span class="pre">load_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compiler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.load_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> in to the control
amplitude generating the corresponding evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape (len(ctrls), len(tlist)). Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.optimize_circuit">
<code class="sig-name descname"><span class="pre">optimize_circuit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.optimize_circuit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`</strong></dt><dd><p>Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qc: <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a></dt><dd><p>The circuit representation with elementary gates
that can be implemented in this model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.plot_pulses">
<code class="sig-name descname"><span class="pre">plot_pulses</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_pulse_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the ideal pulse coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>title: str, optional</strong></dt><dd><p>Title for the plot.</p>
</dd>
<dt><strong>figsize: tuple, optional</strong></dt><dd><p>The size of the figure.</p>
</dd>
<dt><strong>dpi: int, optional</strong></dt><dd><p>The dpi of the figure.</p>
</dd>
<dt><strong>show_axis: bool, optional</strong></dt><dd><p>If the axis are shown.</p>
</dd>
<dt><strong>rescale_pulse_coeffs: bool, optional</strong></dt><dd><p>Rescale the hight of each pulses.</p>
</dd>
<dt><strong>num_steps: int, optional</strong></dt><dd><p>Number of time steps in the plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>fig: matplotlib.figure.Figure</dt><dd><p>The <cite>Figure</cite> object for the plot.</p>
</dd>
<dt>ax: matplotlib.axes._subplots.AxesSubplot</dt><dd><p>The axes for the plot.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">plot_pulses</span></code> only works for array_like coefficients</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.pulse_matrix">
<code class="sig-name descname"><span class="pre">pulse_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>t, u, labels:</dt><dd><p>Returns the total time and label for every operation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.read_coeff">
<code class="sig-name descname"><span class="pre">read_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.read_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the control amplitudes matrix and time list
saved in the file by <cite>save_amp</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list in included in the first column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>The time list read from the file.</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>The pulse matrix read from the file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.remove_pulse">
<code class="sig-name descname"><span class="pre">remove_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.remove_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the control pulse with given indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: int or list of int</strong></dt><dd><p>The indices of the control Hamiltonians to be removed.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label of the pulse</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator of the evolution by matrix exponentiation.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <cite>load_circuit</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.run_analytically">
<code class="sig-name descname"><span class="pre">run_analytically</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.run_analytically" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the state evolution under the given <cite>qutip.QubitCircuit</cite>
with matrice exponentiation. It will calculate the propagator
with matrix exponentiation and return a list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>.
This method won’t include noise or collpase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>Takes the quantum circuit to be implemented. If not given, use
the quantum circuit saved in the processor by <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>.</p>
</dd>
<dt><strong>init_state: :class:`qutip.Qobj`, optional</strong></dt><dd><p>The initial state of the qubits in the register.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>U_list: list</dt><dd><p>A list of propagators obtained for the physical implementation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.run_state">
<code class="sig-name descname"><span class="pre">run_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analytical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>analytical</cite> is False, use <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve</span></code></a> to
calculate the time of the state evolution
and return the result. Other arguments of mesolve can be
given as keyword arguments.
If <cite>analytical</cite> is True, calculate the propagator
with matrix exponentiation and return a list of matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>init_state: Qobj</strong></dt><dd><p>Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>analytical: boolean</strong></dt><dd><p>If True, calculate the evolution with matrices exponentiation.</p>
</dd>
<dt><strong>qc: :class:`.QubitCircuit`, optional</strong></dt><dd><p>A quantum circuit. If given, it first calls the <code class="docutils literal notranslate"><span class="pre">load_circuit</span></code>
and then calculate the evolution.</p>
</dd>
<dt><strong>states: :class:`qutip.Qobj`, optional</strong></dt><dd><p>Old API, same as init_state.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments for the qutip solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>evo_result: <a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is False,  an instance of the class
<a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a> will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">analytical</span></code> is True, a list of matrices representation
is returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.save_coeff">
<code class="sig-name descname"><span class="pre">save_coeff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inctime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.save_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the control amplitudes in each timeslot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: string</strong></dt><dd><p>Name of the file.</p>
</dd>
<dt><strong>inctime: bool, optional</strong></dt><dd><p>True if the time list should be included in the first column.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.set_all_tlist">
<code class="sig-name descname"><span class="pre">set_all_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.set_all_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the same <cite>tlist</cite> for all the pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.set_up_ops">
<code class="sig-name descname"><span class="pre">set_up_ops</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.set_up_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.set_up_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Hamiltonians for the spinchain model and save them in the
attribute <cite>ctrls</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.set_up_params">
<code class="sig-name descname"><span class="pre">set_up_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltamax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/device/cavityqed.html#DispersiveCavityQED.set_up_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.set_up_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the parameters in the attribute <cite>params</cite> and check the validity.
The keys of <cite>params</cite> including “sx”, “sz”, “w0”, “eps”, “delta”
and “g”, each
mapped to a list for parameters corresponding to each qubits.
For coupling strength “g”, list element i is the interaction
between qubits i and i+1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>num_levels: int</strong></dt><dd><p>The number of energy levels in the resonator.</p>
</dd>
<dt><strong>deltamax: list</strong></dt><dd><p>The coefficients of sigma-x for each of the qubits in the system.</p>
</dd>
<dt><strong>epsmax: list</strong></dt><dd><p>The coefficients of sigma-z for each of the qubits in the system.</p>
</dd>
<dt><strong>wo: int</strong></dt><dd><p>The base frequency of the resonator.</p>
</dd>
<dt><strong>wq: list</strong></dt><dd><p>The frequency of the qubits.</p>
</dd>
<dt><strong>eps: list</strong></dt><dd><p>The epsilon for each of the qubits in the system.</p>
</dd>
<dt><strong>delta: list</strong></dt><dd><p>The delta for each of the qubits in the system.</p>
</dd>
<dt><strong>g: list</strong></dt><dd><p>The interaction strength for each of the qubit with the resonator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>All parameters will be multiplied by 2*pi for simplicity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.device.DispersiveCavityQED.to_array">
<code class="sig-name descname"><span class="pre">to_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.device.DispersiveCavityQED.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a parameter to an array.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.noise.Noise">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Noise</span></code><a class="reference internal" href="../modules/qutip/qip/noise.html#Noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.Noise" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class representing noise in a processor.
The noise object can be added to <a class="reference internal" href="#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Processor</span></code></a> and
contributes to evolution.</p>
<dl class="py method">
<dt id="qutip.qip.noise.Noise.get_noisy_dynamics">
<code class="sig-name descname"><span class="pre">get_noisy_dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">systematic_noise</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#Noise.get_noisy_dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.Noise.get_noisy_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pulses list added with noise and
the pulse independent noise in a dummy Pulse object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of the components system, the default value is
[2,2…,2] for qubits system.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>The input pulses, on which the noise object is to be applied.</p>
</dd>
<dt><strong>systematic_noise: :class:`.Pulse`</strong></dt><dd><p>The dummy pulse with no ideal control element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>Noisy pulses.</p>
</dd>
<dt>systematic_noise: <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>The dummy pulse representing pulse independent noise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.noise.DecoherenceNoise">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DecoherenceNoise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#DecoherenceNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.DecoherenceNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>The decoherence noise in a processor. It generates lindblad noise
according to the given collapse operator <cite>c_ops</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c_ops: :class:`qutip.Qobj` or list</strong></dt><dd><p>The Hamiltonian representing the dynamics of the noise.</p>
</dd>
<dt><strong>targets: int or list, optional</strong></dt><dd><p>The indices of qubits that are acted on. Default is on all
qubits</p>
</dd>
<dt><strong>coeff: list, optional</strong></dt><dd><p>A list of the coefficients for the control Hamiltonians.</p>
</dd>
<dt><strong>tlist: array_like, optional</strong></dt><dd><p>A NumPy array specifies the time of each coefficient.</p>
</dd>
<dt><strong>all_qubits: bool, optional</strong></dt><dd><p>If <cite>c_ops</cite> contains only single qubits collapse operator,
<code class="docutils literal notranslate"><span class="pre">all_qubits=True</span></code> will allow it to be applied to all qubits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c_ops: :class:`qutip.Qobj` or list</strong></dt><dd><p>The Hamiltonian representing the dynamics of the noise.</p>
</dd>
<dt><strong>targets: int or list</strong></dt><dd><p>The indices of qubits that are acted on.</p>
</dd>
<dt><strong>coeff: list</strong></dt><dd><p>A list of the coefficients for the control Hamiltonians.</p>
</dd>
<dt><strong>tlist: array_like</strong></dt><dd><p>A NumPy array specifies the time of each coefficient.</p>
</dd>
<dt><strong>all_qubits: bool</strong></dt><dd><p>If <cite>c_ops</cite> contains only single qubits collapse operator,
<code class="docutils literal notranslate"><span class="pre">all_qubits=True</span></code> will allow it to be applied to all qubits.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.noise.DecoherenceNoise.get_noisy_dynamics">
<code class="sig-name descname"><span class="pre">get_noisy_dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">systematic_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#DecoherenceNoise.get_noisy_dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.DecoherenceNoise.get_noisy_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pulses list added with noise and
the pulse independent noise in a dummy Pulse object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of the components system, the default value is
[2,2…,2] for qubits system.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>The input pulses, on which the noise object is to be applied.</p>
</dd>
<dt><strong>systematic_noise: :class:`.Pulse`</strong></dt><dd><p>The dummy pulse with no ideal control element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>Noisy pulses.</p>
</dd>
<dt>systematic_noise: <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>The dummy pulse representing pulse independent noise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.noise.RelaxationNoise">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">RelaxationNoise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#RelaxationNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.RelaxationNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>The decoherence on each qubit characterized by two time scales t1 and t2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t1: float or list, optional</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit.</p>
</dd>
<dt><strong>t2: float or list, optional</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit.</p>
</dd>
<dt><strong>targets: int or list, optional</strong></dt><dd><p>The indices of qubits that are acted on. Default is on all
qubits</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t1: float or list</strong></dt><dd><p>Characterize the decoherence of amplitude damping for
each qubit.</p>
</dd>
<dt><strong>t2: float or list</strong></dt><dd><p>Characterize the decoherence of dephasing for
each qubit.</p>
</dd>
<dt><strong>targets: int or list</strong></dt><dd><p>The indices of qubits that are acted on.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.noise.RelaxationNoise.get_noisy_dynamics">
<code class="sig-name descname"><span class="pre">get_noisy_dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">systematic_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#RelaxationNoise.get_noisy_dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.RelaxationNoise.get_noisy_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pulses list added with noise and
the pulse independent noise in a dummy Pulse object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of the components system, the default value is
[2,2…,2] for qubits system.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>The input pulses, on which the noise object is to be applied.</p>
</dd>
<dt><strong>systematic_noise: :class:`.Pulse`</strong></dt><dd><p>The dummy pulse with no ideal control element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>Noisy pulses.</p>
</dd>
<dt>systematic_noise: <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>The dummy pulse representing pulse independent noise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.noise.ControlAmpNoise">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">ControlAmpNoise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#ControlAmpNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.ControlAmpNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>The noise in the amplitude of the control pulse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coeff: list</strong></dt><dd><p>A list of the coefficients for the control Hamiltonians.
For available choices, see <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a>.</p>
</dd>
<dt><strong>tlist: array_like, optional</strong></dt><dd><p>A NumPy array specifies the time of each coefficient.</p>
</dd>
<dt><strong>indices: list of int, optional</strong></dt><dd><p>The indices of target pulse in the list of pulses.</p>
</dd>
<dt><strong>Attributes</strong></dt><dd></dd>
<dt><strong>———-</strong></dt><dd></dd>
<dt><strong>coeff: list</strong></dt><dd><p>A list of the coefficients for the control Hamiltonians.
For available choices, see <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a>.</p>
</dd>
<dt><strong>tlist: array_like</strong></dt><dd><p>A NumPy array specifies the time of each coefficient.</p>
</dd>
<dt><strong>indices: list of int</strong></dt><dd><p>The indices of target pulse in the list of pulses.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.noise.ControlAmpNoise.get_noisy_dynamics">
<code class="sig-name descname"><span class="pre">get_noisy_dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">systematic_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#ControlAmpNoise.get_noisy_dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.ControlAmpNoise.get_noisy_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pulses list added with noise and
the pulse independent noise in a dummy Pulse object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of the components system, the default value is
[2,2…,2] for qubits system.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>The input pulses, on which the noise object is to be applied.</p>
</dd>
<dt><strong>systematic_noise: :class:`.Pulse`</strong></dt><dd><p>The dummy pulse with no ideal control element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>Noisy pulses.</p>
</dd>
<dt>systematic_noise: <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>The dummy pulse representing pulse independent noise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.noise.RandomNoise">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">RandomNoise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rand_gen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#RandomNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.RandomNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Random noise in the amplitude of the control pulse. The arguments for
the random generator need to be given as key word arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float, optional</strong></dt><dd><p>The time interval between two random amplitude. The coefficients
of the noise are the same within this time range.</p>
</dd>
<dt><strong>rand_gen: numpy.random, optional</strong></dt><dd><p>A random generator in numpy.random, it has to take a <code class="docutils literal notranslate"><span class="pre">size</span></code>
parameter as the size of random numbers in the output array.</p>
</dd>
<dt><strong>indices: list of int, optional</strong></dt><dd><p>The indices of target pulse in the list of pulses.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Key word arguments for the random number generator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gaussnoise</span> <span class="o">=</span> <span class="n">RandomNoise</span><span class="p">(</span>             <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rand_gen</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>             
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt: float, optional</strong></dt><dd><p>The time interval between two random amplitude. The coefficients
of the noise are the same within this time range.</p>
</dd>
<dt><strong>rand_gen: numpy.random, optional</strong></dt><dd><p>A random generator in numpy.random, it has to take a <code class="docutils literal notranslate"><span class="pre">size</span></code>
parameter.</p>
</dd>
<dt><strong>indices: list of int</strong></dt><dd><p>The indices of target pulse in the list of pulses.</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>Key word arguments for the random number generator.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.noise.RandomNoise.get_noisy_dynamics">
<code class="sig-name descname"><span class="pre">get_noisy_dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">systematic_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/noise.html#RandomNoise.get_noisy_dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.noise.RandomNoise.get_noisy_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pulses list added with noise and
the pulse independent noise in a dummy Pulse object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: list, optional</strong></dt><dd><p>The dimension of the components system, the default value is
[2,2…,2] for qubits system.</p>
</dd>
<dt><strong>pulses: list of :class:`.Pulse`</strong></dt><dd><p>The input pulses, on which the noise object is to be applied.</p>
</dd>
<dt><strong>systematic_noise: :class:`.Pulse`</strong></dt><dd><p>The dummy pulse with no ideal control element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_pulses: list of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>Noisy pulses.</p>
</dd>
<dt>systematic_noise: <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a></dt><dd><p>The dummy pulse representing pulse independent noise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.pulse.Pulse">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a control pulse and the pulse dependent noise.
The pulse is characterized by the ideal control pulse, the coherent
noise and the lindblad noise. The later two are lists of
noisy evolution dynamics.
Each dynamic element is characterized by four variables:
<cite>qobj</cite>, <cite>targets</cite>, <cite>tlist</cite> and <cite>coeff</cite>.</p>
<p>See examples for different construction behavior.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>qobj: :class:’qutip.Qobj’</strong></dt><dd><p>The Hamiltonian of the ideal pulse.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>target qubits of the ideal pulse
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>tlist: array-like, optional</strong></dt><dd><p><cite>tlist</cite> of the ideal pulse.
A list of time at which the time-dependent coefficients are applied.
<cite>tlist</cite> does not have to be equidistant, but must have the same length
or one element shorter compared to <cite>coeff</cite>. See documentation for
the parameter <cite>spline_kind</cite>.</p>
</dd>
<dt><strong>coeff: array-like or bool, optional</strong></dt><dd><p>Time-dependent coefficients of the ideal control pulse.
If an array, the length
must be the same or one element longer compared to <cite>tlist</cite>.
See documentation for the parameter <cite>spline_kind</cite>.
If a bool, the coefficient is a constant 1 or 0.</p>
</dd>
<dt><strong>spline_kind: str, optional</strong></dt><dd><p>Type of the coefficient interpolation:
“step_func” or “cubic”.</p>
<p>-“step_func”:
The coefficient will be treated as a step function.
E.g. <code class="docutils literal notranslate"><span class="pre">tlist=[0,1,2]</span></code> and <code class="docutils literal notranslate"><span class="pre">coeff=[3,2]</span></code>, means that the coefficient
is 3 in t=[0,1) and 2 in t=[2,3). It requires
<code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)-1</span></code> or <code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)</span></code>, but
in the second case the last element of <cite>coeff</cite> has no effect.</p>
<p>-“cubic”:
Use cubic interpolation for the coefficient. It requires
<code class="docutils literal notranslate"><span class="pre">len(coeff)=len(tlist)</span></code></p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>The label (name) of the pulse.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a pulse that is turned off</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
</pre></div>
</div>
<p>Create a time dependent pulse</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">spline_kind</span> <span class="o">=</span> <span class="s2">&quot;step_func&quot;</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tlist</span><span class="o">=</span><span class="n">tlist</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">spline_kind</span><span class="o">=</span><span class="s2">&quot;step_func&quot;</span><span class="p">)</span> 
</pre></div>
</div>
<p>Create a time independent pulse</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
</pre></div>
</div>
<p>Create a constant pulse with time range</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tlist</span><span class="o">=</span><span class="n">tlist</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
</pre></div>
</div>
<p>Create an dummy Pulse (H=0)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pulse</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> 
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ideal_pulse: :class:`._EvoElement`</strong></dt><dd><p>The ideal dynamic of the control pulse.</p>
</dd>
<dt><strong>coherent_noise: list of :class:`._EvoElement`</strong></dt><dd><p>The coherent noise caused by the control pulse. Each dynamic element is
still characterized by a time-dependent Hamiltonian.</p>
</dd>
<dt><strong>lindblad_noise: list of :class:`._EvoElement`</strong></dt><dd><p>The dissipative noise of the control pulse. Each dynamic element
will be treated as a (time-dependent) lindblad operator in the
master equation.</p>
</dd>
<dt><strong>spline_kind: str</strong></dt><dd><p>See parameter <cite>spline_kind</cite>.</p>
</dd>
<dt><strong>label: str</strong></dt><dd><p>See parameter <cite>label</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.add_coherent_noise">
<code class="sig-name descname"><span class="pre">add_coherent_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.add_coherent_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.add_coherent_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new (time-dependent) Hamiltonian to the coherent noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:’qutip.Qobj’</strong></dt><dd><p>The Hamiltonian of the pulse.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>target qubits of the pulse
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied.
<cite>tlist</cite> does not have to be equidistant, but must have the same
length
or one element shorter compared to <cite>coeff</cite>. See documentation for
the parameter <cite>spline_kind</cite> of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>.</p>
</dd>
<dt><strong>coeff: array-like or bool, optional</strong></dt><dd><p>Time-dependent coefficients of the pulse noise.
If an array, the length
must be the same or one element longer compared to <cite>tlist</cite>.
See documentation for
the parameter <cite>spline_kind</cite> of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>.
If a bool, the coefficient is a constant 1 or 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.add_lindblad_noise">
<code class="sig-name descname"><span class="pre">add_lindblad_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qobj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.add_lindblad_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.add_lindblad_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new (time-dependent) lindblad noise to the coherent noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qobj: :class:’qutip.Qobj’</strong></dt><dd><p>The collapse operator of the lindblad noise.</p>
</dd>
<dt><strong>targets: list</strong></dt><dd><p>target qubits of the collapse operator
(or subquantum system of other dimensions).</p>
</dd>
<dt><strong>tlist: array-like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied.
<cite>tlist</cite> does not have to be equidistant, but must have the same
length
or one element shorter compared to <cite>coeff</cite>.
See documentation for
the parameter <cite>spline_kind</cite> of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>.</p>
</dd>
<dt><strong>coeff: array-like or bool, optional</strong></dt><dd><p>Time-dependent coefficients of the pulse noise.
If an array, the length
must be the same or one element longer compared to <cite>tlist</cite>.
See documentation for
the parameter <cite>spline_kind</cite> of <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a>.
If a bool, the coefficient is a constant 1 or 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.coeff">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">coeff</span></code><a class="headerlink" href="#qutip.qip.pulse.Pulse.coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>See parameter <cite>coeff</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.get_full_tlist">
<code class="sig-name descname"><span class="pre">get_full_tlist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.get_full_tlist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.get_full_tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full tlist of the pulses and noise.  It means that if
different <code class="docutils literal notranslate"><span class="pre">tlist</span></code> are present, they will be merged to one with all
time points stored in a sorted array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>full_tlist: array-like 1d</dt><dd><p>The full time sequence for the noisy evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.get_ideal_qobj">
<code class="sig-name descname"><span class="pre">get_ideal_qobj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.get_ideal_qobj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.get_ideal_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Hamiltonian of the ideal pulse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: int or list</strong></dt><dd><p>Dimension of the system.
If int, we assume it is the number of qubits in the system.
If list, it is the dimension of the component systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>qobj: <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></dt><dd><p>The Hamiltonian of the ideal pulse.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.get_ideal_qobjevo">
<code class="sig-name descname"><span class="pre">get_ideal_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.get_ideal_qobjevo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.get_ideal_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a <cite>QobjEvo</cite> representation of the ideal evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: int or list</strong></dt><dd><p>Dimension of the system.
If int, we assume it is the number of qubits in the system.
If list, it is the dimension of the component systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ideal_evo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A <cite>QobjEvo</cite> representing the ideal evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.get_noisy_qobjevo">
<code class="sig-name descname"><span class="pre">get_noisy_qobjevo</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.get_noisy_qobjevo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.get_noisy_qobjevo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> representation of the noisy evolution. The
result can be used directly as input for the qutip solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims: int or list</strong></dt><dd><p>Dimension of the system.
If int, we assume it is the number of qubits in the system.
If list, it is the dimension of the component systems.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>noisy_evo: <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">QobjEvo</span></code> representing the ideal evolution and coherent noise.</p>
</dd>
<dt>c_ops: list of <a class="reference internal" href="#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a></dt><dd><p>A list of (time-dependent) lindbald operators.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.print_info">
<code class="sig-name descname"><span class="pre">print_info</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/pulse.html#Pulse.print_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.pulse.Pulse.print_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the information of the pulse, including the ideal dynamics,
the coherent noise and the lindblad noise.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.qobj">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">qobj</span></code><a class="headerlink" href="#qutip.qip.pulse.Pulse.qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>See parameter <cite>qobj</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.targets">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">targets</span></code><a class="headerlink" href="#qutip.qip.pulse.Pulse.targets" title="Permalink to this definition">¶</a></dt>
<dd><p>See parameter <cite>targets</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.pulse.Pulse.tlist">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">tlist</span></code><a class="headerlink" href="#qutip.qip.pulse.Pulse.tlist" title="Permalink to this definition">¶</a></dt>
<dd><p>See parameter <cite>tlist</cite></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.compiler.GateCompiler">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">GateCompiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/gatecompiler.html#GateCompiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.GateCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class. It compiles a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> into
the pulse sequence for the processor. The core member function
<cite>compile</cite> calls compiling method from the sub-class and concatenate
the compiled pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of the component systems.</p>
</dd>
<dt><strong>params: dict, optional</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters,
such as laser frequency, detuning etc.
It will be saved in the class attributes and can be used to calculate
the control pulses.</p>
</dd>
<dt><strong>pulse_dict: dict, optional</strong></dt><dd><p>A map between the pulse label and its index in the pulse list.
If given, the compiled pulse can be identified with
<code class="docutils literal notranslate"><span class="pre">(pulse_label,</span> <span class="pre">coeff)</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">(pulse_index,</span> <span class="pre">coeff)</span></code>.
The number of key-value pairs should match the number of pulses
in the processor.
If it is empty, an integer <code class="docutils literal notranslate"><span class="pre">pulse_index</span></code> needs to be used
in the compiling routine saved under the attributes <code class="docutils literal notranslate"><span class="pre">gate_compiler</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gate_compiler: dict</strong></dt><dd><p>The Python dictionary in the form of {gate_name: compiler_function}.
It saves the compiling routine for each gate. See sub-classes
for implementation.
Note that for continuous pulse, the first coeff should always be 0.</p>
</dd>
<dt><strong>args: dict</strong></dt><dd><p>Arguments for individual compiling routines.
It adds more flexibility in customizing compiler.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.compiler.GateCompiler.compile">
<code class="sig-name descname"><span class="pre">compile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/gatecompiler.html#GateCompiler.compile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.GateCompiler.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile the the native gates into control pulse sequence.
It calls each compiling method and concatenates
the compiled pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>circuit: :class:`.QubitCircuit` or list of</strong></dt><dd><p><a class="reference internal" href="#qutip.qip.Gate" title="qutip.qip.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>
A list of elementary gates that can be implemented in the
corresponding hardware.
The gate names have to be in <cite>gate_compiler</cite>.</p>
</dd>
<dt><strong>schedule_mode: str, optional</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;ASAP&quot;</span></code> for “as soon as possible” or
<code class="docutils literal notranslate"><span class="pre">&quot;ALAP&quot;</span></code> for “as late as possible” or
<code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> for no schedule.
Default is None.</p>
</dd>
<dt><strong>args: dict, optional</strong></dt><dd><p>A dictionary of arguments used in a specific gate compiler
function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape <code class="docutils literal notranslate"><span class="pre">(len(ctrls),</span> <span class="pre">len(tlist))</span></code>. Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.GateCompiler.globalphase_compiler">
<code class="sig-name descname"><span class="pre">globalphase_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/gatecompiler.html#GateCompiler.globalphase_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.GateCompiler.globalphase_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the GLOBALPHASE gate</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.compiler.CavityQEDCompiler">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">CavityQEDCompiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> into
the pulse sequence for the processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>params: dict</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters.
See <a class="reference internal" href="#qutip.qip.device.DispersiveCavityQED.set_up_params" title="qutip.qip.device.DispersiveCavityQED.set_up_params"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DispersiveCavityQED.set_up_params</span></code></a> for the definition.</p>
</dd>
<dt><strong>global_phase: float, optional</strong></dt><dd><p>Record of the global phase change and will be returned.</p>
</dd>
<dt><strong>pulse_dict: dict, optional</strong></dt><dd><p>A map between the pulse label and its index in the pulse list.
If given, the compiled pulse can be identified with
<code class="docutils literal notranslate"><span class="pre">(pulse_label,</span> <span class="pre">coeff)</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">(pulse_index,</span> <span class="pre">coeff)</span></code>.
The number of key-value pairs should match the number of pulses
in the processor.
If it is empty, an integer <code class="docutils literal notranslate"><span class="pre">pulse_index</span></code> needs to be used
in the compiling routine saved under the attributes <code class="docutils literal notranslate"><span class="pre">gate_compiler</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of the component systems.</p>
</dd>
<dt><strong>params: dict</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters,
such as laser frequency, detuning etc.</p>
</dd>
<dt><strong>pulse_dict: dict</strong></dt><dd><p>A map between the pulse label and its index in the pulse list.</p>
</dd>
<dt><strong>gate_compiler: dict</strong></dt><dd><p>The Python dictionary in the form of {gate_name: decompose_function}.
It saves the decomposition scheme for each gate.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.compile">
<code class="sig-name descname"><span class="pre">compile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile the the native gates into control pulse sequence.
It calls each compiling method and concatenates
the compiled pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>circuit: :class:`.QubitCircuit` or list of</strong></dt><dd><p><a class="reference internal" href="#qutip.qip.Gate" title="qutip.qip.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>
A list of elementary gates that can be implemented in the
corresponding hardware.
The gate names have to be in <cite>gate_compiler</cite>.</p>
</dd>
<dt><strong>schedule_mode: str, optional</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;ASAP&quot;</span></code> for “as soon as possible” or
<code class="docutils literal notranslate"><span class="pre">&quot;ALAP&quot;</span></code> for “as late as possible” or
<code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> for no schedule.
Default is None.</p>
</dd>
<dt><strong>args: dict, optional</strong></dt><dd><p>A dictionary of arguments used in a specific gate compiler
function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape <code class="docutils literal notranslate"><span class="pre">(len(ctrls),</span> <span class="pre">len(tlist))</span></code>. Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.globalphase_compiler">
<code class="sig-name descname"><span class="pre">globalphase_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler.globalphase_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.globalphase_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the GLOBALPHASE gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.iswap_compiler">
<code class="sig-name descname"><span class="pre">iswap_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler.iswap_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.iswap_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the ISWAP gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.rx_compiler">
<code class="sig-name descname"><span class="pre">rx_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler.rx_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.rx_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the RX gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.rz_compiler">
<code class="sig-name descname"><span class="pre">rz_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler.rz_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.rz_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the RZ gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.CavityQEDCompiler.sqrtiswap_compiler">
<code class="sig-name descname"><span class="pre">sqrtiswap_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/cavityqedcompiler.html#CavityQEDCompiler.sqrtiswap_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.CavityQEDCompiler.sqrtiswap_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the SQRTISWAP gate</p>
<p class="rubric">Notes</p>
<p>This version of sqrtiswap_compiler has very low fidelity, please use
iswap</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.compiler.SpinChainCompiler">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">SpinChainCompiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile a <a class="reference internal" href="#qutip.qip.circuit.QubitCircuit" title="qutip.qip.circuit.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitCircuit</span></code></a> into
the pulse sequence for the processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of qubits in the system.</p>
</dd>
<dt><strong>params: dict</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters.
See <a class="reference internal" href="#qutip.qip.device.SpinChain.set_up_params" title="qutip.qip.device.SpinChain.set_up_params"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SpinChain.set_up_params</span></code></a> for the definition.</p>
</dd>
<dt><strong>setup: string</strong></dt><dd><p>“linear” or “circular” for two sub-classes.</p>
</dd>
<dt><strong>global_phase: bool</strong></dt><dd><p>Record of the global phase change and will be returned.</p>
</dd>
<dt><strong>pulse_dict: dict, optional</strong></dt><dd><p>A map between the pulse label and its index in the pulse list.
If given, the compiled pulse can be identified with
<code class="docutils literal notranslate"><span class="pre">(pulse_label,</span> <span class="pre">coeff)</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">(pulse_index,</span> <span class="pre">coeff)</span></code>.
The number of key-value pairs should match the number of pulses
in the processor.
If it is empty, an integer <code class="docutils literal notranslate"><span class="pre">pulse_index</span></code> needs to be used
in the compiling routine saved under the attributes <code class="docutils literal notranslate"><span class="pre">gate_compiler</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of the component systems.</p>
</dd>
<dt><strong>params: dict</strong></dt><dd><p>A Python dictionary contains the name and the value of the parameters,
such as laser frequency, detuning etc.</p>
</dd>
<dt><strong>pulse_dict: dict</strong></dt><dd><p>A map between the pulse label and its index in the pulse list.</p>
</dd>
<dt><strong>gate_compiler: dict</strong></dt><dd><p>The Python dictionary in the form of {gate_name: decompose_function}.
It saves the decomposition scheme for each gate.</p>
</dd>
<dt><strong>setup: string</strong></dt><dd><p>“linear” or “circular” for two sub-classes.</p>
</dd>
<dt><strong>global_phase: bool</strong></dt><dd><p>Record of the global phase change and will be returned.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.compile">
<code class="sig-name descname"><span class="pre">compile</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">schedule_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile the the native gates into control pulse sequence.
It calls each compiling method and concatenates
the compiled pulses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>circuit: :class:`.QubitCircuit` or list of</strong></dt><dd><p><a class="reference internal" href="#qutip.qip.Gate" title="qutip.qip.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Gate</span></code></a>
A list of elementary gates that can be implemented in the
corresponding hardware.
The gate names have to be in <cite>gate_compiler</cite>.</p>
</dd>
<dt><strong>schedule_mode: str, optional</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;ASAP&quot;</span></code> for “as soon as possible” or
<code class="docutils literal notranslate"><span class="pre">&quot;ALAP&quot;</span></code> for “as late as possible” or
<code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> for no schedule.
Default is None.</p>
</dd>
<dt><strong>args: dict, optional</strong></dt><dd><p>A dictionary of arguments used in a specific gate compiler
function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tlist: array_like</dt><dd><p>A NumPy array specifies the time of each coefficient</p>
</dd>
<dt>coeffs: array_like</dt><dd><p>A 2d NumPy array of the shape <code class="docutils literal notranslate"><span class="pre">(len(ctrls),</span> <span class="pre">len(tlist))</span></code>. Each
row corresponds to the control pulse sequence for
one Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.globalphase_compiler">
<code class="sig-name descname"><span class="pre">globalphase_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler.globalphase_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.globalphase_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the GLOBALPHASE gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.iswap_compiler">
<code class="sig-name descname"><span class="pre">iswap_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler.iswap_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.iswap_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the ISWAP gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.rx_compiler">
<code class="sig-name descname"><span class="pre">rx_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler.rx_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.rx_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the RX gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.rz_compiler">
<code class="sig-name descname"><span class="pre">rz_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler.rz_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.rz_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the RZ gate</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.SpinChainCompiler.sqrtiswap_compiler">
<code class="sig-name descname"><span class="pre">sqrtiswap_compiler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/spinchaincompiler.html#SpinChainCompiler.sqrtiswap_compiler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.SpinChainCompiler.sqrtiswap_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiler for the SQRTISWAP gate</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.compiler.Scheduler">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Scheduler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ALAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_functions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/scheduler.html#Scheduler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.Scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>A gate (pulse) scheduler for quantum circuits (instructions).
It schedules a given circuit or instructions
to reduce the total execution time by parallelization.
It uses heuristic methods mainly from
in <a class="reference external" href="https://doi.org/10.1117/12.666419">https://doi.org/10.1117/12.666419</a>.</p>
<p>The scheduler includes two methods,
“ASAP”, as soon as possible, and “ALAP”, as late as possible.
The later is commonly used in quantum computation
because of the finite lifetime of qubits.</p>
<p>The scheduler aims at pulse schedule and
therefore does not consider merging gates to reduce the gates number.
It assumes that the input circuit is optimized at the gate level
and matches the hardware topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method: str</strong></dt><dd><p>“ASAP” for as soon as possible.
“ALAP” for as late as possible.</p>
</dd>
<dt><strong>constraint_functions: list, optional</strong></dt><dd><p>A list of hardware constraint functions.
Default includes a function <cite>qubit_contraint</cite>,
i.e. one qubit cannot be used by two gates at the same time.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.qip.compiler.Scheduler.apply_constraint">
<code class="sig-name descname"><span class="pre">apply_constraint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instructions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/scheduler.html#Scheduler.apply_constraint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.Scheduler.apply_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply hardware constraint to check
if two instructions can be executed in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind1, ind2: int</strong></dt><dd><p>indices of the two instructions</p>
</dd>
<dt><strong>instructions: list</strong></dt><dd><p>The instruction list</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.Scheduler.commutation_rules">
<code class="sig-name descname"><span class="pre">commutation_rules</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ind2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instructions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/scheduler.html#Scheduler.commutation_rules"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.Scheduler.commutation_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two gates commute, given that their used qubits overlap.
Since usually the input gates are already in a universal gate sets,
it uses an oversimplified condition:</p>
<p>If the two gates do not have the same name,
they are considered as not commuting.
If they are the same gate and have the same controls or targets,
they are considered as commuting.
E.g. <cite>CNOT 0, 1</cite> commute with <cite>CNOT 0, 2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.qip.compiler.Scheduler.schedule">
<code class="sig-name descname"><span class="pre">schedule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gates_schedule</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_cycles_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/scheduler.html#Scheduler.schedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.Scheduler.schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule a <cite>QubitCircuit</cite>,
a list of <cite>Gates</cite> or a list of <cite>Instruction</cite>.
For pulse schedule, the execution time for each <cite>Instruction</cite>
is given in its <cite>duration</cite> attributes.</p>
<p>The scheduler first generates a quantum gates dependency graph,
containing information about
which gates have to be executed before some other gates.
The graph preserves the mobility of the gates,
i.e. commuting gates are not dependent on each other,
even if they use the same qubits.
Next, it computes the longest distance of each node
to the start and end nodes.
The distance for each dependency arrow is defined
by the execution time of the instruction
(By default, it is 1 for all gates).
This is used as a priority measure in the next step.
The gate with a longer distance to the end node and
a shorter distance to the start node has higher priority.
In the last step, it uses a list-schedule algorithm
with hardware constraint and priority and
returns a list of cycles for gates/instructions.</p>
<p>For pulse schedule, an additional step is required
to compute the start time of each instruction.
It adds the additional dependency
caused by hardware constraint to the graph
and recomputes the distance of each node to the start and end node.
This distance is then converted to
the start time of each instruction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>circuit: QubitCircuit or list</strong></dt><dd><p>For gate schedule,
it should be a QubitCircuit or a list of Gate objects.
For pulse schedule, it should be a list of Instruction objects,
each with an attribute <cite>duration</cite>
that indicates the execution time of this instruction.</p>
</dd>
<dt><strong>gates_schedule: bool, optional</strong></dt><dd><p><cite>True</cite>, if only gates schedule is needed.
This saves some computation
that is only useful to pulse schedule.
If the input <cite>circuit</cite> is a <cite>QubitCircuit</cite>,
it will be assigned to <cite>True</cite> automatically.
Otherwise, the default is <cite>False</cite>.</p>
</dd>
<dt><strong>return_cycles_list: bool, optional</strong></dt><dd><p>If <cite>True</cite>, the method returns the <cite>cycles_list</cite>,
e.g. [{0, 2}, {1, 3}],
which means that the first cycle contains gates0 and gates2
while the second cycle contains gates1 and gates3.
It is only usefull for gates schedule.</p>
</dd>
<dt><strong>random_shuffle: bool, optional</strong></dt><dd><p>If the commuting gates are randomly scuffled to explore
larger search space.</p>
</dd>
<dt><strong>repeat_num: int, optional</strong></dt><dd><p>Repeat the scheduling several times and use the best result.
Used together with <code class="docutils literal notranslate"><span class="pre">random_shuffle=Ture</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>gate_cycle_indices or instruction_start_time: list</dt><dd><p>The cycle indices for each gate or
the start time for each instruction.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.scheduler</span> <span class="kn">import</span> <span class="n">Scheduler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SNOT&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># gate0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CZ&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># gate1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CZ&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># gate2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CZ&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># gate3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CZ&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># gate4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CZ&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># gate5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circuit</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SWAP&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># gate6</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">Scheduler</span><span class="p">(</span><span class="s2">&quot;ASAP&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">gates_schedule</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[0, 1, 3, 2, 2, 3, 4]</span>
</pre></div>
</div>
<p>The result list is the cycle indices for each gate.
It means that the circuit can be executed in 5 gate cycles:
<code class="docutils literal notranslate"><span class="pre">[gate0,</span> <span class="pre">gate1,</span> <span class="pre">(gate3,</span> <span class="pre">gate4),</span> <span class="pre">(gate2,</span> <span class="pre">gate5),</span> <span class="pre">gate6]</span></code>
Notice that gate3 and gate4 commute with gate2,
therefore, the order is changed to reduce the number of cycles.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.qip.compiler.Instruction">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Instruction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pulse_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/qip/compiler/instruction.html#Instruction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.qip.compiler.Instruction" title="Permalink to this definition">¶</a></dt>
<dd><p>The instruction that implements a quantum gate.
It contains the control pulse required to implement the gate
on a particular hardware model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gate: :class:`.Gate`</strong></dt><dd><p>The quantum gate.</p>
</dd>
<dt><strong>duration: list, optional</strong></dt><dd><p>The execution time needed for the instruction.</p>
</dd>
<dt><strong>tlist: array_like, optional</strong></dt><dd><p>A list of time at which the time-dependent coefficients are
applied. See <a class="reference internal" href="#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pulse</span></code></a> for detailed information`</p>
</dd>
<dt><strong>pulse_info: list, optional</strong></dt><dd><p>A list of tuples, each tuple corresponding to a pair of pulse label
and pulse coefficient, in the format (str, array_like).
This pulses will implement the desired gate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>targets: list, optional</strong></dt><dd><p>The target qubits.</p>
</dd>
<dt><strong>controls: list, optional</strong></dt><dd><p>The control qubits.</p>
</dd>
<dt><strong>used_qubits: set</strong></dt><dd><p>Union of the control and target qubits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="optimal-control">
<span id="classes-control"></span><h2>Optimal control<a class="headerlink" href="#optimal-control" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="qutip.control.optimizer.Optimizer">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Optimizer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all control pulse optimisers. This class should not be
instantiated, use its subclasses.  This class implements the fidelity,
gradient and interation callback functions.  All subclass objects must be
initialised with a</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">OptimConfig</span></code> instance - various configuration options</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dynamics</span></code> instance - describes the dynamics of the (quantum) system
to be control optimised</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.  Options are attributes of
qutip.logging_utils, in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution, assuming
everything runs as expected.  The default NOTSET implies that the level
will be taken from the QuTiP settings file, which by default is WARN.</p>
</dd>
<dt><strong>params:  Dictionary</strong></dt><dd><p>The key value pairs are the attribute name and value. Note: attributes
are created if they do not exist already, and are overwritten if they
do.</p>
</dd>
<dt><strong>alg</strong><span class="classifier">string</span></dt><dd><p>Algorithm to use in pulse optimisation.  Options are:</p>
<ul class="simple">
<li><p>‘GRAPE’ (default) - GRadient Ascent Pulse Engineering</p></li>
<li><p>‘CRAB’ - Chopped RAndom Basis</p></li>
</ul>
</dd>
<dt><strong>alg_params</strong><span class="classifier">Dictionary</span></dt><dd><p>Options that are specific to the pulse optim algorithm <code class="docutils literal notranslate"><span class="pre">alg</span></code>.</p>
</dd>
<dt><strong>disp_conv_msg</strong><span class="classifier">bool</span></dt><dd><p>Set true to display a convergence message
(for scipy.optimize.minimize methods anyway)</p>
</dd>
<dt><strong>optim_method</strong><span class="classifier">string</span></dt><dd><p>a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error</p>
</dd>
<dt><strong>method_params</strong><span class="classifier">Dictionary</span></dt><dd><p>Options for the optim_method.
Note that where there is an equivalent attribute of this instance
or the termination_conditions (for example maxiter)
it will override an value in these options</p>
</dd>
<dt><strong>approx_grad</strong><span class="classifier">bool</span></dt><dd><p>If set True then the method will approximate the gradient itself
(if it has requirement and facility for this)
This will mean that the fid_err_grad_wrapper will not get called
Note it should be left False when using the Dynamics
to calculate approximate gradients
Note it is set True automatically when the alg is CRAB</p>
</dd>
<dt><strong>amp_lbound</strong><span class="classifier">float or list of floats</span></dt><dd><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong><span class="classifier">float or list of floats</span></dt><dd><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">List of floats</span></dt><dd><p>Bounds for the parameters.
If not set before the run_optimization call then the list
is built automatically based on the amp_lbound and amp_ubound
attributes.
Setting this attribute directly allows specific bounds to be set
for individual parameters.
Note: Only some methods use bounds</p>
</dd>
<dt><strong>dynamics</strong><span class="classifier">Dynamics (subclass instance)</span></dt><dd><p>describes the dynamics of the (quantum) system to be control optimised
(see Dynamics classes for details)</p>
</dd>
<dt><strong>config</strong><span class="classifier">OptimConfig instance</span></dt><dd><p>various configuration options
(see OptimConfig for details)</p>
</dd>
<dt><strong>termination_conditions</strong><span class="classifier">TerminationCondition instance</span></dt><dd><p>attributes determine when the optimisation will end</p>
</dd>
<dt><strong>pulse_generator</strong><span class="classifier">PulseGen (subclass instance)</span></dt><dd><p>(can be) used to create initial pulses
not used by the class, but set by pulseoptim.create_pulse_optimizer</p>
</dd>
<dt><strong>stats</strong><span class="classifier">Stats</span></dt><dd><p>attributes of which give performance stats for the optimisation
set to None to reduce overhead of calculating stats.
Note it is (usually) shared with the Dynamics instance</p>
</dd>
<dt><strong>dump</strong><span class="classifier"><a class="reference internal" href="#qutip.control.dump.OptimDump" title="qutip.control.dump.OptimDump"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.control.dump.OptimDump</span></code></a></span></dt><dd><p>Container for data dumped during the optimisation.
Can be set by specifying the dumping level or set directly.
Note this is mainly intended for user and a development debugging
but could be used for status information during a long optimisation.</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.optimizer.Optimizer.dumping" title="qutip.control.optimizer.Optimizer.dumping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></a><span class="classifier">string</span></dt><dd><p>The level of data dumping that will occur during the optimisation</p>
</dd>
<dt><strong>dump_to_file</strong><span class="classifier">bool</span></dt><dd><p>If set True then data will be dumped to file during the optimisation
dumping will be set to SUMMARY during init_optim
if dump_to_file is True and dumping not set.
Default is False</p>
</dd>
<dt><strong>dump_dir</strong><span class="classifier">string</span></dt><dd><p>Basically a link to dump.dump_dir. Exists so that it can be set through
optim_params.
If dump is None then will return None or will set dumping to SUMMARY
when setting a path</p>
</dd>
<dt><strong>iter_summary</strong><span class="classifier"><a class="reference internal" href="#qutip.control.optimizer.OptimIterSummary" title="qutip.control.optimizer.OptimIterSummary"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimIterSummary</span></code></a></span></dt><dd><p>Summary of the most recent iteration.
Note this is only set if dummping is on</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.apply_method_params">
<code class="sig-name descname"><span class="pre">apply_method_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.apply_method_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.apply_method_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Loops through all the method_params
(either passed here or the method_params attribute)
If the name matches an attribute of this object or the
termination conditions object, then the value of this attribute
is set. Otherwise it is assumed to a method_option for the
scipy.optimize.minimize function</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.dumping">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dumping</span></code><a class="headerlink" href="#qutip.control.optimizer.Optimizer.dumping" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of data dumping that will occur during the optimisation</p>
<ul class="simple">
<li><p>NONE : No processing data dumped (Default)</p></li>
<li><p>SUMMARY : A summary at each iteration will be recorded</p></li>
<li><p>FULL : All logs will be generated and dumped</p></li>
<li><p>CUSTOM : Some customised level of dumping</p></li>
</ul>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify which logs are dumped</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.fid_err_func_wrapper">
<code class="sig-name descname"><span class="pre">fid_err_func_wrapper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.fid_err_func_wrapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.fid_err_func_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fidelity error achieved using the ctrl amplitudes passed
in as the first argument.</p>
<p>This is called by generic optimisation algorithm as the
func to the minimised. The argument is the current
variable values, i.e. control amplitudes, passed as
a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]
and then used to update the stored ctrl values (if they have changed)</p>
<p>The error is checked against the target, and the optimisation is
terminated if the target has been achieved.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.fid_err_grad_wrapper">
<code class="sig-name descname"><span class="pre">fid_err_grad_wrapper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.fid_err_grad_wrapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.fid_err_grad_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the gradient of the fidelity error with respect to all of the
variables, i.e. the ctrl amplidutes in each timeslot</p>
<p>This is called by generic optimisation algorithm as the gradients of
func to the minimised wrt the variables. The argument is the current
variable values, i.e. control amplitudes, passed as
a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]
and then used to update the stored ctrl values (if they have changed)</p>
<p>Although the optimisation algorithms have a check within them for
function convergence, i.e. local minima, the sum of the squares
of the normalised gradient is checked explicitly, and the
optimisation is terminated if this is below the min_gradient_norm
condition</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.init_optim">
<code class="sig-name descname"><span class="pre">init_optim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.init_optim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.iter_step_callback_func">
<code class="sig-name descname"><span class="pre">iter_step_callback_func</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.iter_step_callback_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.iter_step_callback_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the elapsed wall time for the optimisation run so far.
Terminate if this has exceeded the maximum allowed time</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.Optimizer.run_optimization">
<code class="sig-name descname"><span class="pre">run_optimization</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#Optimizer.run_optimization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>This default function optimisation method is a wrapper to the
scipy.optimize.minimize function.</p>
<p>It will attempt to minimise the fidelity error with respect to some
parameters, which are determined by _get_optim_var_vals (see below)</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, wall time, or
function call or iteration count exceeded. Note these
conditions include gradient minimum met (local minima) for
methods that use a gradient.</p>
<p>The function minimisation method is taken from the optim_method
attribute. Note that not all of these methods have been tested.
Note that some of these use a gradient and some do not.
See the scipy documentation for details. Options specific to the
method can be passed setting the method_params attribute.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimizer.OptimizerBFGS">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimizerBFGS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerBFGS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the run_optimization method using the BFGS algorithm</p>
<dl class="py method">
<dt id="qutip.control.optimizer.OptimizerBFGS.run_optimization">
<code class="sig-name descname"><span class="pre">run_optimization</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerBFGS.run_optimization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerBFGS.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise the control pulse amplitudes to minimise the fidelity error
using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm
The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, gradient minimum met
(local minima), wall time / iteration count exceeded.</p>
<p>Essentially this is wrapper to the:
scipy.optimize.fmin_bfgs
function</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimizer.OptimizerLBFGSB">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimizerLBFGSB</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerLBFGSB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the run_optimization method using the L-BFGS-B algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_metric_corr</strong><span class="classifier">integer</span></dt><dd><p>The maximum number of variable metric corrections used to define
the limited memory matrix. That is the number of previous
gradient values that are used to approximate the Hessian
see the scipy.optimize.fmin_l_bfgs_b documentation for description
of m argument</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.optimizer.OptimizerLBFGSB.init_optim">
<code class="sig-name descname"><span class="pre">init_optim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerLBFGSB.init_optim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.optimizer.OptimizerLBFGSB.run_optimization">
<code class="sig-name descname"><span class="pre">run_optimization</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerLBFGSB.run_optimization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise the control pulse amplitudes to minimise the fidelity error
using the L-BFGS-B algorithm, which is the constrained
(bounded amplitude values), limited memory, version of the
Broyden–Fletcher–Goldfarb–Shanno algorithm.</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, gradient minimum met
(local minima), wall time / iteration count exceeded.</p>
<p>Essentially this is wrapper to the:
scipy.optimize.fmin_l_bfgs_b function
This in turn is a warpper for well established implementation of
the L-BFGS-B algorithm written in Fortran, which is therefore
very fast. See SciPy documentation for credit and details on
this function.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimizer.OptimizerCrab">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimizerCrab</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerCrab"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimises the pulse using the CRAB algorithm [1].
It uses the scipy.optimize.minimize function with the method specified
by the optim_method attribute. See Optimizer.run_optimization for details
It minimises the fidelity error function with respect to the CRAB
basis function coefficients.</p>
<p>AJGP ToDo: Add citation here</p>
<dl class="py method">
<dt id="qutip.control.optimizer.OptimizerCrab.init_optim">
<code class="sig-name descname"><span class="pre">init_optim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerCrab.init_optim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrab.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimizer.OptimizerCrabFmin">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimizerCrabFmin</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerCrabFmin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrabFmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimises the pulse using the CRAB algorithm <a class="reference internal" href="#rdf03e412f8b6-1" id="id2">[1]</a>, <a class="reference internal" href="#rdf03e412f8b6-2" id="id3">[2]</a>.
It uses the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.fmin</span></code> function which is effectively a wrapper
for the Nelder-Mead method.  It minimises the fidelity error function with
respect to the CRAB basis function coefficients.  This is the default
Optimizer for CRAB.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdf03e412f8b6-1"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>P. Doria, T. Calarco &amp; S. Montangero. Phys. Rev. Lett. 106, 190501
(2011).</p>
</dd>
<dt class="label" id="rdf03e412f8b6-2"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>T. Caneva, T. Calarco, &amp; S. Montangero. Phys. Rev. A 84, 022326
(2011).</p>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.optimizer.OptimizerCrabFmin.run_optimization">
<code class="sig-name descname"><span class="pre">run_optimization</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term_conds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimizerCrabFmin.run_optimization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrabFmin.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>This function optimisation method is a wrapper to the
scipy.optimize.fmin function.</p>
<p>It will attempt to minimise the fidelity error with respect to some
parameters, which are determined by _get_optim_var_vals which
in the case of CRAB are the basis function coefficients</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, wall time, or
function call or iteration count exceeded. Specifically to the fmin
method, the optimisation will stop when change parameter values
is less than xtol or the change in function value is below ftol.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimizer.OptimIterSummary">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimIterSummary</span></code><a class="reference internal" href="../modules/qutip/control/optimizer.html#OptimIterSummary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimizer.OptimIterSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>A summary of the most recent iteration of the pulse optimisation</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iter_num</strong><span class="classifier">int</span></dt><dd><p>Iteration number of the pulse optimisation</p>
</dd>
<dt><strong>fid_func_call_num</strong><span class="classifier">int</span></dt><dd><p>Fidelity function call number of the pulse optimisation</p>
</dd>
<dt><strong>grad_func_call_num</strong><span class="classifier">int</span></dt><dd><p>Gradient function call number of the pulse optimisation</p>
</dd>
<dt><strong>fid_err</strong><span class="classifier">float</span></dt><dd><p>Fidelity error</p>
</dd>
<dt><strong>grad_norm</strong><span class="classifier">float</span></dt><dd><p>fidelity gradient (wrt the control parameters) vector norm
that is the magnitude of the gradient</p>
</dd>
<dt><strong>wall_time</strong><span class="classifier">float</span></dt><dd><p>Time spent computing the pulse optimisation so far
(in seconds of elapsed time)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.control.termcond.TerminationConditions">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">TerminationConditions</span></code><a class="reference internal" href="../modules/qutip/control/termcond.html#TerminationConditions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.termcond.TerminationConditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all termination conditions
Used to determine when to stop the optimisation algorithm
Note different subclasses should be used to match the type of
optimisation being used</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fid_err_targ</strong><span class="classifier">float</span></dt><dd><p>Target fidelity error</p>
</dd>
<dt><strong>fid_goal</strong><span class="classifier">float</span></dt><dd><p>goal fidelity, e.g. 1 - self.fid_err_targ
It its typical to set this for unitary systems</p>
</dd>
<dt><strong>max_wall_time</strong><span class="classifier">float</span></dt><dd><p># maximum time for optimisation (seconds)</p>
</dd>
<dt><strong>min_gradient_norm</strong><span class="classifier">float</span></dt><dd><p>Minimum normalised gradient after which optimisation will terminate</p>
</dd>
<dt><strong>max_iterations</strong><span class="classifier">integer</span></dt><dd><p>Maximum iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_fid_func_calls</strong><span class="classifier">integer</span></dt><dd><p>Maximum number of calls to the fidelity function during
the optimisation algorithm</p>
</dd>
<dt><strong>accuracy_factor</strong><span class="classifier">float</span></dt><dd><p>Determines the accuracy of the result.
Typical values for accuracy_factor are: 1e12 for low accuracy;
1e7 for moderate accuracy; 10.0 for extremely high accuracy
scipy.optimize.fmin_l_bfgs_b factr argument.
Only set for specific methods (fmin_l_bfgs_b) that uses this
Otherwise the same thing is passed as method_option ftol
(although the scale is different)
Hence it is not defined here, but may be set by the user</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.control.optimresult.OptimResult">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimResult</span></code><a class="reference internal" href="../modules/qutip/control/optimresult.html#OptimResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.optimresult.OptimResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Attributes give the result of the pulse optimisation attempt</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>termination_reason</strong><span class="classifier">string</span></dt><dd><p>Description of the reason for terminating the optimisation</p>
</dd>
<dt><strong>fidelity</strong><span class="classifier">float</span></dt><dd><p>final (normalised) fidelity that was achieved</p>
</dd>
<dt><strong>initial_fid_err</strong><span class="classifier">float</span></dt><dd><p>fidelity error before optimisation starting</p>
</dd>
<dt><strong>fid_err</strong><span class="classifier">float</span></dt><dd><p>final fidelity error that was achieved</p>
</dd>
<dt><strong>goal_achieved</strong><span class="classifier">boolean</span></dt><dd><p>True is the fidely error achieved was below the target</p>
</dd>
<dt><strong>grad_norm_final</strong><span class="classifier">float</span></dt><dd><p>Final value of the sum of the squares of the (normalised) fidelity
error gradients</p>
</dd>
<dt><strong>grad_norm_min_reached</strong><span class="classifier">float</span></dt><dd><p>True if the optimisation terminated due to the minimum value
of the gradient being reached</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">integer</span></dt><dd><p>Number of iterations of the optimisation algorithm completed</p>
</dd>
<dt><strong>max_iter_exceeded</strong><span class="classifier">boolean</span></dt><dd><p>True if the iteration limit was reached</p>
</dd>
<dt><strong>max_fid_func_exceeded</strong><span class="classifier">boolean</span></dt><dd><p>True if the fidelity function call limit was reached</p>
</dd>
<dt><strong>wall_time</strong><span class="classifier">float</span></dt><dd><p>time elapsed during the optimisation</p>
</dd>
<dt><strong>wall_time_limit_exceeded</strong><span class="classifier">boolean</span></dt><dd><p>True if the wall time limit was reached</p>
</dd>
<dt><strong>time</strong><span class="classifier">array[num_tslots+1] of float</span></dt><dd><p>Time are the start of each timeslot
with the final value being the total evolution time</p>
</dd>
<dt><strong>initial_amps</strong><span class="classifier">array[num_tslots, n_ctrls]</span></dt><dd><p>The amplitudes at the start of the optimisation</p>
</dd>
<dt><strong>final_amps</strong><span class="classifier">array[num_tslots, n_ctrls]</span></dt><dd><p>The amplitudes at the end of the optimisation</p>
</dd>
<dt><strong>evo_full_final</strong><span class="classifier">Qobj</span></dt><dd><p>The evolution operator from t=0 to t=T based on the final amps</p>
</dd>
<dt><strong>evo_full_initial</strong><span class="classifier">Qobj</span></dt><dd><p>The evolution operator from t=0 to t=T based on the initial amps</p>
</dd>
<dt><strong>stats</strong><span class="classifier">Stats</span></dt><dd><p>Object contaning the stats for the run (if any collected)</p>
</dd>
<dt><strong>optimizer</strong><span class="classifier">Optimizer</span></dt><dd><p>Instance of the Optimizer used to generate the result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="qutip.control.dynamics.Dynamics">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Dynamics</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimconfig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a base class only. See subclass descriptions and choose an
appropriate one for the application.</p>
<p>Note that initialize_controls must be called before most of the methods
can be used. init_timeslots can be called sometimes earlier in order
to access timeslot related attributes</p>
<p>This acts as a container for the operators that are used to calculate
time evolution of the system under study. That is the dynamics generators
(Hamiltonians, Lindbladians etc), the propagators from one timeslot to
the next, and the evolution operators. Due to the large number of matrix
additions and multiplications, for small systems at least, the optimisation
performance is much better using ndarrays to represent these operators.
However</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>params:  Dictionary</strong></dt><dd><p>The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">Stats</span></dt><dd><p>Attributes of which give performance stats for the optimisation
set to None to reduce overhead of calculating stats.
Note it is (usually) shared with the Optimizer object</p>
</dd>
<dt><strong>tslot_computer</strong><span class="classifier">TimeslotComputer (subclass instance)</span></dt><dd><p>Used to manage when the timeslot dynamics
generators, propagators, gradients etc are updated</p>
</dd>
<dt><strong>prop_computer</strong><span class="classifier">PropagatorComputer (subclass instance)</span></dt><dd><p>Used to compute the propagators and their gradients</p>
</dd>
<dt><strong>fid_computer</strong><span class="classifier">FidelityComputer (subclass instance)</span></dt><dd><p>Used to computer the fidelity error and the fidelity error
gradient.</p>
</dd>
<dt><strong>memory_optimization</strong><span class="classifier">int</span></dt><dd><p>Level of memory optimisation. Setting to 0 (default) means that
execution speed is prioritized over memory.
Setting to 1 means that some memory prioritisation steps will be
taken, for instance using Qobj (and hence sparse arrays) as the
the internal operator data type, and not caching some operators
Potentially further memory saving maybe made with
memory_optimization &gt; 1.
The options are processed in _set_memory_optimizations, see
this for more information. Individual memory saving  options can be
switched by settting them directly (see below)</p>
</dd>
<dt><strong>oper_dtype</strong><span class="classifier">type</span></dt><dd><p>Data type for internal dynamics generators, propagators and time
evolution operators. This can be ndarray or Qobj.
Qobj may perform better for larger systems, and will also
perform better when (custom) fidelity measures use Qobj methods
such as partial trace.
See _choose_oper_dtype for how this is chosen when not specified</p>
</dd>
<dt><strong>cache_phased_dyn_gen</strong><span class="classifier">bool</span></dt><dd><p>If True then the dynamics generators will be saved with and
without the propagation prefactor (if there is one)
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>cache_prop_grad</strong><span class="classifier">bool</span></dt><dd><p>If the True then the propagator gradients (for exact gradients) will
be computed when the propagator are computed and cache until
the are used by the fidelity computer. If False then the
fidelity computer will calculate them as needed.
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>cache_dyn_gen_eigenvectors_adj: bool</strong></dt><dd><p>If True then DynamicsUnitary will cached the adjoint of
the Hamiltion eignvector matrix
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>sparse_eigen_decomp: bool</strong></dt><dd><p>If True then DynamicsUnitary will use the sparse eigenvalue
decomposition.
Defaults to True when memory_optimization&lt;=1, otherwise False</p>
</dd>
<dt><strong>num_tslots</strong><span class="classifier">integer</span></dt><dd><p>Number of timeslots (aka timeslices)</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.num_ctrls" title="qutip.control.dynamics.Dynamics.num_ctrls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_ctrls</span></code></a><span class="classifier">integer</span></dt><dd><p>calculate the of controls from the length of the control list</p>
</dd>
<dt><strong>evo_time</strong><span class="classifier">float</span></dt><dd><p>Total time for the evolution</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of float</span></dt><dd><p>Duration of each timeslot
Note that if this is set before initialize_controls is called
then num_tslots and evo_time are calculated from tau, otherwise
tau is generated from num_tslots and evo_time, that is
equal size time slices</p>
</dd>
<dt><strong>time</strong><span class="classifier">array[num_tslots+1] of float</span></dt><dd><p>Cumulative time for the evolution, that is the time at the start
of each time slice</p>
</dd>
<dt><strong>drift_dyn_gen</strong><span class="classifier">Qobj or list of Qobj</span></dt><dd><p>Drift or system dynamics generator (Hamiltonian)
Matrix defining the underlying dynamics of the system
Can also be a list of Qobj (length num_tslots) for time varying
drift dynamics</p>
</dd>
<dt><strong>ctrl_dyn_gen</strong><span class="classifier">List of Qobj</span></dt><dd><p>Control dynamics generator (Hamiltonians)
List of matrices defining the control dynamics</p>
</dd>
<dt><strong>initial</strong><span class="classifier">Qobj</span></dt><dd><p>Starting state / gate
The matrix giving the initial state / gate, i.e. at time 0
Typically the identity for gate evolution</p>
</dd>
<dt><strong>target</strong><span class="classifier">Qobj</span></dt><dd><p>Target state / gate:
The matrix giving the desired state / gate for the evolution</p>
</dd>
<dt><strong>ctrl_amps</strong><span class="classifier">array[num_tslots, num_ctrls] of float</span></dt><dd><p>Control amplitudes
The amplitude (scale factor) for each control in each timeslot</p>
</dd>
<dt><strong>initial_ctrl_scaling</strong><span class="classifier">float</span></dt><dd><p>Scale factor applied to be applied the control amplitudes
when they are initialised
This is used by the PulseGens rather than in any fucntions in
this class</p>
</dd>
<dt><strong>initial_ctrl_offset</strong><span class="classifier">float</span></dt><dd><p>Linear offset applied to be applied the control amplitudes
when they are initialised
This is used by the PulseGens rather than in any fucntions in
this class</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.dyn_gen" title="qutip.control.dynamics.Dynamics.dyn_gen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dyn_gen</span></code></a><span class="classifier">List of Qobj</span></dt><dd><p>List of combined dynamics generators (Qobj) for each timeslot</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.prop" title="qutip.control.dynamics.Dynamics.prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop</span></code></a><span class="classifier">list of Qobj</span></dt><dd><p>List of propagators (Qobj) for each timeslot</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.prop_grad" title="qutip.control.dynamics.Dynamics.prop_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop_grad</span></code></a><span class="classifier">array[num_tslots, num_ctrls] of Qobj</span></dt><dd><p>Array of propagator gradients (Qobj) for each timeslot, control</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.fwd_evo" title="qutip.control.dynamics.Dynamics.fwd_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwd_evo</span></code></a><span class="classifier">List of Qobj</span></dt><dd><p>List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.onwd_evo" title="qutip.control.dynamics.Dynamics.onwd_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">onwd_evo</span></code></a><span class="classifier">List of Qobj</span></dt><dd><p>List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.onto_evo" title="qutip.control.dynamics.Dynamics.onto_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">onto_evo</span></code></a><span class="classifier">List of Qobj</span></dt><dd><p>List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><strong>evo_current</strong><span class="classifier">Boolean</span></dt><dd><p>Used to flag that the dynamics used to calculate the evolution
operators is current. It is set to False when the amplitudes
change</p>
</dd>
<dt><strong>fact_mat_round_prec</strong><span class="classifier">float</span></dt><dd><p>Rounding precision used when calculating the factor matrix
to determine if two eigenvalues are equivalent
Only used when the PropagatorComputer uses diagonalisation</p>
</dd>
<dt><strong>def_amps_fname</strong><span class="classifier">string</span></dt><dd><p>Default name for the output used when save_amps is called</p>
</dd>
<dt><strong>unitarity_check_level</strong><span class="classifier">int</span></dt><dd><p>If &gt; 0 then unitarity of the system evolution is checked at at
evolution recomputation.
level 1 checks all propagators
level 2 checks eigen basis as well
Default is 0</p>
</dd>
<dt><strong>unitarity_tol :</strong></dt><dd><p>Tolerance used in checking if operator is unitary
Default is 1e-10</p>
</dd>
<dt><strong>dump</strong><span class="classifier"><a class="reference internal" href="#qutip.control.dump.DynamicsDump" title="qutip.control.dump.DynamicsDump"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.control.dump.DynamicsDump</span></code></a></span></dt><dd><p>Store of historical calculation data.
Set to None (Default) for no storing of historical data
Use dumping property to set level of data dumping</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.dumping" title="qutip.control.dynamics.Dynamics.dumping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></a><span class="classifier">string</span></dt><dd><p>The level of data dumping that will occur during the time evolution calculation.</p>
</dd>
<dt><strong>dump_to_file</strong><span class="classifier">bool</span></dt><dd><p>If set True then data will be dumped to file during the calculations
dumping will be set to SUMMARY during init_evo if dump_to_file is True
and dumping not set.
Default is False</p>
</dd>
<dt><strong>dump_dir</strong><span class="classifier">string</span></dt><dd><p>Basically a link to dump.dump_dir. Exists so that it can be set through
dyn_params.
If dump is None then will return None or will set dumping to SUMMARY
when setting a path</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.combine_dyn_gen">
<code class="sig-name descname"><span class="pre">combine_dyn_gen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.combine_dyn_gen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.combine_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the dynamics generator for a given timeslot
The is the combined Hamiltion for unitary systems</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.compute_evolution">
<code class="sig-name descname"><span class="pre">compute_evolution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.compute_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.compute_evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculate the time evolution operators
Dynamics generators (e.g. Hamiltonian) and
prop (propagators) are calculated as necessary
Actual work is completed by the recompute_evolution method
of the timeslot computer</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.dumping">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dumping</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dumping" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of data dumping that will occur during the time evolution
calculation.</p>
<ul class="simple">
<li><p>NONE : No processing data dumped (Default)</p></li>
<li><p>SUMMARY : A summary of each time evolution will be recorded</p></li>
<li><p>FULL : All operators used or created in the calculation dumped</p></li>
<li><p>CUSTOM : Some customised level of dumping</p></li>
</ul>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify which operators are dumped.  WARNING: FULL could
consume a lot of memory!</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.dyn_gen">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dyn_gen</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>List of combined dynamics generators (Qobj) for each timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.dyn_gen_phase">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dyn_gen_phase</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dyn_gen_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Some op that is applied to the dyn_gen before expontiating to
get the propagator.
See <cite>phase_application</cite> for how this is applied</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.flag_system_changed">
<code class="sig-name descname"><span class="pre">flag_system_changed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.flag_system_changed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag evolution, fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.full_evo">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">full_evo</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.full_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>Full evolution - time evolution at final time slot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.fwd_evo">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">fwd_evo</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.fwd_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen">
<code class="sig-name descname"><span class="pre">get_ctrl_dyn_gen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.get_ctrl_dyn_gen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dynamics generator for the control
Not implemented in the base class. Choose a subclass</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.get_drift_dim">
<code class="sig-name descname"><span class="pre">get_drift_dim</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.get_drift_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_drift_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the matrix that defines the drift dynamics
that is assuming the drift is NxN, then this returns N</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.get_dyn_gen">
<code class="sig-name descname"><span class="pre">get_dyn_gen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.get_dyn_gen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the combined dynamics generator for the timeslot
Not implemented in the base class. Choose a subclass</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.get_num_ctrls">
<code class="sig-name descname"><span class="pre">get_num_ctrls</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.get_num_ctrls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.init_timeslots">
<code class="sig-name descname"><span class="pre">init_timeslots</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.init_timeslots"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.init_timeslots" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the timeslot duration array ‘tau’ based on the evo_time
and num_tslots attributes, unless the tau attribute is already set
in which case this step in ignored
Generate the cumulative time array ‘time’ based on the tau values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.initialize_controls">
<code class="sig-name descname"><span class="pre">initialize_controls</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.initialize_controls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.initialize_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial control amplitudes and time slices
Note this must be called after the configuration is complete
before any dynamics can be calculated</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.num_ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">num_ctrls</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.onto_evo">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">onto_evo</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.onto_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.onwd_evo">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">onwd_evo</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.onwd_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.phase_application">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">phase_application</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.phase_application" title="Permalink to this definition">¶</a></dt>
<dd><p>scalar(string), default=’preop’
Determines how the phase is applied to the dynamics generators</p>
<ul class="simple">
<li><p>‘preop’  : P = expm(phase*dyn_gen)</p></li>
<li><p>‘postop’ : P = expm(dyn_gen*phase)</p></li>
<li><p>‘custom’ : Customised phase application</p></li>
</ul>
<p>The ‘custom’ option assumes that the _apply_phase method has been
set to a custom function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>phase_application</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.prop">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">prop</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.prop" title="Permalink to this definition">¶</a></dt>
<dd><p>List of propagators (Qobj) for each timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.prop_grad">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">prop_grad</span></code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.prop_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of propagator gradients (Qobj) for each timeslot, control</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.refresh_drift_attribs">
<code class="sig-name descname"><span class="pre">refresh_drift_attribs</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.refresh_drift_attribs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.refresh_drift_attribs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.save_amps">
<code class="sig-name descname"><span class="pre">save_amps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.save_amps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.save_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the current control amplitudes in each timeslot
The first column in the file will be the start time of the slot</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name</strong><span class="classifier">string</span></dt><dd><p>Name of the file
If None given the def_amps_fname attribuite will be used</p>
</dd>
<dt><strong>times</strong><span class="classifier">List type (or string)</span></dt><dd><p>List / array of the start times for each slot
If None given this will be retrieved through get_amp_times()
If ‘exclude’ then times will not be saved in the file, just
the amplitudes</p>
</dd>
<dt><strong>amps</strong><span class="classifier">Array[num_tslots, num_ctrls]</span></dt><dd><p>Amplitudes to be saved
If None given the ctrl_amps attribute will be used</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">Boolean</span></dt><dd><p>If True then an info message will be logged</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.unitarity_check">
<code class="sig-name descname"><span class="pre">unitarity_check</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.unitarity_check"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.unitarity_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all propagators are unitary</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.Dynamics.update_ctrl_amps">
<code class="sig-name descname"><span class="pre">update_ctrl_amps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_amps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#Dynamics.update_ctrl_amps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.update_ctrl_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if any amplitudes have changed. If so, then mark the
timeslots as needing recalculation
The actual work is completed by the compare_amps method of the
timeslot computer</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dynamics.DynamicsGenMat">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DynamicsGenMat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimconfig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#DynamicsGenMat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsGenMat" title="Permalink to this definition">¶</a></dt>
<dd><p>This sub class can be used for any system where no additional
operator is applied to the dynamics generator before calculating
the propagator, e.g. classical dynamics, Lindbladian</p>
</dd></dl>

<dl class="py class">
<dt id="qutip.control.dynamics.DynamicsUnitary">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DynamicsUnitary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimconfig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#DynamicsUnitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the subclass to use for systems with dynamics described by
unitary matrices. E.g. closed systems with Hermitian Hamiltonians
Note a matrix diagonalisation is used to compute the exponent
The eigen decomposition is also used to calculate the propagator gradient.
The method is taken from DYNAMO (see file header)</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drift_ham</strong><span class="classifier">Qobj</span></dt><dd><p>This is the drift Hamiltonian for unitary dynamics
It is mapped to drift_dyn_gen during initialize_controls</p>
</dd>
<dt><strong>ctrl_ham</strong><span class="classifier">List of Qobj</span></dt><dd><p>These are the control Hamiltonians for unitary dynamics
It is mapped to ctrl_dyn_gen during initialize_controls</p>
</dd>
<dt><strong>H</strong><span class="classifier">List of Qobj</span></dt><dd><p>The combined drift and control Hamiltonians for each timeslot
These are the dynamics generators for unitary dynamics.
It is mapped to dyn_gen during initialize_controls</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dynamics.DynamicsUnitary.check_unitarity">
<code class="sig-name descname"><span class="pre">check_unitarity</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#DynamicsUnitary.check_unitarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.check_unitarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all propagators are unitary
For propagators found not to be unitary, the potential underlying
causes are investigated.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.DynamicsUnitary.initialize_controls">
<code class="sig-name descname"><span class="pre">initialize_controls</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amplitudes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_tslots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#DynamicsUnitary.initialize_controls"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.initialize_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial control amplitudes and time slices
Note this must be called after the configuration is complete
before any dynamics can be calculated</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dynamics.DynamicsUnitary.num_ctrls">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">num_ctrls</span></code><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dynamics.DynamicsSymplectic">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DynamicsSymplectic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimconfig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dynamics.html#DynamicsSymplectic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsSymplectic" title="Permalink to this definition">¶</a></dt>
<dd><p>Symplectic systems
This is the subclass to use for systems where the dynamics is described
by symplectic matrices, e.g. coupled oscillators, quantum optics</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>omega</strong><span class="classifier">array[drift_dyn_gen.shape]</span></dt><dd><p>matrix used in the calculation of propagators (time evolution)
with symplectic systems.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dynamics.DynamicsSymplectic.dyn_gen_phase">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dyn_gen_phase</span></code><a class="headerlink" href="#qutip.control.dynamics.DynamicsSymplectic.dyn_gen_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>The phasing operator for the symplectic group generators
usually refered to as Omega
By default this is applied as ‘postop’ dyn_gen*-Omega
If phase_application is ‘preop’ it is applied as Omega*dyn_gen</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.propcomp.PropagatorComputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PropagatorComputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropagatorComputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base for all  Propagator Computer classes
that are used to calculate the propagators,
and also the propagator gradient when exact gradient methods are used
Note: they must be instantiated with a Dynamics object, that is the
container for the data that the functions operate on
This base class cannot be used directly. See subclass descriptions
and choose the appropriate one for the application</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip_utils.logging,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>grad_exact</strong><span class="classifier">boolean</span></dt><dd><p>indicates whether the computer class instance is capable
of computing propagator gradients. It is used to determine
whether to create the Dynamics prop_grad array</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.propcomp.PropagatorComputer.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropagatorComputer.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.propcomp.PropagatorComputer.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropagatorComputer.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.propcomp.PropCompApproxGrad">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PropCompApproxGrad</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompApproxGrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompApproxGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>This subclass can be used when the propagator is calculated simply
by expm of the dynamics generator, i.e. when gradients will be calculated
using approximate methods.</p>
<dl class="py method">
<dt id="qutip.control.propcomp.PropCompApproxGrad.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompApproxGrad.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompApproxGrad.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.propcomp.PropCompDiag">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PropCompDiag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompDiag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompDiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Coumputes the propagator exponentiation using diagonalisation of
of the dynamics generator</p>
<dl class="py method">
<dt id="qutip.control.propcomp.PropCompDiag.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompDiag.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompDiag.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.propcomp.PropCompFrechet">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PropCompFrechet</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompFrechet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompFrechet" title="Permalink to this definition">¶</a></dt>
<dd><p>Frechet method for calculating the propagator: exponentiating the combined
dynamics generator and the propagator gradient. It should work for all
systems, e.g. unitary, open, symplectic. There are other
<a class="reference internal" href="#qutip.control.propcomp.PropagatorComputer" title="qutip.control.propcomp.PropagatorComputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PropagatorComputer</span></code></a> subclasses that may be more efficient.</p>
<dl class="py method">
<dt id="qutip.control.propcomp.PropCompFrechet.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/propcomp.html#PropCompFrechet.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompFrechet.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.fidcomp.FidelityComputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">FidelityComputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all Fidelity Computers.
This cannot be used directly. See subclass descriptions and choose
one appropriate for the application
Note: this must be instantiated with a Dynamics object, that is the
container for the data that the methods operate on</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>dimensional_norm</strong><span class="classifier">float</span></dt><dd><p>Normalisation constant</p>
</dd>
<dt><strong>fid_norm_func</strong><span class="classifier">function</span></dt><dd><p>Used to normalise the fidelity
See SU and PSU options for the unitary dynamics</p>
</dd>
<dt><strong>grad_norm_func</strong><span class="classifier">function</span></dt><dd><p>Used to normalise the fidelity gradient
See SU and PSU options for the unitary dynamics</p>
</dd>
<dt><strong>uses_onwd_evo</strong><span class="classifier">boolean</span></dt><dd><p>flag to specify whether the onwd_evo evolution operator
(see Dynamics) is used by the FidelityComputer</p>
</dd>
<dt><strong>uses_onto_evo</strong><span class="classifier">boolean</span></dt><dd><dl class="simple">
<dt>flag to specify whether the onto_evo evolution operator</dt><dd><p>(see Dynamics) is used by the FidelityComputer</p>
</dd>
</dl>
</dd>
<dt><strong>fid_err</strong><span class="classifier">float</span></dt><dd><p>Last computed value of the fidelity error</p>
</dd>
<dt><strong>fidelity</strong><span class="classifier">float</span></dt><dd><p>Last computed value of the normalised fidelity</p>
</dd>
<dt><strong>fidelity_current</strong><span class="classifier">boolean</span></dt><dd><p>flag to specify whether the fidelity / fid_err are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
<dt><strong>fid_err_grad: array[num_tslot, num_ctrls] of float</strong></dt><dd><p>Last computed values for the fidelity error gradients wrt the
control in the timeslot</p>
</dd>
<dt><strong>grad_norm</strong><span class="classifier">float</span></dt><dd><p>Last computed value for the norm of the fidelity error gradients
(sqrt of the sum of the squares)</p>
</dd>
<dt><strong>fid_err_grad_current</strong><span class="classifier">boolean</span></dt><dd><p>flag to specify whether the fidelity / fid_err are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.clear">
<code class="sig-name descname"><span class="pre">clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear any temporarily held status data</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.flag_system_changed">
<code class="sig-name descname"><span class="pre">flag_system_changed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.flag_system_changed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.get_fid_err">
<code class="sig-name descname"><span class="pre">get_fid_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.get_fid_err"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the absolute distance from the maximum achievable fidelity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient">
<code class="sig-name descname"><span class="pre">get_fid_err_gradient</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.get_fid_err_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.init_comp">
<code class="sig-name descname"><span class="pre">init_comp</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.init_comp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>initialises the computer based on the configuration of the Dynamics</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidelityComputer.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidelityComputer.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.fidcomp.FidCompUnitary">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">FidCompUnitary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes fidelity error and gradient assuming unitary dynamics, e.g.
closed qubit systems
Note fidelity and gradient calculations were taken from DYNAMO
(see file header)</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phase_option</strong><span class="classifier">string</span></dt><dd><dl class="simple">
<dt>determines how global phase is treated in fidelity calculations:</dt><dd><p>PSU - global phase ignored
SU - global phase included</p>
</dd>
</dl>
</dd>
<dt><strong>fidelity_prenorm</strong><span class="classifier">complex</span></dt><dd><p>Last computed value of the fidelity before it is normalised
It is stored to use in the gradient normalisation calculation</p>
</dd>
<dt><strong>fidelity_prenorm_current</strong><span class="classifier">boolean</span></dt><dd><p>flag to specify whether fidelity_prenorm are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.clear">
<code class="sig-name descname"><span class="pre">clear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear any temporarily held status data</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.compute_fid_grad">
<code class="sig-name descname"><span class="pre">compute_fid_grad</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.compute_fid_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.compute_fid_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates exact gradient of function wrt to each timeslot
control amplitudes. Note these gradients are not normalised
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.flag_system_changed">
<code class="sig-name descname"><span class="pre">flag_system_changed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.flag_system_changed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fid_err">
<code class="sig-name descname"><span class="pre">get_fid_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.get_fid_err"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the absolute error in the fidelity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient">
<code class="sig-name descname"><span class="pre">get_fid_err_gradient</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.get_fid_err_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array
The gradients are cached in case they are requested
mutliple times between control updates
(although this is not typically found to happen)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fidelity">
<code class="sig-name descname"><span class="pre">get_fidelity</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.get_fidelity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the appropriately normalised fidelity value
The normalisation is determined by the fid_norm_func pointer
which should be set in the config</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm">
<code class="sig-name descname"><span class="pre">get_fidelity_prenorm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.get_fidelity_prenorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current fidelity value prior to normalisation
Note the gradient function uses this value
The value is cached, because it is used in the gradient calculation</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.init_comp">
<code class="sig-name descname"><span class="pre">init_comp</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.init_comp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check configuration and initialise the normalisation</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.init_normalization">
<code class="sig-name descname"><span class="pre">init_normalization</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.init_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.init_normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Calc norm of &lt;Ufinal | Ufinal&gt; to scale subsequent norms
When considering unitary time evolution operators, this basically
results in calculating the trace of the identity matrix
and is hence equal to the size of the target matrix
There may be situations where this is not the case, and hence it
is not assumed to be so.
The normalisation function called should be set to either the
PSU - global phase ignored
SU  - global phase respected</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_PSU">
<code class="sig-name descname"><span class="pre">normalize_PSU</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_PSU"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_PSU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_SU">
<code class="sig-name descname"><span class="pre">normalize_SU</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_SU"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_SU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU">
<code class="sig-name descname"><span class="pre">normalize_gradient_PSU</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_gradient_PSU"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalise the gradient matrix passed as grad
This PSU version is independent of global phase</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU">
<code class="sig-name descname"><span class="pre">normalize_gradient_SU</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_gradient_SU"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalise the gradient matrix passed as grad
This SU version respects global phase</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompUnitary.set_phase_option">
<code class="sig-name descname"><span class="pre">set_phase_option</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phase_option</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompUnitary.set_phase_option"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.set_phase_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated - use phase_option
Phase options are
SU - global phase important
PSU - global phase is not important</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.fidcomp.FidCompTraceDiff">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">FidCompTraceDiff</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes fidelity error and gradient for general system dynamics
by calculating the the fidelity error as the trace of the overlap
of the difference between the target and evolution resulting from
the pulses with the transpose of the same.
This should provide a distance measure for dynamics described by matrices
Note the gradient calculation is taken from:
‘Robust quantum gates for open systems via optimal control:
Markovian versus non-Markovian dynamics’
Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale_factor</strong><span class="classifier">float</span></dt><dd><p>The fidelity error calculated is of some arbitary scale. This
factor can be used to scale the fidelity error such that it may
represent some physical measure
If None is given then it is caculated as 1/2N, where N
is the dimension of the drift, when the Dynamics are initialised.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad">
<code class="sig-name descname"><span class="pre">compute_fid_err_grad</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff.compute_fid_err_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate exact gradient of the fidelity error function
wrt to each timeslot control amplitudes.
Uses the trace difference norm fidelity
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err">
<code class="sig-name descname"><span class="pre">get_fid_err</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff.get_fid_err"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the absolute error in the fidelity</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient">
<code class="sig-name descname"><span class="pre">get_fid_err_gradient</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff.get_fid_err_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array
The gradients are cached in case they are requested
mutliple times between control updates
(although this is not typically found to happen)</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.init_comp">
<code class="sig-name descname"><span class="pre">init_comp</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff.init_comp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>initialises the computer based on the configuration of the Dynamics
Calculates the scale_factor is not already set</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiff.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">FidCompTraceDiffApprox</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox" title="Permalink to this definition">¶</a></dt>
<dd><p>As FidCompTraceDiff, except uses the finite difference method to
compute approximate gradients</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>epsilon</strong><span class="classifier">float</span></dt><dd><p>control amplitude offset to use when approximating the gradient wrt
a timeslot control amplitude</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad">
<code class="sig-name descname"><span class="pre">compute_fid_err_grad</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox.compute_fid_err_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates gradient of function wrt to each timeslot
control amplitudes. Note these gradients are not normalised
They are calulated
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.tslotcomp.TimeslotComputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">TimeslotComputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TimeslotComputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all Timeslot Computers
Note: this must be instantiated with a Dynamics object, that is the
container for the data that the methods operate on</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>evo_comp_summary</strong><span class="classifier">EvoCompSummary</span></dt><dd><p>A summary of the most recent evolution computation
Used in the stats and dump
Will be set to None if neither stats or dump are set</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.tslotcomp.TimeslotComputer.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TimeslotComputer.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.tslotcomp.TimeslotComputer.dump_current">
<code class="sig-name descname"><span class="pre">dump_current</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TimeslotComputer.dump_current"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer.dump_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a copy of the current time evolution</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">TSlotCompUpdateAll</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Timeslot Computer - Update All
Updates all dynamics generators, propagators and evolutions when
ctrl amplitudes are updated</p>
<dl class="py method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps">
<code class="sig-name descname"><span class="pre">compare_amps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_amps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.compare_amps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if any amplitudes have changed. If so, then mark the
timeslots as needing recalculation
Returns: True if amplitudes are the same, False if they have changed</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc">
<code class="sig-name descname"><span class="pre">get_timeslot_for_fidelity_calc</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.get_timeslot_for_fidelity_calc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeslot index that will be used calculate current fidelity
value.
This (default) method simply returns the last timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution">
<code class="sig-name descname"><span class="pre">recompute_evolution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.recompute_evolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculates the evolution operators.
Dynamics generators (e.g. Hamiltonian) and
prop (propagators) are calculated as necessary</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGen">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGen</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulse generator
Base class for all Pulse generators
The object can optionally be instantiated with a Dynamics object,
in which case the timeslots and amplitude scaling and offset
are copied from that.
Otherwise the class can be used independently by setting:
tau (array of timeslot durations)
or
num_tslots and pulse_time for equally spaced timeslots</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_tslots</strong><span class="classifier">integer</span></dt><dd><p>Number of timeslots, aka timeslices
(copied from Dynamics if given)</p>
</dd>
<dt><strong>pulse_time</strong><span class="classifier">float</span></dt><dd><p>total duration of the pulse
(copied from Dynamics.evo_time if given)</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">float</span></dt><dd><p>linear scaling applied to the pulse
(copied from Dynamics.initial_ctrl_scaling if given)</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float</span></dt><dd><p>linear offset applied to the pulse
(copied from Dynamics.initial_ctrl_offset if given)</p>
</dd>
<dt><strong>tau</strong><span class="classifier">array[num_tslots] of float</span></dt><dd><p>Duration of each timeslot
(copied from Dynamics if given)</p>
</dd>
<dt><strong>lbound</strong><span class="classifier">float</span></dt><dd><p>Lower boundary for the pulse amplitudes
Note that the scaling and offset attributes can be used to fully
bound the pulse for all generators except some of the random ones
This bound (if set) may result in additional shifting / scaling
Default is -Inf</p>
</dd>
<dt><strong>ubound</strong><span class="classifier">float</span></dt><dd><p>Upper boundary for the pulse amplitudes
Note that the scaling and offset attributes can be used to fully
bound the pulse for all generators except some of the random ones
This bound (if set) may result in additional shifting / scaling
Default is Inf</p>
</dd>
<dt><strong>periodic</strong><span class="classifier">boolean</span></dt><dd><p>True if the pulse generator produces periodic pulses</p>
</dd>
<dt><strong>random</strong><span class="classifier">boolean</span></dt><dd><p>True if the pulse generator produces random pulses</p>
</dd>
<dt><strong>log_level</strong><span class="classifier">integer</span></dt><dd><p>level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively ‘quiet’ execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGen.apply_params">
<code class="sig-name descname"><span class="pre">apply_params</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGen.apply_params"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGen.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGen.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the pulse as an array of vales for each timeslot
Must be implemented by subclass</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGen.init_pulse">
<code class="sig-name descname"><span class="pre">init_pulse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGen.init_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the pulse parameters</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGen.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGen.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenRandom">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenRandom</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenRandom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random pulses as simply random values for each timeslot</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenRandom.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenRandom.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse of random values between 1 and -1
Values are scaled using the scaling property
and shifted using the offset property
Returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenRandom.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenRandom.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenZero">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenZero</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenZero"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat pulse</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenZero.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenZero.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenZero.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse with the same value in every timeslot.
The value will be zero, unless the offset is not zero,
in which case it will be the offset</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenLinear">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenLinear</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenLinear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates linear pulses</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gradient</strong><span class="classifier">float</span></dt><dd><p>Gradient of the line.
Note this is calculated from the start_val and end_val if these
are given</p>
</dd>
<dt><strong>start_val</strong><span class="classifier">float</span></dt><dd><p>Start point of the line. That is the starting amplitude</p>
</dd>
<dt><strong>end_val</strong><span class="classifier">float</span></dt><dd><p>End point of the line.
That is the amplitude at the start of the last timeslot</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenLinear.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenLinear.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a linear pulse using either the gradient and start value
or using the end point to calulate the gradient
Note that the scaling and offset parameters are still applied,
so unless these values are the default 1.0 and 0.0, then the
actual gradient etc will be different
Returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenLinear.init_pulse">
<code class="sig-name descname"><span class="pre">init_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenLinear.init_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the gradient if pulse is defined by start and
end point values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenLinear.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenLinear.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenPeriodic">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenPeriodic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenPeriodic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate class for all periodic pulse generators
All of the periodic pulses range from -1 to 1
All have a start phase that can be set between 0 and 2pi</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_waves</strong><span class="classifier">float</span></dt><dd><p>Number of complete waves (cycles) that occur in the pulse.
wavelen and freq calculated from this if it is given</p>
</dd>
<dt><strong>wavelen</strong><span class="classifier">float</span></dt><dd><p>Wavelength of the pulse (assuming the speed is 1)
freq is calculated from this if it is given</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Frequency of the pulse</p>
</dd>
<dt><strong>start_phase</strong><span class="classifier">float</span></dt><dd><p>Phase of the pulse signal when t=0</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenPeriodic.init_pulse">
<code class="sig-name descname"><span class="pre">init_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenPeriodic.init_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the wavelength, frequency, number of waves etc
from the each other and the other parameters
If num_waves is given then the other parameters are worked from this
Otherwise if the wavelength is given then it is the driver
Otherwise the frequency is used to calculate wavelength and num_waves</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenPeriodic.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenPeriodic.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenSine">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenSine</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSine" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sine wave pulses</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenSine.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSine.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSine.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sine wave pulse
If no params are provided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs.
returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenSquare">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenSquare</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSquare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates square wave pulses</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenSquare.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSquare.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSquare.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a square wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenSaw">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenSaw</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSaw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSaw" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates saw tooth wave pulses</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenSaw.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenSaw.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSaw.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a saw tooth wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenTriangle">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenTriangle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenTriangle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenTriangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates triangular wave pulses</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenTriangle.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_waves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenTriangle.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenTriangle.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sine wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenGaussian">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenGaussian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates pulses with a Gaussian profile</p>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenGaussian.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussian.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse with Gaussian shape. The peak is centre around the
mean and the variance determines the breadth
The scaling and offset attributes are applied as an amplitude
and fixed linear offset. Note that the maximum amplitude will be
scaling + offset.</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenGaussian.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussian.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenGaussianEdge</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussianEdge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate pulses with inverted Gaussian ramping in and out
It’s intended use for a ramping modulation, which is often required in
experimental setups.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decay_time</strong><span class="classifier">float</span></dt><dd><p>Determines the ramping rate. It is approximately the time
required to bring the pulse to full amplitude
It is set to 1/10 of the pulse time by default</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decay_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussianEdge.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse that starts and ends at zero and 1.0 in between
then apply scaling and offset
The tailing in and out is an inverted Gaussian shape</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenGaussianEdge.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenCrab">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenCrab</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all CRAB pulse generators
Note these are more involved in the optimisation process as they are
used to produce piecewise control amplitudes each time new optimisation
parameters are tried</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function</p>
</dd>
<dt><strong>num_basis_funcs</strong><span class="classifier">integer</span></dt><dd><p>Number of basis functions
In this case set at 2 and should not be changed</p>
</dd>
<dt><strong>coeffs</strong><span class="classifier">float array[num_coeffs, num_basis_funcs]</span></dt><dd><p>The basis coefficient values</p>
</dd>
<dt><strong>randomize_coeffs</strong><span class="classifier">bool</span></dt><dd><p>If True (default) then the coefficients are set to some random values
when initialised, otherwise they will all be equal to self.scaling</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs">
<code class="sig-name descname"><span class="pre">estimate_num_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.estimate_num_coeffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the number coefficients based on the dimensionality of the
system.
:returns: <strong>num_coeffs</strong> – estimated number of coefficients
:rtype: int</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals">
<code class="sig-name descname"><span class="pre">get_optim_var_vals</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.get_optim_var_vals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameter values to be optimised
:returns:
:rtype: list (or 1d array) of floats</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.init_coeffs">
<code class="sig-name descname"><span class="pre">init_coeffs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.init_coeffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.init_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the initial ceofficent values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_coeffs</strong><span class="classifier">integer</span></dt><dd><p>Number of coefficients used for each basis function
If given this overides the default and sets the attribute
of the same name.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.init_pulse">
<code class="sig-name descname"><span class="pre">init_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.init_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial freq and coefficient values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals">
<code class="sig-name descname"><span class="pre">set_optim_var_vals</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_vals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrab.set_optim_var_vals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the values of the any of the pulse generation parameters
based on new values from the optimisation method
Typically this will be the basis coefficients</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">PulseGenCrabFourier</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dyn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrabFourier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a pulse using the Fourier basis functions, i.e. sin and cos</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqs</strong><span class="classifier">float array[num_coeffs]</span></dt><dd><p>Frequencies for the basis functions</p>
</dd>
<dt><strong>randomize_freqs</strong><span class="classifier">bool</span></dt><dd><p>If True (default) the some random offset is applied to the frequencies</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse">
<code class="sig-name descname"><span class="pre">gen_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrabFourier.gen_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse using the Fourier basis with the freqs and
coeffs attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coeffs</strong><span class="classifier">float array[num_coeffs, num_basis_funcs]</span></dt><dd><p>The basis coefficient values
If given this overides the default and sets the attribute
of the same name.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.init_freqs">
<code class="sig-name descname"><span class="pre">init_freqs</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrabFourier.init_freqs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_freqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the frequencies
These are the Fourier harmonics with a uniformly distributed
random offset</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.init_pulse">
<code class="sig-name descname"><span class="pre">init_pulse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_coeffs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrabFourier.init_pulse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial freq and coefficient values</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.reset">
<code class="sig-name descname"><span class="pre">reset</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/pulsegen.html#PulseGenCrabFourier.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.stats.Stats">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Stats</span></code><a class="reference internal" href="../modules/qutip/control/stats.html#Stats"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.stats.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all optimisation statistics
Used for configurations where all timeslots are updated each iteration
e.g. exact gradients
Note that all times are generated using timeit.default_timer() and are
in seconds</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dyn_gen_name</strong><span class="classifier">string</span></dt><dd><p>Text used in some report functions.
Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics
Default is simply ‘dynamics generator’</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">integer</span></dt><dd><p>Number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>wall_time_optim_start</strong><span class="classifier">float</span></dt><dd><p>Start time for the optimisation</p>
</dd>
<dt><strong>wall_time_optim_end</strong><span class="classifier">float</span></dt><dd><p>End time for the optimisation</p>
</dd>
<dt><strong>wall_time_optim</strong><span class="classifier">float</span></dt><dd><p>Time elasped during the optimisation</p>
</dd>
<dt><strong>wall_time_dyn_gen_compute</strong><span class="classifier">float</span></dt><dd><p>Total wall (elasped) time computing combined dynamics generator
(for example combining drift and control Hamiltonians)</p>
</dd>
<dt><strong>wall_time_prop_compute</strong><span class="classifier">float</span></dt><dd><p>Total wall (elasped) time computing propagators, that is the
time evolution from one timeslot to the next
Includes calculating the propagator gradient for exact gradients</p>
</dd>
<dt><strong>wall_time_fwd_prop_compute</strong><span class="classifier">float</span></dt><dd><p>Total wall (elasped) time computing combined forward propagation,
that is the time evolution from the start to a specific timeslot.
Excludes calculating the propagators themselves</p>
</dd>
<dt><strong>wall_time_onwd_prop_compute</strong><span class="classifier">float</span></dt><dd><p>Total wall (elasped) time computing combined onward propagation,
that is the time evolution from a specific timeslot to the end time.
Excludes calculating the propagators themselves</p>
</dd>
<dt><strong>wall_time_gradient_compute</strong><span class="classifier">float</span></dt><dd><p>Total wall (elasped) time computing the fidelity error gradient.
Excludes calculating the propagator gradients (in exact gradient
methods)</p>
</dd>
<dt><strong>num_fidelity_func_calls</strong><span class="classifier">integer</span></dt><dd><p>Number of calls to fidelity function by the optimisation algorithm</p>
</dd>
<dt><strong>num_grad_func_calls</strong><span class="classifier">integer</span></dt><dd><p>Number of calls to gradient function by the optimisation algorithm</p>
</dd>
<dt><strong>num_tslot_recompute</strong><span class="classifier">integer</span></dt><dd><p>Number of time the timeslot evolution is recomputed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_fidelity_computes</strong><span class="classifier">integer</span></dt><dd><p>Number of time the fidelity is computed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_grad_computes</strong><span class="classifier">integer</span></dt><dd><p>Number of time the gradient is computed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_ctrl_amp_updates</strong><span class="classifier">integer</span></dt><dd><p>Number of times the control amplitudes are updated</p>
</dd>
<dt><strong>mean_num_ctrl_amp_updates_per_iter</strong><span class="classifier">float</span></dt><dd><p>Mean number of control amplitude updates per iteration</p>
</dd>
<dt><strong>num_timeslot_changes</strong><span class="classifier">integer</span></dt><dd><p>Number of times the amplitudes of a any control in a timeslot changes</p>
</dd>
<dt><strong>mean_num_timeslot_changes_per_update</strong><span class="classifier">float</span></dt><dd><p>Mean average number of timeslot amplitudes that are changed per update</p>
</dd>
<dt><strong>num_ctrl_amp_changes</strong><span class="classifier">integer</span></dt><dd><p>Number of times individual control amplitudes that are changed</p>
</dd>
<dt><strong>mean_num_ctrl_amp_changes_per_update</strong><span class="classifier">float</span></dt><dd><p>Mean average number of control amplitudes that are changed per update</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.stats.Stats.calculate">
<code class="sig-name descname"><span class="pre">calculate</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/stats.html#Stats.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.stats.Stats.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the calculations (e.g. averages) that are required on the stats
Should be called before calling report</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.stats.Stats.report">
<code class="sig-name descname"><span class="pre">report</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/stats.html#Stats.report"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.stats.Stats.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a report of the stats to the console</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.Dump">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">Dump</span></code><a class="reference internal" href="../modules/qutip/control/dump.html#Dump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.Dump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dump items.
The lists for dump items is depends on the type
Note: abstract class</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>parent</strong><span class="classifier">some control object (Dynamics or Optimizer)</span></dt><dd><p>aka the host. Object that generates the data that is dumped and is
host to this dump object.</p>
</dd>
<dt><strong>dump_dir</strong><span class="classifier">str</span></dt><dd><p>directory where files (if any) will be written out
the path and be relative or absolute
use ~/ to specify user home directory
Note: files are only written when write_to_file is True
of writeout is called explicitly
Defaults to ~/.qtrl_dump</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dump.Dump.level" title="qutip.control.dump.Dump.level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">level</span></code></a><span class="classifier">string</span></dt><dd><p>The level of data dumping that will occur.</p>
</dd>
<dt><strong>write_to_file</strong><span class="classifier">bool</span></dt><dd><p>When set True data and summaries (as configured) will be written
interactively to file during the processing
Set during instantiation by the host based on its dump_to_file attrib</p>
</dd>
<dt><strong>dump_file_ext</strong><span class="classifier">str</span></dt><dd><p>Default file extension for any file names that are auto generated</p>
</dd>
<dt><strong>fname_base</strong><span class="classifier">str</span></dt><dd><p>First part of any auto generated file names.
This is usually overridden in the subclass</p>
</dd>
<dt><strong>dump_summary</strong><span class="classifier">bool</span></dt><dd><p>If True a summary is recorded each time a new item is added to the
the dump.
Default is True</p>
</dd>
<dt><strong>summary_sep</strong><span class="classifier">str</span></dt><dd><p>delimiter for the summary file.
default is a space</p>
</dd>
<dt><strong>data_sep</strong><span class="classifier">str</span></dt><dd><p>delimiter for the data files (arrays saved to file).
default is a space</p>
</dd>
<dt><strong>summary_file</strong><span class="classifier">str</span></dt><dd><p>File path for summary file.
Automatically generated. Can be set specifically</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dump.Dump.create_dump_dir">
<code class="sig-name descname"><span class="pre">create_dump_dir</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#Dump.create_dump_dir"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.Dump.create_dump_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks dump directory exists, creates it if not</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.Dump.level">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">level</span></code><a class="headerlink" href="#qutip.control.dump.Dump.level" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of data dumping that will occur.</p>
<dl class="simple">
<dt>SUMMARY</dt><dd><p>A summary will be recorded</p>
</dd>
<dt>FULL</dt><dd><p>All possible dumping</p>
</dd>
<dt>CUSTOM</dt><dd><p>Some customised level of dumping</p>
</dd>
</dl>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify what specifically is dumped</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.OptimDump">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">OptimDump</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SUMMARY'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dumps of optimisation data generated during the pulse
optimisation.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>dump_summary</strong><span class="classifier">bool</span></dt><dd><p>When True summary items are appended to the iter_summary</p>
</dd>
<dt><strong>iter_summary</strong><span class="classifier">list of <a class="reference internal" href="#qutip.control.optimizer.OptimIterSummary" title="qutip.control.optimizer.OptimIterSummary"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.control.optimizer.OptimIterSummary</span></code></a></span></dt><dd><p>Summary at each iteration</p>
</dd>
<dt><strong>dump_fid_err</strong><span class="classifier">bool</span></dt><dd><p>When True values are appended to the fid_err_log</p>
</dd>
<dt><strong>fid_err_log</strong><span class="classifier">list of float</span></dt><dd><p>Fidelity error at each call of the fid_err_func</p>
</dd>
<dt><strong>dump_grad_norm</strong><span class="classifier">bool</span></dt><dd><p>When True values are appended to the fid_err_log</p>
</dd>
<dt><strong>grad_norm_log</strong><span class="classifier">list of float</span></dt><dd><p>Gradient norm at each call of the grad_norm_log</p>
</dd>
<dt><strong>dump_grad</strong><span class="classifier">bool</span></dt><dd><p>When True values are appended to the grad_log</p>
</dd>
<dt><strong>grad_log</strong><span class="classifier">list of ndarray</span></dt><dd><p>Gradients at each call of the fid_grad_func</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dump.OptimDump.add_iter_summary">
<code class="sig-name descname"><span class="pre">add_iter_summary</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump.add_iter_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.add_iter_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>add copy of current optimizer iteration summary</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.dump_all">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dump_all</span></code><a class="headerlink" href="#qutip.control.dump.OptimDump.dump_all" title="Permalink to this definition">¶</a></dt>
<dd><p>True if everything (ignoring the summary) is to be dumped</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.dump_any">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dump_any</span></code><a class="headerlink" href="#qutip.control.dump.OptimDump.dump_any" title="Permalink to this definition">¶</a></dt>
<dd><p>True if anything other than the summary is to be dumped</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.update_fid_err_log">
<code class="sig-name descname"><span class="pre">update_fid_err_log</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fid_err</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump.update_fid_err_log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_fid_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the fid_err log</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.update_grad_log">
<code class="sig-name descname"><span class="pre">update_grad_log</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump.update_grad_log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_grad_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the grad log</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.update_grad_norm_log">
<code class="sig-name descname"><span class="pre">update_grad_norm_log</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grad_norm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump.update_grad_norm_log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_grad_norm_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the grad_norm log</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.OptimDump.writeout">
<code class="sig-name descname"><span class="pre">writeout</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#OptimDump.writeout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>write all the logs and the summary out to file(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f</strong><span class="classifier">filename or filehandle</span></dt><dd><p>If specified then all summary and  object data will go in one file.
If None is specified then type specific files will be generated
in the dump_dir
If a filehandle is specified then it must be a byte mode file
as numpy.savetxt is used, and requires this.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.DynamicsDump">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DynamicsDump</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamics</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SUMMARY'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#DynamicsDump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dumps of dynamics data. Mainly time evolution calculations.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>dump_summary</strong><span class="classifier">bool</span></dt><dd><p>If True a summary is recorded</p>
</dd>
<dt><strong>evo_summary</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">tslotcomp.EvoCompSummary</span></code></span></dt><dd><p>Summary items are appended if dump_summary is True
at each recomputation of the evolution.</p>
</dd>
<dt><strong>dump_amps</strong><span class="classifier">bool</span></dt><dd><p>If True control amplitudes are dumped</p>
</dd>
<dt><strong>dump_dyn_gen</strong><span class="classifier">bool</span></dt><dd><p>If True the dynamics generators (Hamiltonians) are dumped</p>
</dd>
<dt><strong>dump_prop</strong><span class="classifier">bool</span></dt><dd><p>If True propagators are dumped</p>
</dd>
<dt><strong>dump_prop_grad</strong><span class="classifier">bool</span></dt><dd><p>If True propagator gradients are dumped</p>
</dd>
<dt><strong>dump_fwd_evo</strong><span class="classifier">bool</span></dt><dd><p>If True forward evolution operators are dumped</p>
</dd>
<dt><strong>dump_onwd_evo</strong><span class="classifier">bool</span></dt><dd><p>If True onward evolution operators are dumped</p>
</dd>
<dt><strong>dump_onto_evo</strong><span class="classifier">bool</span></dt><dd><p>If True onto (or backward) evolution operators are dumped</p>
</dd>
<dt><strong>evo_dumps</strong><span class="classifier">list of <a class="reference internal" href="#qutip.control.dump.EvoCompDumpItem" title="qutip.control.dump.EvoCompDumpItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">EvoCompDumpItem</span></code></a></span></dt><dd><p>A new dump item is appended at each recomputation of the evolution.
That is if any of the calculation objects are to be dumped.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="qutip.control.dump.DynamicsDump.add_evo_comp_summary">
<code class="sig-name descname"><span class="pre">add_evo_comp_summary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_item_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#DynamicsDump.add_evo_comp_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.add_evo_comp_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>add copy of current evo comp summary</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.DynamicsDump.add_evo_dump">
<code class="sig-name descname"><span class="pre">add_evo_dump</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#DynamicsDump.add_evo_dump"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.add_evo_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dump of current time evolution generating objects</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.DynamicsDump.dump_all">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dump_all</span></code><a class="headerlink" href="#qutip.control.dump.DynamicsDump.dump_all" title="Permalink to this definition">¶</a></dt>
<dd><p>True if all of the calculation objects are to be dumped</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.DynamicsDump.dump_any">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">dump_any</span></code><a class="headerlink" href="#qutip.control.dump.DynamicsDump.dump_any" title="Permalink to this definition">¶</a></dt>
<dd><p>True if any of the calculation objects are to be dumped</p>
</dd></dl>

<dl class="py method">
<dt id="qutip.control.dump.DynamicsDump.writeout">
<code class="sig-name descname"><span class="pre">writeout</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#DynamicsDump.writeout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Write all the dump items and the summary out to file(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f</strong><span class="classifier">filename or filehandle</span></dt><dd><p>If specified then all summary and object data will go in one file.
If None is specified then type specific files will be generated in
the dump_dir.  If a filehandle is specified then it must be a byte
mode file as numpy.savetxt is used, and requires this.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.DumpItem">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DumpItem</span></code><a class="reference internal" href="../modules/qutip/control/dump.html#DumpItem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DumpItem" title="Permalink to this definition">¶</a></dt>
<dd><p>An item in a dump list</p>
</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.EvoCompDumpItem">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">EvoCompDumpItem</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#EvoCompDumpItem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.EvoCompDumpItem" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of all objects generated to calculate one time evolution. Note the
attributes are only set if the corresponding <a class="reference internal" href="#qutip.control.dump.DynamicsDump" title="qutip.control.dump.DynamicsDump"><code class="xref py py-class docutils literal notranslate"><span class="pre">DynamicsDump</span></code></a>
<code class="docutils literal notranslate"><span class="pre">dump_*</span></code> attribute is set.</p>
<dl class="py method">
<dt id="qutip.control.dump.EvoCompDumpItem.writeout">
<code class="sig-name descname"><span class="pre">writeout</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/control/dump.html#EvoCompDumpItem.writeout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.EvoCompDumpItem.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>write all the objects out to files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f</strong><span class="classifier">filename or filehandle</span></dt><dd><p>If specified then all object data will go in one file.
If None is specified then type specific files will be generated
in the dump_dir
If a filehandle is specified then it must be a byte mode file
as numpy.savetxt is used, and requires this.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="qutip.control.dump.DumpSummaryItem">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">DumpSummaryItem</span></code><a class="reference internal" href="../modules/qutip/control/dump.html#DumpSummaryItem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.control.dump.DumpSummaryItem" title="Permalink to this definition">¶</a></dt>
<dd><p>A summary of the most recent iteration.  Abstract class only.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>Index in the summary list in which this is stored</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="apidoc.html" class="btn btn-neutral float-left" title="API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">
        Last updated on Aug 23, 2023.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>